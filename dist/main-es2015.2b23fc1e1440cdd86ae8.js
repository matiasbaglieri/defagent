(window.webpackJsonp = window.webpackJsonp || []).push([
  [7],
  {
    '+MLx': function(module, exports, __webpack_require__) {
      var aFunction = __webpack_require__('HAuM');
      module.exports = function(fn, that, length) {
        if ((aFunction(fn), void 0 === that)) return fn;
        switch (length) {
          case 0:
            return function() {
              return fn.call(that);
            };
          case 1:
            return function(a) {
              return fn.call(that, a);
            };
          case 2:
            return function(a, b) {
              return fn.call(that, a, b);
            };
          case 3:
            return function(a, b, c) {
              return fn.call(that, a, b, c);
            };
        }
        return function() {
          return fn.apply(that, arguments);
        };
      };
    },
    '/GqU': function(module, exports, __webpack_require__) {
      var IndexedObject = __webpack_require__('RK3t'),
        requireObjectCoercible = __webpack_require__('HYAF');
      module.exports = function(it) {
        return IndexedObject(requireObjectCoercible(it));
      };
    },
    '/byt': function(module, exports) {
      module.exports = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
      };
    },
    0: function(module, exports, __webpack_require__) {
      module.exports = __webpack_require__('zUnb');
    },
    '07d7': function(module, exports, __webpack_require__) {
      var redefine = __webpack_require__('busE'),
        toString = __webpack_require__('sEFX'),
        ObjectPrototype = Object.prototype;
      toString !== ObjectPrototype.toString &&
        redefine(ObjectPrototype, 'toString', toString, { unsafe: !0 });
    },
    '0BK2': function(module, exports) {
      module.exports = {};
    },
    '0Dky': function(module, exports) {
      module.exports = function(exec) {
        try {
          return !!exec();
        } catch (error) {
          return !0;
        }
      };
    },
    '0EUg': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return concatAll;
      });
      var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__('bHdf');
      function concatAll() {
        return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__.a)(1);
      }
    },
    '0GbY': function(module, exports, __webpack_require__) {
      var path = __webpack_require__('Qo9l'),
        global = __webpack_require__('2oRo'),
        aFunction = function(variable) {
          return 'function' == typeof variable ? variable : void 0;
        };
      module.exports = function(namespace, method) {
        return arguments.length < 2
          ? aFunction(path[namespace]) || aFunction(global[namespace])
          : (path[namespace] && path[namespace][method]) ||
              (global[namespace] && global[namespace][method]);
      };
    },
    '0QMH': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return hmrBootstrap;
      });
      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'fXoL'
        ),
        _angularclass_hmr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'rB/T'
        );
      function hmrBootstrap(module, bootstrap) {
        let ngModule;
        module.hot.accept(),
          bootstrap()
            .then(mod => (ngModule = mod))
            .catch(err => console.error(err)),
          module.hot.dispose(() => {
            const elements = ngModule.injector
                .get(_angular_core__WEBPACK_IMPORTED_MODULE_0__.g)
                .components.map(c => c.location.nativeElement),
              makeVisible = Object(
                _angularclass_hmr__WEBPACK_IMPORTED_MODULE_1__.createNewHosts
              )(elements);
            ngModule.destroy(), makeVisible();
          });
      }
    },
    '0eef': function(module, exports, __webpack_require__) {
      'use strict';
      var nativePropertyIsEnumerable = {}.propertyIsEnumerable,
        getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
        NASHORN_BUG =
          getOwnPropertyDescriptor &&
          !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
      exports.f = NASHORN_BUG
        ? function(V) {
            var descriptor = getOwnPropertyDescriptor(this, V);
            return !!descriptor && descriptor.enumerable;
          }
        : nativePropertyIsEnumerable;
    },
    '0rvr': function(module, exports, __webpack_require__) {
      var anObject = __webpack_require__('glrk'),
        aPossiblePrototype = __webpack_require__('O741');
      module.exports =
        Object.setPrototypeOf ||
        ('__proto__' in {}
          ? (function() {
              var setter,
                CORRECT_SETTER = !1,
                test = {};
              try {
                (setter = Object.getOwnPropertyDescriptor(
                  Object.prototype,
                  '__proto__'
                ).set).call(test, []),
                  (CORRECT_SETTER = test instanceof Array);
              } catch (error) {}
              return function(O, proto) {
                return (
                  anObject(O),
                  aPossiblePrototype(proto),
                  CORRECT_SETTER
                    ? setter.call(O, proto)
                    : (O.__proto__ = proto),
                  O
                );
              };
            })()
          : void 0);
    },
    '14Sl': function(module, exports, __webpack_require__) {
      'use strict';
      var hide = __webpack_require__('X2U+'),
        redefine = __webpack_require__('busE'),
        fails = __webpack_require__('0Dky'),
        wellKnownSymbol = __webpack_require__('tiKp'),
        regexpExec = __webpack_require__('kmMV'),
        SPECIES = wellKnownSymbol('species'),
        REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
          var re = /./;
          return (
            (re.exec = function() {
              var result = [];
              return (result.groups = { a: '7' }), result;
            }),
            '7' !== ''.replace(re, '$<a>')
          );
        }),
        SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
          var re = /(?:)/,
            originalExec = re.exec;
          re.exec = function() {
            return originalExec.apply(this, arguments);
          };
          var result = 'ab'.split(re);
          return 2 !== result.length || 'a' !== result[0] || 'b' !== result[1];
        });
      module.exports = function(KEY, length, exec, sham) {
        var SYMBOL = wellKnownSymbol(KEY),
          DELEGATES_TO_SYMBOL = !fails(function() {
            var O = {};
            return (
              (O[SYMBOL] = function() {
                return 7;
              }),
              7 != ''[KEY](O)
            );
          }),
          DELEGATES_TO_EXEC =
            DELEGATES_TO_SYMBOL &&
            !fails(function() {
              var execCalled = !1,
                re = /a/;
              return (
                (re.exec = function() {
                  return (execCalled = !0), null;
                }),
                'split' === KEY &&
                  ((re.constructor = {}),
                  (re.constructor[SPECIES] = function() {
                    return re;
                  })),
                re[SYMBOL](''),
                !execCalled
              );
            });
        if (
          !DELEGATES_TO_SYMBOL ||
          !DELEGATES_TO_EXEC ||
          ('replace' === KEY && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
          ('split' === KEY && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
        ) {
          var nativeRegExpMethod = /./[SYMBOL],
            methods = exec(SYMBOL, ''[KEY], function(
              nativeMethod,
              regexp,
              str,
              arg2,
              forceStringMethod
            ) {
              return regexp.exec === regexpExec
                ? DELEGATES_TO_SYMBOL && !forceStringMethod
                  ? {
                      done: !0,
                      value: nativeRegExpMethod.call(regexp, str, arg2)
                    }
                  : { done: !0, value: nativeMethod.call(str, regexp, arg2) }
                : { done: !1 };
            }),
            regexMethod = methods[1];
          redefine(String.prototype, KEY, methods[0]),
            redefine(
              RegExp.prototype,
              SYMBOL,
              2 == length
                ? function(string, arg) {
                    return regexMethod.call(string, this, arg);
                  }
                : function(string) {
                    return regexMethod.call(string, this);
                  }
            ),
            sham && hide(RegExp.prototype[SYMBOL], 'sham', !0);
        }
      };
    },
    '1E5z': function(module, exports, __webpack_require__) {
      var defineProperty = __webpack_require__('m/L8').f,
        has = __webpack_require__('UTVS'),
        TO_STRING_TAG = __webpack_require__('tiKp')('toStringTag');
      module.exports = function(it, TAG, STATIC) {
        it &&
          !has((it = STATIC ? it : it.prototype), TO_STRING_TAG) &&
          defineProperty(it, TO_STRING_TAG, { configurable: !0, value: TAG });
      };
    },
    '1G5W': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return takeUntil;
      });
      var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'l7GE'
        ),
        _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'ZUHj'
        );
      function takeUntil(notifier) {
        return source => source.lift(new TakeUntilOperator(notifier));
      }
      class TakeUntilOperator {
        constructor(notifier) {
          this.notifier = notifier;
        }
        call(subscriber, source) {
          const takeUntilSubscriber = new TakeUntilSubscriber(subscriber),
            notifierSubscription = Object(
              _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__.a
            )(takeUntilSubscriber, this.notifier);
          return notifierSubscription && !takeUntilSubscriber.seenValue
            ? (takeUntilSubscriber.add(notifierSubscription),
              source.subscribe(takeUntilSubscriber))
            : takeUntilSubscriber;
        }
      }
      class TakeUntilSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(destination) {
          super(destination), (this.seenValue = !1);
        }
        notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          (this.seenValue = !0), this.complete();
        }
        notifyComplete() {}
      }
    },
    '1Y/n': function(module, exports, __webpack_require__) {
      var aFunction = __webpack_require__('HAuM'),
        toObject = __webpack_require__('ewvW'),
        IndexedObject = __webpack_require__('RK3t'),
        toLength = __webpack_require__('UMSQ'),
        createMethod = function(IS_RIGHT) {
          return function(that, callbackfn, argumentsLength, memo) {
            aFunction(callbackfn);
            var O = toObject(that),
              self = IndexedObject(O),
              length = toLength(O.length),
              index = IS_RIGHT ? length - 1 : 0,
              i = IS_RIGHT ? -1 : 1;
            if (argumentsLength < 2)
              for (;;) {
                if (index in self) {
                  (memo = self[index]), (index += i);
                  break;
                }
                if (((index += i), IS_RIGHT ? index < 0 : length <= index))
                  throw TypeError(
                    'Reduce of empty array with no initial value'
                  );
              }
            for (; IS_RIGHT ? index >= 0 : length > index; index += i)
              index in self && (memo = callbackfn(memo, self[index], index, O));
            return memo;
          };
        };
      module.exports = { left: createMethod(!1), right: createMethod(!0) };
    },
    '1kSV': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return ng_bootstrap_NgbAccordion;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return ng_bootstrap_NgbAccordionConfig;
        }),
        __webpack_require__.d(__webpack_exports__, 'c', function() {
          return ng_bootstrap_NgbAccordionModule;
        }),
        __webpack_require__.d(__webpack_exports__, 'd', function() {
          return ng_bootstrap_NgbDropdown;
        }),
        __webpack_require__.d(__webpack_exports__, 'e', function() {
          return ng_bootstrap_NgbDropdownMenu;
        }),
        __webpack_require__.d(__webpack_exports__, 'f', function() {
          return ng_bootstrap_NgbDropdownModule;
        }),
        __webpack_require__.d(__webpack_exports__, 'g', function() {
          return ng_bootstrap_NgbDropdownToggle;
        }),
        __webpack_require__.d(__webpack_exports__, 'h', function() {
          return ng_bootstrap_NgbModule;
        }),
        __webpack_require__.d(__webpack_exports__, 'i', function() {
          return ng_bootstrap_NgbPanel;
        }),
        __webpack_require__.d(__webpack_exports__, 'j', function() {
          return ng_bootstrap_NgbPanelContent;
        }),
        __webpack_require__.d(__webpack_exports__, 'k', function() {
          return ng_bootstrap_NgbPanelHeader;
        }),
        __webpack_require__.d(__webpack_exports__, 'l', function() {
          return ng_bootstrap_NgbPanelToggle;
        }),
        __webpack_require__.d(__webpack_exports__, 'm', function() {
          return ng_bootstrap_NgbProgressbar;
        }),
        __webpack_require__.d(__webpack_exports__, 'n', function() {
          return ng_bootstrap_NgbProgressbarModule;
        }),
        __webpack_require__.d(__webpack_exports__, 'o', function() {
          return ng_bootstrap_NgbTab;
        }),
        __webpack_require__.d(__webpack_exports__, 'p', function() {
          return ng_bootstrap_NgbTabContent;
        }),
        __webpack_require__.d(__webpack_exports__, 'q', function() {
          return ng_bootstrap_NgbTabTitle;
        }),
        __webpack_require__.d(__webpack_exports__, 'r', function() {
          return ng_bootstrap_NgbTabset;
        }),
        __webpack_require__.d(__webpack_exports__, 's', function() {
          return ng_bootstrap_NgbTabsetModule;
        }),
        __webpack_require__.d(__webpack_exports__, 't', function() {
          return ng_bootstrap_NgbNavbar;
        });
      var core = __webpack_require__('fXoL'),
        common = __webpack_require__('ofXK'),
        fesm2015_forms = __webpack_require__('3Pt+'),
        Subject = __webpack_require__('XNiG'),
        Observable =
          (__webpack_require__('2Vo4'),
          __webpack_require__('itXk'),
          __webpack_require__('HDdC')),
        AsyncAction = __webpack_require__('3N8a');
      const async_async = new (__webpack_require__('IjjT')).a(AsyncAction.a);
      var isArray = __webpack_require__('DH7j');
      __webpack_require__('z+Ro'), __webpack_require__('KqfI');
      var isFunction = __webpack_require__('n6bG'),
        map = __webpack_require__('lJxs');
      function fromEvent(target, eventName, options, resultSelector) {
        return (
          Object(isFunction.a)(options) &&
            ((resultSelector = options), (options = void 0)),
          resultSelector
            ? fromEvent(target, eventName, options).pipe(
                Object(map.a)(args =>
                  Object(isArray.a)(args)
                    ? resultSelector(...args)
                    : resultSelector(args)
                )
              )
            : new Observable.a(subscriber => {
                !(function setupSubscription(
                  sourceObj,
                  eventName,
                  handler,
                  subscriber,
                  options
                ) {
                  let unsubscribe;
                  if (
                    (function(sourceObj) {
                      return (
                        sourceObj &&
                        'function' == typeof sourceObj.addEventListener &&
                        'function' == typeof sourceObj.removeEventListener
                      );
                    })(sourceObj)
                  ) {
                    const source = sourceObj;
                    sourceObj.addEventListener(eventName, handler, options),
                      (unsubscribe = () =>
                        source.removeEventListener(
                          eventName,
                          handler,
                          options
                        ));
                  } else if (
                    (function(sourceObj) {
                      return (
                        sourceObj &&
                        'function' == typeof sourceObj.on &&
                        'function' == typeof sourceObj.off
                      );
                    })(sourceObj)
                  ) {
                    const source = sourceObj;
                    sourceObj.on(eventName, handler),
                      (unsubscribe = () => source.off(eventName, handler));
                  } else if (
                    (function(sourceObj) {
                      return (
                        sourceObj &&
                        'function' == typeof sourceObj.addListener &&
                        'function' == typeof sourceObj.removeListener
                      );
                    })(sourceObj)
                  ) {
                    const source = sourceObj;
                    sourceObj.addListener(eventName, handler),
                      (unsubscribe = () =>
                        source.removeListener(eventName, handler));
                  } else {
                    if (!sourceObj || !sourceObj.length)
                      throw new TypeError('Invalid event target');
                    for (let i = 0, len = sourceObj.length; i < len; i++)
                      setupSubscription(
                        sourceObj[i],
                        eventName,
                        handler,
                        subscriber,
                        options
                      );
                  }
                  subscriber.add(unsubscribe);
                })(
                  target,
                  eventName,
                  function(e) {
                    subscriber.next(
                      arguments.length > 1
                        ? Array.prototype.slice.call(arguments)
                        : e
                    );
                  },
                  subscriber,
                  options
                );
              })
        );
      }
      __webpack_require__('VRyK');
      var fromArray = __webpack_require__('yCtX'),
        OuterSubscriber = __webpack_require__('l7GE'),
        subscribeToResult = __webpack_require__('ZUHj');
      class RaceOperator {
        call(subscriber, source) {
          return source.subscribe(new race_RaceSubscriber(subscriber));
        }
      }
      class race_RaceSubscriber extends OuterSubscriber.a {
        constructor(destination) {
          super(destination),
            (this.hasFirst = !1),
            (this.observables = []),
            (this.subscriptions = []);
        }
        _next(observable) {
          this.observables.push(observable);
        }
        _complete() {
          const observables = this.observables,
            len = observables.length;
          if (0 === len) this.destination.complete();
          else {
            for (let i = 0; i < len && !this.hasFirst; i++) {
              let observable = observables[i],
                subscription = Object(subscribeToResult.a)(
                  this,
                  observable,
                  observable,
                  i
                );
              this.subscriptions && this.subscriptions.push(subscription),
                this.add(subscription);
            }
            this.observables = null;
          }
        }
        notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          if (!this.hasFirst) {
            this.hasFirst = !0;
            for (let i = 0; i < this.subscriptions.length; i++)
              if (i !== outerIndex) {
                let subscription = this.subscriptions[i];
                subscription.unsubscribe(), this.remove(subscription);
              }
            this.subscriptions = null;
          }
          this.destination.next(innerValue);
        }
      }
      __webpack_require__('JX91');
      var Subscriber = __webpack_require__('7o/Q');
      __webpack_require__('eIep');
      var takeUntil = __webpack_require__('1G5W'),
        filter = __webpack_require__('pLZG'),
        take = __webpack_require__('IzEk');
      function withLatestFrom(...args) {
        return source => {
          let project;
          return (
            'function' == typeof args[args.length - 1] &&
              (project = args.pop()),
            source.lift(new WithLatestFromOperator(args, project))
          );
        };
      }
      class WithLatestFromOperator {
        constructor(observables, project) {
          (this.observables = observables), (this.project = project);
        }
        call(subscriber, source) {
          return source.subscribe(
            new withLatestFrom_WithLatestFromSubscriber(
              subscriber,
              this.observables,
              this.project
            )
          );
        }
      }
      class withLatestFrom_WithLatestFromSubscriber extends OuterSubscriber.a {
        constructor(destination, observables, project) {
          super(destination),
            (this.observables = observables),
            (this.project = project),
            (this.toRespond = []);
          const len = observables.length;
          this.values = new Array(len);
          for (let i = 0; i < len; i++) this.toRespond.push(i);
          for (let i = 0; i < len; i++) {
            let observable = observables[i];
            this.add(
              Object(subscribeToResult.a)(this, observable, observable, i)
            );
          }
        }
        notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.values[outerIndex] = innerValue;
          const toRespond = this.toRespond;
          if (toRespond.length > 0) {
            const found = toRespond.indexOf(outerIndex);
            -1 !== found && toRespond.splice(found, 1);
          }
        }
        notifyComplete() {}
        _next(value) {
          if (0 === this.toRespond.length) {
            const args = [value, ...this.values];
            this.project ? this._tryProject(args) : this.destination.next(args);
          }
        }
        _tryProject(args) {
          let result;
          try {
            result = this.project.apply(this, args);
          } catch (err) {
            return void this.destination.error(err);
          }
          this.destination.next(result);
        }
      }
      var Notification = __webpack_require__('WMd4');
      function delay_delay(delay, scheduler = async_async) {
        var value;
        const delayFor =
          (value = delay) instanceof Date && !isNaN(+value)
            ? +delay - scheduler.now()
            : Math.abs(delay);
        return source => source.lift(new DelayOperator(delayFor, scheduler));
      }
      class DelayOperator {
        constructor(delay, scheduler) {
          (this.delay = delay), (this.scheduler = scheduler);
        }
        call(subscriber, source) {
          return source.subscribe(
            new delay_DelaySubscriber(subscriber, this.delay, this.scheduler)
          );
        }
      }
      class delay_DelaySubscriber extends Subscriber.a {
        constructor(destination, delay, scheduler) {
          super(destination),
            (this.delay = delay),
            (this.scheduler = scheduler),
            (this.queue = []),
            (this.active = !1),
            (this.errored = !1);
        }
        static dispatch(state) {
          const source = state.source,
            queue = source.queue,
            scheduler = state.scheduler,
            destination = state.destination;
          for (; queue.length > 0 && queue[0].time - scheduler.now() <= 0; )
            queue.shift().notification.observe(destination);
          if (queue.length > 0) {
            const delay = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay);
          } else this.unsubscribe(), (source.active = !1);
        }
        _schedule(scheduler) {
          (this.active = !0),
            this.destination.add(
              scheduler.schedule(delay_DelaySubscriber.dispatch, this.delay, {
                source: this,
                destination: this.destination,
                scheduler: scheduler
              })
            );
        }
        scheduleNotification(notification) {
          if (!0 === this.errored) return;
          const scheduler = this.scheduler,
            message = new DelayMessage(
              scheduler.now() + this.delay,
              notification
            );
          this.queue.push(message),
            !1 === this.active && this._schedule(scheduler);
        }
        _next(value) {
          this.scheduleNotification(Notification.a.createNext(value));
        }
        _error(err) {
          (this.errored = !0),
            (this.queue = []),
            this.destination.error(err),
            this.unsubscribe();
        }
        _complete() {
          this.scheduleNotification(Notification.a.createComplete()),
            this.unsubscribe();
        }
      }
      class DelayMessage {
        constructor(time, notification) {
          (this.time = time), (this.notification = notification);
        }
      }
      function NgbAccordion_ng_template_1_ng_template_3_Template(rf, ctx) {}
      function NgbAccordion_ng_template_1_Template(rf, ctx) {
        if (
          (1 & rf &&
            (core.Fc(0, '\n      '),
            core.Qb(1, 'button', 3),
            core.Fc(2),
            core.Dc(
              3,
              NgbAccordion_ng_template_1_ng_template_3_Template,
              0,
              0,
              'ng-template',
              4
            ),
            core.Fc(4, '\n      '),
            core.Pb(),
            core.Fc(5, '\n    ')),
          2 & rf)
        ) {
          const panel_r3 = ctx.$implicit;
          core.xb(1),
            core.kc('ngbPanelToggle', panel_r3),
            core.xb(1),
            core.Hc('\n        ', panel_r3.title, ''),
            core.xb(1),
            core.kc(
              'ngTemplateOutlet',
              null == panel_r3.titleTpl ? null : panel_r3.titleTpl.templateRef
            );
        }
      }
      function NgbAccordion_ng_template_4_ng_template_5_Template(rf, ctx) {}
      function NgbAccordion_ng_template_4_div_8_ng_template_4_Template(
        rf,
        ctx
      ) {}
      function NgbAccordion_ng_template_4_div_8_Template(rf, ctx) {
        if (
          (1 & rf &&
            (core.Qb(0, 'div', 9),
            core.Fc(1, '\n          '),
            core.Qb(2, 'div', 10),
            core.Fc(3, '\n               '),
            core.Dc(
              4,
              NgbAccordion_ng_template_4_div_8_ng_template_4_Template,
              0,
              0,
              'ng-template',
              4
            ),
            core.Fc(5, '\n          '),
            core.Pb(),
            core.Fc(6, '\n        '),
            core.Pb()),
          2 & rf)
        ) {
          const panel_r5 = core.fc().$implicit;
          core.Db('show', panel_r5.isOpen),
            core.lc('id', panel_r5.id),
            core.yb('aria-labelledby', panel_r5.id + '-header'),
            core.xb(4),
            core.kc(
              'ngTemplateOutlet',
              null == panel_r5.contentTpl
                ? null
                : panel_r5.contentTpl.templateRef
            );
        }
      }
      __webpack_require__('w1tV'), __webpack_require__('vkgz');
      const _c0 = function(a0, a1) {
        return { $implicit: a0, opened: a1 };
      };
      function NgbAccordion_ng_template_4_Template(rf, ctx) {
        if (
          (1 & rf &&
            (core.Fc(0, '\n      '),
            core.Qb(1, 'div', 5),
            core.Fc(2, '\n        '),
            core.Qb(3, 'div', 6),
            core.Fc(4, '\n          '),
            core.Dc(
              5,
              NgbAccordion_ng_template_4_ng_template_5_Template,
              0,
              0,
              'ng-template',
              7
            ),
            core.Fc(6, '\n        '),
            core.Pb(),
            core.Fc(7, '\n        '),
            core.Dc(
              8,
              NgbAccordion_ng_template_4_div_8_Template,
              7,
              5,
              'div',
              8
            ),
            core.Fc(9, '\n      '),
            core.Pb(),
            core.Fc(10, '\n    ')),
          2 & rf)
        ) {
          const panel_r5 = ctx.$implicit,
            ctx_r2 = core.fc(),
            _r0 = core.tc(2);
          core.xb(3),
            core.zb(
              'card-header ' +
                (panel_r5.type
                  ? 'bg-' + panel_r5.type
                  : ctx_r2.type
                  ? 'bg-' + ctx_r2.type
                  : '')
            ),
            core.mc('id', '', panel_r5.id, '-header'),
            core.xb(2),
            core.kc(
              'ngTemplateOutlet',
              (null == panel_r5.headerTpl
                ? null
                : panel_r5.headerTpl.templateRef) || _r0
            )(
              'ngTemplateOutletContext',
              core.pc(6, _c0, panel_r5, panel_r5.isOpen)
            ),
            core.xb(3),
            core.kc('ngIf', !ctx_r2.destroyOnHide || panel_r5.isOpen);
        }
      }
      $localize`:@@ngb.alert.close␟f4e529ae5ffd73001d1ff4bbdeeb0a72e342e5c8␟7819314041543176992:Close`;
      const _c4 = ['*'];
      var I18N_55;
      function NgbProgressbar_span_5_Template(rf, ctx) {
        if (
          (1 & rf && (core.Qb(0, 'span'), core.Ub(1, I18N_55), core.Pb()),
          2 & rf)
        ) {
          const ctx_r0 = core.fc();
          core.xb(1), core.Xb(ctx_r0.getPercentValue()), core.Vb(1);
        }
      }
      function NgbTabset_li_3_ng_template_4_Template(rf, ctx) {}
      function NgbTabset_li_3_Template(rf, ctx) {
        if (1 & rf) {
          const _r5 = core.Rb();
          core.Qb(0, 'li', 4),
            core.Fc(1, '\n        '),
            core.Qb(2, 'a', 5),
            core.bc('click', function($event) {
              core.vc(_r5);
              const tab_r2 = ctx.$implicit;
              return core.fc().select(tab_r2.id), $event.preventDefault();
            }),
            core.Fc(3),
            core.Dc(
              4,
              NgbTabset_li_3_ng_template_4_Template,
              0,
              0,
              'ng-template',
              6
            ),
            core.Fc(5, '\n        '),
            core.Pb(),
            core.Fc(6, '\n      '),
            core.Pb();
        }
        if (2 & rf) {
          const tab_r2 = ctx.$implicit,
            ctx_r0 = core.fc();
          core.xb(2),
            core.Db('active', tab_r2.id === ctx_r0.activeId)(
              'disabled',
              tab_r2.disabled
            ),
            core.kc('id', tab_r2.id),
            core.yb('tabindex', tab_r2.disabled ? '-1' : void 0)(
              'aria-controls',
              ctx_r0.destroyOnHide && tab_r2.id !== ctx_r0.activeId
                ? null
                : tab_r2.id + '-panel'
            )('aria-selected', tab_r2.id === ctx_r0.activeId)(
              'aria-disabled',
              tab_r2.disabled
            ),
            core.xb(1),
            core.Hc('\n          ', tab_r2.title, ''),
            core.xb(1),
            core.kc(
              'ngTemplateOutlet',
              null == tab_r2.titleTpl ? null : tab_r2.titleTpl.templateRef
            );
        }
      }
      function NgbTabset_ng_template_8_div_1_ng_template_2_Template(rf, ctx) {}
      function NgbTabset_ng_template_8_div_1_Template(rf, ctx) {
        if (
          (1 & rf &&
            (core.Qb(0, 'div', 8),
            core.Fc(1, '\n          '),
            core.Dc(
              2,
              NgbTabset_ng_template_8_div_1_ng_template_2_Template,
              0,
              0,
              'ng-template',
              6
            ),
            core.Fc(3, '\n        '),
            core.Pb()),
          2 & rf)
        ) {
          const tab_r6 = core.fc().$implicit,
            ctx_r7 = core.fc();
          core.Ab(
            'tab-pane ',
            tab_r6.id === ctx_r7.activeId ? 'active' : null,
            ''
          ),
            core.mc('id', '', tab_r6.id, '-panel'),
            core.yb('aria-labelledby', tab_r6.id),
            core.xb(2),
            core.kc(
              'ngTemplateOutlet',
              null == tab_r6.contentTpl ? null : tab_r6.contentTpl.templateRef
            );
        }
      }
      function NgbTabset_ng_template_8_Template(rf, ctx) {
        if (
          (1 & rf &&
            (core.Fc(0, '\n        '),
            core.Dc(1, NgbTabset_ng_template_8_div_1_Template, 4, 6, 'div', 7),
            core.Fc(2, '\n      ')),
          2 & rf)
        ) {
          const tab_r6 = ctx.$implicit,
            ctx_r1 = core.fc();
          core.xb(1),
            core.kc(
              'ngIf',
              !ctx_r1.destroyOnHide || tab_r6.id === ctx_r1.activeId
            );
        }
      }
      function isString(value) {
        return 'string' == typeof value;
      }
      function isDefined(value) {
        return null != value;
      }
      $localize`:@@ngb.carousel.previous␟680d5c75b7fd8d37961083608b9fcdc4167b4c43␟4452427314943113135:Previous`,
        $localize`:@@ngb.carousel.next␟f732c304c7433e5a83ffcd862c3dce709a0f4982␟3885497195825665706:Next`,
        $localize`:@@ngb.datepicker.previous-month␟c3b08b07b5ab98e7cdcf18df39355690ab7d3884␟8586908745456864217:Previous month`,
        $localize`:@@ngb.datepicker.previous-month␟c3b08b07b5ab98e7cdcf18df39355690ab7d3884␟8586908745456864217:Previous month`,
        $localize`:@@ngb.datepicker.next-month␟4bd046985cfe13040d5ef0cd881edce0968a111a␟3628374603023447227:Next month`,
        $localize`:@@ngb.datepicker.next-month␟4bd046985cfe13040d5ef0cd881edce0968a111a␟3628374603023447227:Next month`,
        $localize`:@@ngb.datepicker.select-month␟1dbc84807f35518112f62e5775d1daebd3d8462b␟2253869508135064750:Select month`,
        $localize`:@@ngb.datepicker.select-month␟1dbc84807f35518112f62e5775d1daebd3d8462b␟2253869508135064750:Select month`,
        $localize`:@@ngb.datepicker.select-year␟8ceb09d002bf0c5d1cac171dfbffe1805d2b3962␟8852264961585484321:Select year`,
        $localize`:@@ngb.datepicker.select-year␟8ceb09d002bf0c5d1cac171dfbffe1805d2b3962␟8852264961585484321:Select year`,
        $localize`:@@ngb.pagination.first␟656506dfd46380956a655f919f1498d018f75ca0␟6867721956102594380:««`,
        $localize`:@@ngb.pagination.previous␟6e52b6ee77a4848d899dd21b591c6fd499e3aef3␟6479320895410098858:«`,
        $localize`:@@ngb.pagination.next␟ba9cbb4ff311464308a3627e4f1c3345d9fe6d7d␟5458177150283468089:»`,
        $localize`:@@ngb.pagination.last␟49f27a460bc97e7e00be5b37098bfa79884fc7d9␟5277020320267646988:»»`,
        $localize`:@@ngb.pagination.first-aria␟f2f852318759c6396b5d3d17031d53817d7b38cc␟2241508602425256033:First`,
        $localize`:@@ngb.pagination.previous-aria␟680d5c75b7fd8d37961083608b9fcdc4167b4c43␟4452427314943113135:Previous`,
        $localize`:@@ngb.pagination.next-aria␟f732c304c7433e5a83ffcd862c3dce709a0f4982␟3885497195825665706:Next`,
        $localize`:@@ngb.pagination.last-aria␟5c729788ba138508aca1bec050b610f7bf81db3e␟4882268002141858767:Last`,
        (I18N_55 = $localize`:@@ngb.progressbar.value␟04d611d19c117c60c9e14d0a04399a027184bc77␟5214781723415385277:${'�0�'}:INTERPOLATION:%`),
        $localize`:@@ngb.timepicker.HH␟ce676ab1d6d98f85c836381cf100a4a91ef95a1f␟4043638465245303811:HH`,
        $localize`:@@ngb.timepicker.hours␟3bbce5fef7e1151da052a4e529453edb340e3912␟8070396816726827304:Hours`,
        $localize`:@@ngb.timepicker.MM␟72c8edf6a50068a05bde70991e36b1e881f4ca54␟1647282246509919852:MM`,
        $localize`:@@ngb.timepicker.minutes␟41e62daa962947c0d23ded0981975d1bddf0bf38␟5531237363767747080:Minutes`,
        $localize`:@@ngb.timepicker.increment-hours␟cb74bc1d625a6c1742f0d7d47306cf495780c218␟5939278348542933629:Increment hours`,
        $localize`:@@ngb.timepicker.decrement-hours␟147c7a19429da7d999e247d22e33fee370b1691b␟3651829882940481818:Decrement hours`,
        $localize`:@@ngb.timepicker.increment-minutes␟f5a4a3bc05e053f6732475d0e74875ec01c3a348␟180147720391025024:Increment minutes`,
        $localize`:@@ngb.timepicker.decrement-minutes␟c1a6899e529c096da5b660385d4e77fe1f7ad271␟7447789825403243588:Decrement minutes`,
        $localize`:@@ngb.timepicker.SS␟ebe38d36a40a2383c5fefa9b4608ffbda08bd4a3␟3628127143071124194:SS`,
        $localize`:@@ngb.timepicker.seconds␟4f2ed9e71a7c981db3e50ae2fedb28aff2ec4e6c␟8874012390997067175:Seconds`,
        $localize`:@@ngb.timepicker.increment-seconds␟912322ecee7d659d04dcf494a70e22e49d334b26␟5364772110539092174:Increment seconds`,
        $localize`:@@ngb.timepicker.decrement-seconds␟5db47ac104294243a70eb9124fbea9d0004ddf69␟753633511487974857:Decrement seconds`,
        $localize`:@@ngb.timepicker.PM␟8d6e691e10306c1b34c6b26805151aaea320ef7f␟3564199131264287502:${'�0�'}:INTERPOLATION:`,
        $localize`:@@ngb.timepicker.AM␟69a1f176a93998876952adac57c3bc3863b6105e␟4592818992509942761:${'�0�'}:INTERPOLATION:`,
        $localize`:@@ngb.toast.close-aria␟f4e529ae5ffd73001d1ff4bbdeeb0a72e342e5c8␟7819314041543176992:Close`,
        'undefined' == typeof Element ||
          Element.prototype.closest ||
          (Element.prototype.matches ||
            (Element.prototype.matches =
              Element.prototype.msMatchesSelector ||
              Element.prototype.webkitMatchesSelector),
          (Element.prototype.closest = function(s) {
            let el = this;
            if (!document.documentElement.contains(el)) return null;
            do {
              if (el.matches(s)) return el;
              el = el.parentElement || el.parentNode;
            } while (null !== el && 1 === el.nodeType);
            return null;
          }));
      let ng_bootstrap_NgbAccordionConfig = (() => {
          class NgbAccordionConfig {
            constructor() {
              this.closeOthers = !1;
            }
          }
          return (
            (NgbAccordionConfig.ɵfac = function(t) {
              return new (t || NgbAccordionConfig)();
            }),
            (NgbAccordionConfig.ɵprov = core.Hb({
              token: NgbAccordionConfig,
              factory: NgbAccordionConfig.ɵfac,
              providedIn: 'root'
            })),
            (NgbAccordionConfig.ngInjectableDef = Object(core.Hb)({
              factory: function() {
                return new NgbAccordionConfig();
              },
              token: NgbAccordionConfig,
              providedIn: 'root'
            })),
            NgbAccordionConfig
          );
        })(),
        nextId = 0,
        ng_bootstrap_NgbPanelHeader = (() => {
          class NgbPanelHeader {
            constructor(templateRef) {
              this.templateRef = templateRef;
            }
          }
          return (
            (NgbPanelHeader.ɵfac = function(t) {
              return new (t || NgbPanelHeader)(core.Lb(core.K));
            }),
            (NgbPanelHeader.ɵdir = core.Gb({
              type: NgbPanelHeader,
              selectors: [['ng-template', 'ngbPanelHeader', '']]
            })),
            NgbPanelHeader
          );
        })(),
        ng_bootstrap_NgbPanelTitle = (() => {
          class NgbPanelTitle {
            constructor(templateRef) {
              this.templateRef = templateRef;
            }
          }
          return (
            (NgbPanelTitle.ɵfac = function(t) {
              return new (t || NgbPanelTitle)(core.Lb(core.K));
            }),
            (NgbPanelTitle.ɵdir = core.Gb({
              type: NgbPanelTitle,
              selectors: [['ng-template', 'ngbPanelTitle', '']]
            })),
            NgbPanelTitle
          );
        })(),
        ng_bootstrap_NgbPanelContent = (() => {
          class NgbPanelContent {
            constructor(templateRef) {
              this.templateRef = templateRef;
            }
          }
          return (
            (NgbPanelContent.ɵfac = function(t) {
              return new (t || NgbPanelContent)(core.Lb(core.K));
            }),
            (NgbPanelContent.ɵdir = core.Gb({
              type: NgbPanelContent,
              selectors: [['ng-template', 'ngbPanelContent', '']]
            })),
            NgbPanelContent
          );
        })(),
        ng_bootstrap_NgbPanel = (() => {
          class NgbPanel {
            constructor() {
              (this.disabled = !1),
                (this.id = 'ngb-panel-' + nextId++),
                (this.isOpen = !1);
            }
            ngAfterContentChecked() {
              (this.titleTpl = this.titleTpls.first),
                (this.headerTpl = this.headerTpls.first),
                (this.contentTpl = this.contentTpls.first);
            }
          }
          return (
            (NgbPanel.ɵfac = function(t) {
              return new (t || NgbPanel)();
            }),
            (NgbPanel.ɵdir = core.Gb({
              type: NgbPanel,
              selectors: [['ngb-panel']],
              contentQueries: function(rf, ctx, dirIndex) {
                var _t;
                1 & rf &&
                  (core.Eb(dirIndex, ng_bootstrap_NgbPanelTitle, !1),
                  core.Eb(dirIndex, ng_bootstrap_NgbPanelHeader, !1),
                  core.Eb(dirIndex, ng_bootstrap_NgbPanelContent, !1)),
                  2 & rf &&
                    (core.sc((_t = core.cc())) && (ctx.titleTpls = _t),
                    core.sc((_t = core.cc())) && (ctx.headerTpls = _t),
                    core.sc((_t = core.cc())) && (ctx.contentTpls = _t));
              },
              inputs: {
                disabled: 'disabled',
                id: 'id',
                title: 'title',
                type: 'type'
              }
            })),
            NgbPanel
          );
        })(),
        ng_bootstrap_NgbAccordion = (() => {
          class NgbAccordion {
            constructor(config) {
              (this.activeIds = []),
                (this.destroyOnHide = !0),
                (this.panelChange = new core.n()),
                (this.type = config.type),
                (this.closeOtherPanels = config.closeOthers);
            }
            isExpanded(panelId) {
              return this.activeIds.indexOf(panelId) > -1;
            }
            expand(panelId) {
              this._changeOpenState(this._findPanelById(panelId), !0);
            }
            expandAll() {
              this.closeOtherPanels
                ? 0 === this.activeIds.length &&
                  this.panels.length &&
                  this._changeOpenState(this.panels.first, !0)
                : this.panels.forEach(panel =>
                    this._changeOpenState(panel, !0)
                  );
            }
            collapse(panelId) {
              this._changeOpenState(this._findPanelById(panelId), !1);
            }
            collapseAll() {
              this.panels.forEach(panel => {
                this._changeOpenState(panel, !1);
              });
            }
            toggle(panelId) {
              const panel = this._findPanelById(panelId);
              panel && this._changeOpenState(panel, !panel.isOpen);
            }
            ngAfterContentChecked() {
              isString(this.activeIds) &&
                (this.activeIds = this.activeIds.split(/\s*,\s*/)),
                this.panels.forEach(
                  panel =>
                    (panel.isOpen =
                      !panel.disabled && this.activeIds.indexOf(panel.id) > -1)
                ),
                this.activeIds.length > 1 &&
                  this.closeOtherPanels &&
                  (this._closeOthers(this.activeIds[0]),
                  this._updateActiveIds());
            }
            _changeOpenState(panel, nextState) {
              if (panel && !panel.disabled && panel.isOpen !== nextState) {
                let defaultPrevented = !1;
                this.panelChange.emit({
                  panelId: panel.id,
                  nextState: nextState,
                  preventDefault: () => {
                    defaultPrevented = !0;
                  }
                }),
                  defaultPrevented ||
                    ((panel.isOpen = nextState),
                    nextState &&
                      this.closeOtherPanels &&
                      this._closeOthers(panel.id),
                    this._updateActiveIds());
              }
            }
            _closeOthers(panelId) {
              this.panels.forEach(panel => {
                panel.id !== panelId && (panel.isOpen = !1);
              });
            }
            _findPanelById(panelId) {
              return this.panels.find(p => p.id === panelId);
            }
            _updateActiveIds() {
              this.activeIds = this.panels
                .filter(panel => panel.isOpen && !panel.disabled)
                .map(panel => panel.id);
            }
          }
          return (
            (NgbAccordion.ɵfac = function(t) {
              return new (t || NgbAccordion)(
                core.Lb(ng_bootstrap_NgbAccordionConfig)
              );
            }),
            (NgbAccordion.ɵcmp = core.Fb({
              type: NgbAccordion,
              selectors: [['ngb-accordion']],
              contentQueries: function(rf, ctx, dirIndex) {
                var _t;
                1 & rf && core.Eb(dirIndex, ng_bootstrap_NgbPanel, !1),
                  2 & rf && core.sc((_t = core.cc())) && (ctx.panels = _t);
              },
              hostAttrs: ['role', 'tablist', 1, 'accordion'],
              hostVars: 1,
              hostBindings: function(rf, ctx) {
                2 & rf &&
                  core.yb('aria-multiselectable', !ctx.closeOtherPanels);
              },
              inputs: {
                activeIds: 'activeIds',
                destroyOnHide: 'destroyOnHide',
                type: 'type',
                closeOtherPanels: ['closeOthers', 'closeOtherPanels']
              },
              outputs: { panelChange: 'panelChange' },
              exportAs: ['ngbAccordion'],
              decls: 6,
              vars: 1,
              consts: [
                ['ngbPanelHeader', ''],
                ['t', ''],
                ['ngFor', '', 3, 'ngForOf'],
                [1, 'btn', 'btn-link', 3, 'ngbPanelToggle'],
                [3, 'ngTemplateOutlet'],
                [1, 'card'],
                ['role', 'tab', 3, 'id'],
                [3, 'ngTemplateOutlet', 'ngTemplateOutletContext'],
                [
                  'role',
                  'tabpanel',
                  'class',
                  'collapse',
                  3,
                  'id',
                  'show',
                  4,
                  'ngIf'
                ],
                ['role', 'tabpanel', 1, 'collapse', 3, 'id'],
                [1, 'card-body']
              ],
              template: function(rf, ctx) {
                1 & rf &&
                  (core.Fc(0, '\n    '),
                  core.Dc(
                    1,
                    NgbAccordion_ng_template_1_Template,
                    6,
                    3,
                    'ng-template',
                    0,
                    1,
                    core.Ec
                  ),
                  core.Fc(3, '\n    '),
                  core.Dc(
                    4,
                    NgbAccordion_ng_template_4_Template,
                    11,
                    9,
                    'ng-template',
                    2
                  ),
                  core.Fc(5, '\n  ')),
                  2 & rf && (core.xb(4), core.kc('ngForOf', ctx.panels));
              },
              directives: function() {
                return [
                  ng_bootstrap_NgbPanelHeader,
                  common.j,
                  ng_bootstrap_NgbPanelToggle,
                  common.m,
                  common.k
                ];
              },
              encapsulation: 2
            })),
            NgbAccordion
          );
        })(),
        ng_bootstrap_NgbPanelToggle = (() => {
          class NgbPanelToggle {
            constructor(accordion, panel) {
              (this.accordion = accordion), (this.panel = panel);
            }
            set ngbPanelToggle(panel) {
              panel && (this.panel = panel);
            }
          }
          return (
            (NgbPanelToggle.ɵfac = function(t) {
              return new (t || NgbPanelToggle)(
                core.Lb(ng_bootstrap_NgbAccordion),
                core.Lb(ng_bootstrap_NgbPanel, 9)
              );
            }),
            (NgbPanelToggle.ɵdir = core.Gb({
              type: NgbPanelToggle,
              selectors: [['button', 'ngbPanelToggle', '']],
              hostAttrs: ['type', 'button'],
              hostVars: 5,
              hostBindings: function(rf, ctx) {
                1 & rf &&
                  core.bc('click', function() {
                    return ctx.accordion.toggle(ctx.panel.id);
                  }),
                  2 & rf &&
                    (core.Tb('disabled', ctx.panel.disabled),
                    core.yb('aria-expanded', ctx.panel.isOpen)(
                      'aria-controls',
                      ctx.panel.id
                    ),
                    core.Db('collapsed', !ctx.panel.isOpen));
              },
              inputs: { ngbPanelToggle: 'ngbPanelToggle' }
            })),
            NgbPanelToggle
          );
        })(),
        ng_bootstrap_NgbAccordionModule = (() => {
          class NgbAccordionModule {}
          return (
            (NgbAccordionModule.ɵmod = core.Jb({ type: NgbAccordionModule })),
            (NgbAccordionModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbAccordionModule)();
              },
              imports: [[common.b]]
            })),
            NgbAccordionModule
          );
        })(),
        ng_bootstrap_NgbAlertModule = (() => {
          class NgbAlertModule {}
          return (
            (NgbAlertModule.ɵmod = core.Jb({ type: NgbAlertModule })),
            (NgbAlertModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbAlertModule)();
              },
              imports: [[common.b]]
            })),
            NgbAlertModule
          );
        })(),
        ng_bootstrap_NgbButtonsModule = (() => {
          class NgbButtonsModule {}
          return (
            (NgbButtonsModule.ɵmod = core.Jb({ type: NgbButtonsModule })),
            (NgbButtonsModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbButtonsModule)();
              }
            })),
            NgbButtonsModule
          );
        })(),
        ng_bootstrap_NgbCarouselModule = (() => {
          class NgbCarouselModule {}
          return (
            (NgbCarouselModule.ɵmod = core.Jb({ type: NgbCarouselModule })),
            (NgbCarouselModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbCarouselModule)();
              },
              imports: [[common.b]]
            })),
            NgbCarouselModule
          );
        })(),
        ng_bootstrap_NgbCollapseModule = (() => {
          class NgbCollapseModule {}
          return (
            (NgbCollapseModule.ɵmod = core.Jb({ type: NgbCollapseModule })),
            (NgbCollapseModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbCollapseModule)();
              }
            })),
            NgbCollapseModule
          );
        })();
      const Key = (function() {
          var Key = {
            Tab: 9,
            Enter: 13,
            Escape: 27,
            Space: 32,
            PageUp: 33,
            PageDown: 34,
            End: 35,
            Home: 36,
            ArrowLeft: 37,
            ArrowUp: 38,
            ArrowRight: 39,
            ArrowDown: 40
          };
          return (
            (Key[Key.Tab] = 'Tab'),
            (Key[Key.Enter] = 'Enter'),
            (Key[Key.Escape] = 'Escape'),
            (Key[Key.Space] = 'Space'),
            (Key[Key.PageUp] = 'PageUp'),
            (Key[Key.PageDown] = 'PageDown'),
            (Key[Key.End] = 'End'),
            (Key[Key.Home] = 'Home'),
            (Key[Key.ArrowLeft] = 'ArrowLeft'),
            (Key[Key.ArrowUp] = 'ArrowUp'),
            (Key[Key.ArrowRight] = 'ArrowRight'),
            (Key[Key.ArrowDown] = 'ArrowDown'),
            Key
          );
        })(),
        isContainedIn = (element, array) =>
          !!array && array.some(item => item.contains(element)),
        matchesSelectorIfAny = (element, selector) =>
          !selector ||
          null !=
            (function(element, selector) {
              return selector ? element.closest(selector) : null;
            })(element, selector);
      let iOS = !1;
      'undefined' != typeof navigator &&
        (iOS =
          !!navigator.userAgent &&
          /iPad|iPhone|iPod/.test(navigator.userAgent));
      const FOCUSABLE_ELEMENTS_SELECTOR = [
        'a[href]',
        'button:not([disabled])',
        'input:not([disabled]):not([type="hidden"])',
        'select:not([disabled])',
        'textarea:not([disabled])',
        '[contenteditable]',
        '[tabindex]:not([tabindex="-1"])'
      ].join(', ');
      function getFocusableBoundaryElements(element) {
        const list = Array.from(
          element.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR)
        ).filter(el => -1 !== el.tabIndex);
        return [list[0], list[list.length - 1]];
      }
      class Positioning {
        getAllStyles(element) {
          return window.getComputedStyle(element);
        }
        getStyle(element, prop) {
          return this.getAllStyles(element)[prop];
        }
        isStaticPositioned(element) {
          return 'static' === (this.getStyle(element, 'position') || 'static');
        }
        offsetParent(element) {
          let offsetParentEl = element.offsetParent || document.documentElement;
          for (
            ;
            offsetParentEl &&
            offsetParentEl !== document.documentElement &&
            this.isStaticPositioned(offsetParentEl);

          )
            offsetParentEl = offsetParentEl.offsetParent;
          return offsetParentEl || document.documentElement;
        }
        position(element, round = !0) {
          let elPosition,
            parentOffset = {
              width: 0,
              height: 0,
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            };
          if ('fixed' === this.getStyle(element, 'position'))
            (elPosition = element.getBoundingClientRect()),
              (elPosition = {
                top: elPosition.top,
                bottom: elPosition.bottom,
                left: elPosition.left,
                right: elPosition.right,
                height: elPosition.height,
                width: elPosition.width
              });
          else {
            const offsetParentEl = this.offsetParent(element);
            (elPosition = this.offset(element, !1)),
              offsetParentEl !== document.documentElement &&
                (parentOffset = this.offset(offsetParentEl, !1)),
              (parentOffset.top += offsetParentEl.clientTop),
              (parentOffset.left += offsetParentEl.clientLeft);
          }
          return (
            (elPosition.top -= parentOffset.top),
            (elPosition.bottom -= parentOffset.top),
            (elPosition.left -= parentOffset.left),
            (elPosition.right -= parentOffset.left),
            round &&
              ((elPosition.top = Math.round(elPosition.top)),
              (elPosition.bottom = Math.round(elPosition.bottom)),
              (elPosition.left = Math.round(elPosition.left)),
              (elPosition.right = Math.round(elPosition.right))),
            elPosition
          );
        }
        offset(element, round = !0) {
          const elBcr = element.getBoundingClientRect(),
            viewportOffset_top =
              window.pageYOffset - document.documentElement.clientTop,
            viewportOffset_left =
              window.pageXOffset - document.documentElement.clientLeft;
          let elOffset = {
            height: elBcr.height || element.offsetHeight,
            width: elBcr.width || element.offsetWidth,
            top: elBcr.top + viewportOffset_top,
            bottom: elBcr.bottom + viewportOffset_top,
            left: elBcr.left + viewportOffset_left,
            right: elBcr.right + viewportOffset_left
          };
          return (
            round &&
              ((elOffset.height = Math.round(elOffset.height)),
              (elOffset.width = Math.round(elOffset.width)),
              (elOffset.top = Math.round(elOffset.top)),
              (elOffset.bottom = Math.round(elOffset.bottom)),
              (elOffset.left = Math.round(elOffset.left)),
              (elOffset.right = Math.round(elOffset.right))),
            elOffset
          );
        }
        positionElements(hostElement, targetElement, placement, appendToBody) {
          const [
              placementPrimary = 'top',
              placementSecondary = 'center'
            ] = placement.split('-'),
            hostElPosition = appendToBody
              ? this.offset(hostElement, !1)
              : this.position(hostElement, !1),
            targetElStyles = this.getAllStyles(targetElement),
            marginTop = parseFloat(targetElStyles.marginTop),
            marginBottom = parseFloat(targetElStyles.marginBottom),
            marginLeft = parseFloat(targetElStyles.marginLeft),
            marginRight = parseFloat(targetElStyles.marginRight);
          let topPosition = 0,
            leftPosition = 0;
          switch (placementPrimary) {
            case 'top':
              topPosition =
                hostElPosition.top -
                (targetElement.offsetHeight + marginTop + marginBottom);
              break;
            case 'bottom':
              topPosition = hostElPosition.top + hostElPosition.height;
              break;
            case 'left':
              leftPosition =
                hostElPosition.left -
                (targetElement.offsetWidth + marginLeft + marginRight);
              break;
            case 'right':
              leftPosition = hostElPosition.left + hostElPosition.width;
          }
          switch (placementSecondary) {
            case 'top':
              topPosition = hostElPosition.top;
              break;
            case 'bottom':
              topPosition =
                hostElPosition.top +
                hostElPosition.height -
                targetElement.offsetHeight;
              break;
            case 'left':
              leftPosition = hostElPosition.left;
              break;
            case 'right':
              leftPosition =
                hostElPosition.left +
                hostElPosition.width -
                targetElement.offsetWidth;
              break;
            case 'center':
              'top' === placementPrimary || 'bottom' === placementPrimary
                ? (leftPosition =
                    hostElPosition.left +
                    hostElPosition.width / 2 -
                    targetElement.offsetWidth / 2)
                : (topPosition =
                    hostElPosition.top +
                    hostElPosition.height / 2 -
                    targetElement.offsetHeight / 2);
          }
          targetElement.style.transform = `translate(${Math.round(
            leftPosition
          )}px, ${Math.round(topPosition)}px)`;
          const targetElBCR = targetElement.getBoundingClientRect(),
            html = document.documentElement,
            windowHeight = window.innerHeight || html.clientHeight,
            windowWidth = window.innerWidth || html.clientWidth;
          return (
            targetElBCR.left >= 0 &&
            targetElBCR.top >= 0 &&
            targetElBCR.right <= windowWidth &&
            targetElBCR.bottom <= windowHeight
          );
        }
      }
      const placementSeparator = /\s+/,
        positionService = new Positioning();
      let ng_bootstrap_NgbDatepickerModule = (() => {
          class NgbDatepickerModule {}
          return (
            (NgbDatepickerModule.ɵmod = core.Jb({ type: NgbDatepickerModule })),
            (NgbDatepickerModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbDatepickerModule)();
              },
              imports: [[common.b, fesm2015_forms.a]]
            })),
            NgbDatepickerModule
          );
        })(),
        ng_bootstrap_NgbDropdownConfig = (() => {
          class NgbDropdownConfig {
            constructor() {
              (this.autoClose = !0),
                (this.placement = [
                  'bottom-left',
                  'bottom-right',
                  'top-left',
                  'top-right'
                ]);
            }
          }
          return (
            (NgbDropdownConfig.ɵfac = function(t) {
              return new (t || NgbDropdownConfig)();
            }),
            (NgbDropdownConfig.ɵprov = core.Hb({
              token: NgbDropdownConfig,
              factory: NgbDropdownConfig.ɵfac,
              providedIn: 'root'
            })),
            (NgbDropdownConfig.ngInjectableDef = Object(core.Hb)({
              factory: function() {
                return new NgbDropdownConfig();
              },
              token: NgbDropdownConfig,
              providedIn: 'root'
            })),
            NgbDropdownConfig
          );
        })(),
        ng_bootstrap_NgbNavbar = (() => {
          class NgbNavbar {}
          return (
            (NgbNavbar.ɵfac = function(t) {
              return new (t || NgbNavbar)();
            }),
            (NgbNavbar.ɵdir = core.Gb({
              type: NgbNavbar,
              selectors: [['', 8, 'navbar']]
            })),
            NgbNavbar
          );
        })(),
        ng_bootstrap_NgbDropdownItem = (() => {
          class NgbDropdownItem {
            constructor(elementRef) {
              (this.elementRef = elementRef), (this._disabled = !1);
            }
            set disabled(value) {
              this._disabled = '' === value || !0 === value;
            }
            get disabled() {
              return this._disabled;
            }
          }
          return (
            (NgbDropdownItem.ɵfac = function(t) {
              return new (t || NgbDropdownItem)(core.Lb(core.l));
            }),
            (NgbDropdownItem.ɵdir = core.Gb({
              type: NgbDropdownItem,
              selectors: [['', 'ngbDropdownItem', '']],
              hostAttrs: [1, 'dropdown-item'],
              hostVars: 2,
              hostBindings: function(rf, ctx) {
                2 & rf && core.Db('disabled', ctx.disabled);
              },
              inputs: { disabled: 'disabled' }
            })),
            NgbDropdownItem
          );
        })(),
        ng_bootstrap_NgbDropdownMenu = (() => {
          class NgbDropdownMenu {
            constructor(dropdown) {
              (this.dropdown = dropdown),
                (this.placement = 'bottom'),
                (this.isOpen = !1);
            }
          }
          return (
            (NgbDropdownMenu.ɵfac = function(t) {
              return new (t || NgbDropdownMenu)(
                core.Lb(Object(core.S)(() => ng_bootstrap_NgbDropdown))
              );
            }),
            (NgbDropdownMenu.ɵdir = core.Gb({
              type: NgbDropdownMenu,
              selectors: [['', 'ngbDropdownMenu', '']],
              contentQueries: function(rf, ctx, dirIndex) {
                var _t;
                1 & rf && core.Eb(dirIndex, ng_bootstrap_NgbDropdownItem, !1),
                  2 & rf && core.sc((_t = core.cc())) && (ctx.menuItems = _t);
              },
              hostVars: 5,
              hostBindings: function(rf, ctx) {
                1 & rf &&
                  core.bc('keydown.ArrowUp', function($event) {
                    return ctx.dropdown.onKeyDown($event);
                  })('keydown.ArrowDown', function($event) {
                    return ctx.dropdown.onKeyDown($event);
                  })('keydown.Home', function($event) {
                    return ctx.dropdown.onKeyDown($event);
                  })('keydown.End', function($event) {
                    return ctx.dropdown.onKeyDown($event);
                  })('keydown.Enter', function($event) {
                    return ctx.dropdown.onKeyDown($event);
                  })('keydown.Space', function($event) {
                    return ctx.dropdown.onKeyDown($event);
                  }),
                  2 & rf &&
                    (core.yb('x-placement', ctx.placement),
                    core.Db('dropdown-menu', !0)(
                      'show',
                      ctx.dropdown.isOpen()
                    ));
              }
            })),
            NgbDropdownMenu
          );
        })(),
        ng_bootstrap_NgbDropdownAnchor = (() => {
          class NgbDropdownAnchor {
            constructor(dropdown, _elementRef) {
              (this.dropdown = dropdown),
                (this._elementRef = _elementRef),
                (this.anchorEl = _elementRef.nativeElement);
            }
            getNativeElement() {
              return this._elementRef.nativeElement;
            }
          }
          return (
            (NgbDropdownAnchor.ɵfac = function(t) {
              return new (t || NgbDropdownAnchor)(
                core.Lb(Object(core.S)(() => ng_bootstrap_NgbDropdown)),
                core.Lb(core.l)
              );
            }),
            (NgbDropdownAnchor.ɵdir = core.Gb({
              type: NgbDropdownAnchor,
              selectors: [['', 'ngbDropdownAnchor', '']],
              hostAttrs: ['aria-haspopup', 'true', 1, 'dropdown-toggle'],
              hostVars: 1,
              hostBindings: function(rf, ctx) {
                2 & rf && core.yb('aria-expanded', ctx.dropdown.isOpen());
              }
            })),
            NgbDropdownAnchor
          );
        })(),
        ng_bootstrap_NgbDropdownToggle = (() => {
          class NgbDropdownToggle extends ng_bootstrap_NgbDropdownAnchor {
            constructor(dropdown, elementRef) {
              super(dropdown, elementRef);
            }
          }
          return (
            (NgbDropdownToggle.ɵfac = function(t) {
              return new (t || NgbDropdownToggle)(
                core.Lb(Object(core.S)(() => ng_bootstrap_NgbDropdown)),
                core.Lb(core.l)
              );
            }),
            (NgbDropdownToggle.ɵdir = core.Gb({
              type: NgbDropdownToggle,
              selectors: [['', 'ngbDropdownToggle', '']],
              hostAttrs: ['aria-haspopup', 'true', 1, 'dropdown-toggle'],
              hostVars: 1,
              hostBindings: function(rf, ctx) {
                1 & rf &&
                  core.bc('click', function() {
                    return ctx.dropdown.toggle();
                  })('keydown.ArrowUp', function($event) {
                    return ctx.dropdown.onKeyDown($event);
                  })('keydown.ArrowDown', function($event) {
                    return ctx.dropdown.onKeyDown($event);
                  })('keydown.Home', function($event) {
                    return ctx.dropdown.onKeyDown($event);
                  })('keydown.End', function($event) {
                    return ctx.dropdown.onKeyDown($event);
                  }),
                  2 & rf && core.yb('aria-expanded', ctx.dropdown.isOpen());
              },
              features: [
                core.wb([
                  {
                    provide: ng_bootstrap_NgbDropdownAnchor,
                    useExisting: Object(core.S)(() => NgbDropdownToggle)
                  }
                ]),
                core.ub
              ]
            })),
            NgbDropdownToggle
          );
        })(),
        ng_bootstrap_NgbDropdown = (() => {
          class NgbDropdown {
            constructor(
              _changeDetector,
              config,
              _document,
              _ngZone,
              _elementRef,
              _renderer,
              ngbNavbar
            ) {
              (this._changeDetector = _changeDetector),
                (this._document = _document),
                (this._ngZone = _ngZone),
                (this._elementRef = _elementRef),
                (this._renderer = _renderer),
                (this._closed$ = new Subject.a()),
                (this._open = !1),
                (this.openChange = new core.n()),
                (this.placement = config.placement),
                (this.container = config.container),
                (this.autoClose = config.autoClose),
                (this.display = ngbNavbar ? 'static' : 'dynamic'),
                (this._zoneSubscription = _ngZone.onStable.subscribe(() => {
                  this._positionMenu();
                }));
            }
            ngAfterContentInit() {
              this._ngZone.onStable.pipe(Object(take.a)(1)).subscribe(() => {
                this._applyPlacementClasses(),
                  this._open && this._setCloseHandlers();
              });
            }
            ngOnChanges(changes) {
              changes.container &&
                this._open &&
                this._applyContainer(this.container),
                changes.placement &&
                  !changes.placement.isFirstChange &&
                  this._applyPlacementClasses();
            }
            isOpen() {
              return this._open;
            }
            open() {
              this._open ||
                ((this._open = !0),
                this._applyContainer(this.container),
                this.openChange.emit(!0),
                this._setCloseHandlers());
            }
            _setCloseHandlers() {
              const anchor = this._anchor;
              !(function(
                zone,
                document,
                type,
                close,
                closed$,
                insideElements,
                ignoreElements,
                insideSelector
              ) {
                type &&
                  zone.runOutsideAngular(() => {
                    const escapes$ = fromEvent(document, 'keydown').pipe(
                        Object(takeUntil.a)(closed$),
                        Object(filter.a)(e => e.which === Key.Escape)
                      ),
                      mouseDowns$ = fromEvent(
                        document,
                        iOS ? 'touchstart' : 'mousedown'
                      ).pipe(
                        Object(map.a)(event => {
                          const element = event.target;
                          return (
                            !(
                              (event instanceof MouseEvent &&
                                2 === event.button) ||
                              isContainedIn(element, ignoreElements)
                            ) &&
                            ('inside' === type
                              ? isContainedIn(element, insideElements) &&
                                matchesSelectorIfAny(
                                  element,
                                  '.dropdown-item,.dropdown-divider'
                                )
                              : 'outside' === type
                              ? !isContainedIn(element, insideElements)
                              : matchesSelectorIfAny(
                                  element,
                                  '.dropdown-item,.dropdown-divider'
                                ) || !isContainedIn(element, insideElements))
                          );
                        }),
                        Object(takeUntil.a)(closed$)
                      );
                    (function(...observables) {
                      if (1 === observables.length) {
                        if (!Object(isArray.a)(observables[0]))
                          return observables[0];
                        observables = observables[0];
                      }
                      return Object(fromArray.a)(observables, void 0).lift(
                        new RaceOperator()
                      );
                    })([
                      escapes$,
                      fromEvent(document, iOS ? 'touchend' : 'mouseup').pipe(
                        withLatestFrom(mouseDowns$),
                        Object(filter.a)(([_, shouldClose]) => shouldClose),
                        delay_delay(iOS ? 16 : 0),
                        Object(takeUntil.a)(closed$)
                      )
                    ]).subscribe(() => zone.run(close));
                  });
              })(
                this._ngZone,
                this._document,
                this.autoClose,
                () => this.close(),
                this._closed$,
                this._menu ? [this._menuElement.nativeElement] : [],
                anchor ? [anchor.getNativeElement()] : []
              );
            }
            close() {
              this._open &&
                ((this._open = !1),
                this._resetContainer(),
                this._closed$.next(),
                this.openChange.emit(!1),
                this._changeDetector.markForCheck());
            }
            toggle() {
              this.isOpen() ? this.close() : this.open();
            }
            ngOnDestroy() {
              this._resetContainer(),
                this._closed$.next(),
                this._zoneSubscription.unsubscribe();
            }
            onKeyDown(event) {
              const key = event.which,
                itemElements = this._getMenuElements();
              let position = -1,
                isEventFromItems = !1;
              const isEventFromToggle = this._isEventFromToggle(event);
              if (
                (!isEventFromToggle &&
                  itemElements.length &&
                  itemElements.forEach((itemElement, index) => {
                    itemElement.contains(event.target) &&
                      (isEventFromItems = !0),
                      itemElement === this._document.activeElement &&
                        (position = index);
                  }),
                key !== Key.Space && key !== Key.Enter)
              ) {
                if (isEventFromToggle || isEventFromItems) {
                  if ((this.open(), itemElements.length)) {
                    switch (key) {
                      case Key.ArrowDown:
                        position = Math.min(
                          position + 1,
                          itemElements.length - 1
                        );
                        break;
                      case Key.ArrowUp:
                        if (this._isDropup() && -1 === position) {
                          position = itemElements.length - 1;
                          break;
                        }
                        position = Math.max(position - 1, 0);
                        break;
                      case Key.Home:
                        position = 0;
                        break;
                      case Key.End:
                        position = itemElements.length - 1;
                    }
                    itemElements[position].focus();
                  }
                  event.preventDefault();
                }
              } else
                !isEventFromItems ||
                  (!0 !== this.autoClose && 'inside' !== this.autoClose) ||
                  this.close();
            }
            _isDropup() {
              return this._elementRef.nativeElement.classList.contains(
                'dropup'
              );
            }
            _isEventFromToggle(event) {
              return this._anchor.getNativeElement().contains(event.target);
            }
            _getMenuElements() {
              const menu = this._menu;
              return null == menu
                ? []
                : menu.menuItems
                    .filter(item => !item.disabled)
                    .map(item => item.elementRef.nativeElement);
            }
            _positionMenu() {
              const menu = this._menu;
              this.isOpen() &&
                menu &&
                this._applyPlacementClasses(
                  'dynamic' === this.display
                    ? (function(
                        hostElement,
                        targetElement,
                        placement,
                        appendToBody,
                        baseClass
                      ) {
                        let placementVals = Array.isArray(placement)
                          ? placement
                          : placement.split(placementSeparator);
                        const allowedPlacements = [
                            'top',
                            'bottom',
                            'left',
                            'right',
                            'top-left',
                            'top-right',
                            'bottom-left',
                            'bottom-right',
                            'left-top',
                            'left-bottom',
                            'right-top',
                            'right-bottom'
                          ],
                          addClassesToTarget = targetPlacement => {
                            const [primary, secondary] = targetPlacement.split(
                                '-'
                              ),
                              classes = [];
                            return classes;
                          };
                        let hasAuto = placementVals.findIndex(
                          val => 'auto' === val
                        );
                        hasAuto >= 0 &&
                          allowedPlacements.forEach(function(obj) {
                            null ==
                              placementVals.find(
                                val => -1 !== val.search('^' + obj)
                              ) && placementVals.splice(hasAuto++, 1, obj);
                          });
                        const style = targetElement.style;
                        let testPlacement;
                        (style.position = 'absolute'),
                          (style.top = '0'),
                          (style.left = '0'),
                          (style['will-change'] = 'transform');
                        let isInViewport = !1;
                        for (testPlacement of placementVals) {
                          addClassesToTarget(testPlacement);
                          if (
                            positionService.positionElements(
                              hostElement,
                              targetElement,
                              testPlacement,
                              appendToBody
                            )
                          ) {
                            isInViewport = !0;
                            break;
                          }
                        }
                        return (
                          isInViewport ||
                            ((testPlacement = placementVals[0]),
                            addClassesToTarget(testPlacement),
                            positionService.positionElements(
                              hostElement,
                              targetElement,
                              testPlacement,
                              appendToBody
                            )),
                          testPlacement
                        );
                      })(
                        this._anchor.anchorEl,
                        this._bodyContainer || this._menuElement.nativeElement,
                        this.placement,
                        'body' === this.container
                      )
                    : this._getFirstPlacement(this.placement)
                );
            }
            _getFirstPlacement(placement) {
              return Array.isArray(placement)
                ? placement[0]
                : placement.split(' ')[0];
            }
            _resetContainer() {
              const renderer = this._renderer,
                menuElement = this._menuElement;
              if (menuElement) {
                const dropdownMenuElement = menuElement.nativeElement;
                renderer.appendChild(
                  this._elementRef.nativeElement,
                  dropdownMenuElement
                ),
                  renderer.removeStyle(dropdownMenuElement, 'position'),
                  renderer.removeStyle(dropdownMenuElement, 'transform');
              }
              this._bodyContainer &&
                (renderer.removeChild(this._document.body, this._bodyContainer),
                (this._bodyContainer = null));
            }
            _applyContainer(container = null) {
              if ((this._resetContainer(), 'body' === container)) {
                const renderer = this._renderer,
                  dropdownMenuElement = this._menuElement.nativeElement,
                  bodyContainer = (this._bodyContainer =
                    this._bodyContainer || renderer.createElement('div'));
                renderer.setStyle(bodyContainer, 'position', 'absolute'),
                  renderer.setStyle(dropdownMenuElement, 'position', 'static'),
                  renderer.setStyle(bodyContainer, 'z-index', '1050'),
                  renderer.appendChild(bodyContainer, dropdownMenuElement),
                  renderer.appendChild(this._document.body, bodyContainer);
              }
            }
            _applyPlacementClasses(placement) {
              const menu = this._menu;
              if (menu) {
                placement ||
                  (placement = this._getFirstPlacement(this.placement));
                const renderer = this._renderer,
                  dropdownElement = this._elementRef.nativeElement;
                renderer.removeClass(dropdownElement, 'dropup'),
                  renderer.removeClass(dropdownElement, 'dropdown'),
                  (menu.placement =
                    'static' === this.display ? null : placement);
                const dropdownClass =
                  -1 !== placement.search('^top') ? 'dropup' : 'dropdown';
                renderer.addClass(dropdownElement, dropdownClass);
                const bodyContainer = this._bodyContainer;
                bodyContainer &&
                  (renderer.removeClass(bodyContainer, 'dropup'),
                  renderer.removeClass(bodyContainer, 'dropdown'),
                  renderer.addClass(bodyContainer, dropdownClass));
              }
            }
          }
          return (
            (NgbDropdown.ɵfac = function(t) {
              return new (t || NgbDropdown)(
                core.Lb(core.h),
                core.Lb(ng_bootstrap_NgbDropdownConfig),
                core.Lb(common.c),
                core.Lb(core.z),
                core.Lb(core.l),
                core.Lb(core.D),
                core.Lb(ng_bootstrap_NgbNavbar, 8)
              );
            }),
            (NgbDropdown.ɵdir = core.Gb({
              type: NgbDropdown,
              selectors: [['', 'ngbDropdown', '']],
              contentQueries: function(rf, ctx, dirIndex) {
                var _t;
                1 & rf &&
                  (core.Eb(dirIndex, ng_bootstrap_NgbDropdownMenu, !0),
                  core.Eb(dirIndex, ng_bootstrap_NgbDropdownMenu, !0, core.l),
                  core.Eb(dirIndex, ng_bootstrap_NgbDropdownAnchor, !0)),
                  2 & rf &&
                    (core.sc((_t = core.cc())) && (ctx._menu = _t.first),
                    core.sc((_t = core.cc())) && (ctx._menuElement = _t.first),
                    core.sc((_t = core.cc())) && (ctx._anchor = _t.first));
              },
              hostVars: 2,
              hostBindings: function(rf, ctx) {
                2 & rf && core.Db('show', ctx.isOpen());
              },
              inputs: {
                _open: ['open', '_open'],
                placement: 'placement',
                container: 'container',
                autoClose: 'autoClose',
                display: 'display'
              },
              outputs: { openChange: 'openChange' },
              exportAs: ['ngbDropdown'],
              features: [core.vb]
            })),
            NgbDropdown
          );
        })(),
        ng_bootstrap_NgbDropdownModule = (() => {
          class NgbDropdownModule {}
          return (
            (NgbDropdownModule.ɵmod = core.Jb({ type: NgbDropdownModule })),
            (NgbDropdownModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbDropdownModule)();
              }
            })),
            NgbDropdownModule
          );
        })(),
        ng_bootstrap_NgbModalConfig = (() => {
          class NgbModalConfig {
            constructor() {
              (this.backdrop = !0), (this.keyboard = !0);
            }
          }
          return (
            (NgbModalConfig.ɵfac = function(t) {
              return new (t || NgbModalConfig)();
            }),
            (NgbModalConfig.ɵprov = core.Hb({
              token: NgbModalConfig,
              factory: NgbModalConfig.ɵfac,
              providedIn: 'root'
            })),
            (NgbModalConfig.ngInjectableDef = Object(core.Hb)({
              factory: function() {
                return new NgbModalConfig();
              },
              token: NgbModalConfig,
              providedIn: 'root'
            })),
            NgbModalConfig
          );
        })();
      class ContentRef {
        constructor(nodes, viewRef, componentRef) {
          (this.nodes = nodes),
            (this.viewRef = viewRef),
            (this.componentRef = componentRef);
        }
      }
      const ng_bootstrap_noop = () => {};
      let ng_bootstrap_ScrollBar = (() => {
          class ScrollBar {
            constructor(_document) {
              this._document = _document;
            }
            compensate() {
              return this._isPresent()
                ? this._adjustBody(this._getWidth())
                : ng_bootstrap_noop;
            }
            _adjustBody(width) {
              const body = this._document.body,
                userSetPadding = body.style.paddingRight,
                paddingAmount = parseFloat(
                  window.getComputedStyle(body)['padding-right']
                );
              return (
                (body.style['padding-right'] = paddingAmount + width + 'px'),
                () => (body.style['padding-right'] = userSetPadding)
              );
            }
            _isPresent() {
              const rect = this._document.body.getBoundingClientRect();
              return rect.left + rect.right < window.innerWidth;
            }
            _getWidth() {
              const measurer = this._document.createElement('div');
              measurer.className = 'modal-scrollbar-measure';
              const body = this._document.body;
              body.appendChild(measurer);
              const width =
                measurer.getBoundingClientRect().width - measurer.clientWidth;
              return body.removeChild(measurer), width;
            }
          }
          return (
            (ScrollBar.ɵfac = function(t) {
              return new (t || ScrollBar)(core.Yb(common.c));
            }),
            (ScrollBar.ɵprov = core.Hb({
              token: ScrollBar,
              factory: ScrollBar.ɵfac,
              providedIn: 'root'
            })),
            (ScrollBar.ngInjectableDef = Object(core.Hb)({
              factory: function() {
                return new ScrollBar(Object(core.Yb)(common.c));
              },
              token: ScrollBar,
              providedIn: 'root'
            })),
            ScrollBar
          );
        })(),
        ng_bootstrap_NgbModalBackdrop = (() => {
          class NgbModalBackdrop {}
          return (
            (NgbModalBackdrop.ɵfac = function(t) {
              return new (t || NgbModalBackdrop)();
            }),
            (NgbModalBackdrop.ɵcmp = core.Fb({
              type: NgbModalBackdrop,
              selectors: [['ngb-modal-backdrop']],
              hostAttrs: [2, 'z-index', '1050'],
              hostVars: 2,
              hostBindings: function(rf, ctx) {
                2 & rf &&
                  core.zb(
                    'modal-backdrop fade show' +
                      (ctx.backdropClass ? ' ' + ctx.backdropClass : '')
                  );
              },
              inputs: { backdropClass: 'backdropClass' },
              decls: 0,
              vars: 0,
              template: function(rf, ctx) {},
              encapsulation: 2
            })),
            NgbModalBackdrop
          );
        })();
      class NgbActiveModal {
        close(result) {}
        dismiss(reason) {}
      }
      class NgbModalRef {
        constructor(
          _windowCmptRef,
          _contentRef,
          _backdropCmptRef,
          _beforeDismiss
        ) {
          (this._windowCmptRef = _windowCmptRef),
            (this._contentRef = _contentRef),
            (this._backdropCmptRef = _backdropCmptRef),
            (this._beforeDismiss = _beforeDismiss),
            _windowCmptRef.instance.dismissEvent.subscribe(reason => {
              this.dismiss(reason);
            }),
            (this.result = new Promise((resolve, reject) => {
              (this._resolve = resolve), (this._reject = reject);
            })),
            this.result.then(null, () => {});
        }
        get componentInstance() {
          if (this._contentRef.componentRef)
            return this._contentRef.componentRef.instance;
        }
        close(result) {
          this._windowCmptRef &&
            (this._resolve(result), this._removeModalElements());
        }
        _dismiss(reason) {
          this._reject(reason), this._removeModalElements();
        }
        dismiss(reason) {
          if (this._windowCmptRef)
            if (this._beforeDismiss) {
              const dismiss = this._beforeDismiss();
              dismiss && dismiss.then
                ? dismiss.then(
                    result => {
                      !1 !== result && this._dismiss(reason);
                    },
                    () => {}
                  )
                : !1 !== dismiss && this._dismiss(reason);
            } else this._dismiss(reason);
        }
        _removeModalElements() {
          const windowNativeEl = this._windowCmptRef.location.nativeElement;
          if (
            (windowNativeEl.parentNode.removeChild(windowNativeEl),
            this._windowCmptRef.destroy(),
            this._backdropCmptRef)
          ) {
            const backdropNativeEl = this._backdropCmptRef.location
              .nativeElement;
            backdropNativeEl.parentNode.removeChild(backdropNativeEl),
              this._backdropCmptRef.destroy();
          }
          this._contentRef &&
            this._contentRef.viewRef &&
            this._contentRef.viewRef.destroy(),
            (this._windowCmptRef = null),
            (this._backdropCmptRef = null),
            (this._contentRef = null);
        }
      }
      const ModalDismissReasons = (function() {
        var ModalDismissReasons = { BACKDROP_CLICK: 0, ESC: 1 };
        return (
          (ModalDismissReasons[ModalDismissReasons.BACKDROP_CLICK] =
            'BACKDROP_CLICK'),
          (ModalDismissReasons[ModalDismissReasons.ESC] = 'ESC'),
          ModalDismissReasons
        );
      })();
      let ng_bootstrap_NgbModalWindow = (() => {
          class NgbModalWindow {
            constructor(_document, _elRef) {
              (this._document = _document),
                (this._elRef = _elRef),
                (this.backdrop = !0),
                (this.keyboard = !0),
                (this.dismissEvent = new core.n());
            }
            backdropClick($event) {
              !0 === this.backdrop &&
                this._elRef.nativeElement === $event.target &&
                this.dismiss(ModalDismissReasons.BACKDROP_CLICK);
            }
            escKey($event) {
              this.keyboard &&
                !$event.defaultPrevented &&
                this.dismiss(ModalDismissReasons.ESC);
            }
            dismiss(reason) {
              this.dismissEvent.emit(reason);
            }
            ngOnInit() {
              this._elWithFocus = this._document.activeElement;
            }
            ngAfterViewInit() {
              if (!this._elRef.nativeElement.contains(document.activeElement)) {
                const autoFocusable = this._elRef.nativeElement.querySelector(
                    '[ngbAutofocus]'
                  ),
                  firstFocusable = getFocusableBoundaryElements(
                    this._elRef.nativeElement
                  )[0];
                (
                  autoFocusable ||
                  firstFocusable ||
                  this._elRef.nativeElement
                ).focus();
              }
            }
            ngOnDestroy() {
              const body = this._document.body,
                elWithFocus = this._elWithFocus;
              let elementToFocus;
              (elementToFocus =
                elWithFocus && elWithFocus.focus && body.contains(elWithFocus)
                  ? elWithFocus
                  : body),
                elementToFocus.focus(),
                (this._elWithFocus = null);
            }
          }
          return (
            (NgbModalWindow.ɵfac = function(t) {
              return new (t || NgbModalWindow)(
                core.Lb(common.c),
                core.Lb(core.l)
              );
            }),
            (NgbModalWindow.ɵcmp = core.Fb({
              type: NgbModalWindow,
              selectors: [['ngb-modal-window']],
              hostAttrs: ['role', 'dialog', 'tabindex', '-1'],
              hostVars: 4,
              hostBindings: function(rf, ctx) {
                1 & rf &&
                  core.bc('keyup.esc', function($event) {
                    return ctx.escKey($event);
                  })('click', function($event) {
                    return ctx.backdropClick($event);
                  }),
                  2 & rf &&
                    (core.yb('aria-modal', !0)(
                      'aria-labelledby',
                      ctx.ariaLabelledBy
                    ),
                    core.zb(
                      'modal fade show d-block' +
                        (ctx.windowClass ? ' ' + ctx.windowClass : '')
                    ));
              },
              inputs: {
                backdrop: 'backdrop',
                keyboard: 'keyboard',
                ariaLabelledBy: 'ariaLabelledBy',
                centered: 'centered',
                scrollable: 'scrollable',
                size: 'size',
                windowClass: 'windowClass'
              },
              outputs: { dismissEvent: 'dismiss' },
              ngContentSelectors: _c4,
              decls: 7,
              vars: 2,
              consts: [['role', 'document'], [1, 'modal-content']],
              template: function(rf, ctx) {
                1 & rf &&
                  (core.jc(),
                  core.Fc(0, '\n    '),
                  core.Qb(1, 'div', 0),
                  core.Fc(2, '\n        '),
                  core.Qb(3, 'div', 1),
                  core.ic(4),
                  core.Pb(),
                  core.Fc(5, '\n    '),
                  core.Pb(),
                  core.Fc(6, '\n    ')),
                  2 & rf &&
                    (core.xb(1),
                    core.zb(
                      'modal-dialog' +
                        (ctx.size ? ' modal-' + ctx.size : '') +
                        (ctx.centered ? ' modal-dialog-centered' : '') +
                        (ctx.scrollable ? ' modal-dialog-scrollable' : '')
                    ));
              },
              styles: [
                'ngb-modal-window .component-host-scrollable{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;overflow:hidden}'
              ],
              encapsulation: 2
            })),
            NgbModalWindow
          );
        })(),
        ng_bootstrap_NgbModalStack = (() => {
          class NgbModalStack {
            constructor(
              _applicationRef,
              _injector,
              _document,
              _scrollBar,
              _rendererFactory
            ) {
              (this._applicationRef = _applicationRef),
                (this._injector = _injector),
                (this._document = _document),
                (this._scrollBar = _scrollBar),
                (this._rendererFactory = _rendererFactory),
                (this._activeWindowCmptHasChanged = new Subject.a()),
                (this._ariaHiddenValues = new Map()),
                (this._backdropAttributes = ['backdropClass']),
                (this._modalRefs = []),
                (this._windowAttributes = [
                  'ariaLabelledBy',
                  'backdrop',
                  'centered',
                  'keyboard',
                  'scrollable',
                  'size',
                  'windowClass'
                ]),
                (this._windowCmpts = []),
                this._activeWindowCmptHasChanged.subscribe(() => {
                  if (this._windowCmpts.length) {
                    const activeWindowCmpt = this._windowCmpts[
                      this._windowCmpts.length - 1
                    ];
                    ((element, stopFocusTrap$, refocusOnClick = !1) => {
                      const lastFocusedElement$ = fromEvent(
                        element,
                        'focusin'
                      ).pipe(
                        Object(takeUntil.a)(stopFocusTrap$),
                        Object(map.a)(e => e.target)
                      );
                      fromEvent(element, 'keydown')
                        .pipe(
                          Object(takeUntil.a)(stopFocusTrap$),
                          Object(filter.a)(e => e.which === Key.Tab),
                          withLatestFrom(lastFocusedElement$)
                        )
                        .subscribe(([tabEvent, focusedElement]) => {
                          const [first, last] = getFocusableBoundaryElements(
                            element
                          );
                          (focusedElement !== first &&
                            focusedElement !== element) ||
                            !tabEvent.shiftKey ||
                            (last.focus(), tabEvent.preventDefault()),
                            focusedElement !== last ||
                              tabEvent.shiftKey ||
                              (first.focus(), tabEvent.preventDefault());
                        }),
                        refocusOnClick &&
                          fromEvent(element, 'click')
                            .pipe(
                              Object(takeUntil.a)(stopFocusTrap$),
                              withLatestFrom(lastFocusedElement$),
                              Object(map.a)(arr => arr[1])
                            )
                            .subscribe(lastFocusedElement =>
                              lastFocusedElement.focus()
                            );
                    })(
                      activeWindowCmpt.location.nativeElement,
                      this._activeWindowCmptHasChanged
                    ),
                      this._revertAriaHidden(),
                      this._setAriaHidden(
                        activeWindowCmpt.location.nativeElement
                      );
                  }
                });
            }
            open(moduleCFR, contentInjector, content, options) {
              const containerEl = isDefined(options.container)
                  ? this._document.querySelector(options.container)
                  : this._document.body,
                renderer = this._rendererFactory.createRenderer(null, null),
                revertPaddingForScrollBar = this._scrollBar.compensate(),
                removeBodyClass = () => {
                  this._modalRefs.length ||
                    (renderer.removeClass(this._document.body, 'modal-open'),
                    this._revertAriaHidden());
                };
              if (!containerEl)
                throw new Error(
                  `The specified modal container "${options.container ||
                    'body'}" was not found in the DOM.`
                );
              const activeModal = new NgbActiveModal(),
                contentRef = this._getContentRef(
                  moduleCFR,
                  options.injector || contentInjector,
                  content,
                  activeModal,
                  options
                );
              let backdropCmptRef =
                  !1 !== options.backdrop
                    ? this._attachBackdrop(moduleCFR, containerEl)
                    : null,
                windowCmptRef = this._attachWindowComponent(
                  moduleCFR,
                  containerEl,
                  contentRef
                ),
                ngbModalRef = new NgbModalRef(
                  windowCmptRef,
                  contentRef,
                  backdropCmptRef,
                  options.beforeDismiss
                );
              return (
                this._registerModalRef(ngbModalRef),
                this._registerWindowCmpt(windowCmptRef),
                ngbModalRef.result.then(
                  revertPaddingForScrollBar,
                  revertPaddingForScrollBar
                ),
                ngbModalRef.result.then(removeBodyClass, removeBodyClass),
                (activeModal.close = result => {
                  ngbModalRef.close(result);
                }),
                (activeModal.dismiss = reason => {
                  ngbModalRef.dismiss(reason);
                }),
                this._applyWindowOptions(windowCmptRef.instance, options),
                1 === this._modalRefs.length &&
                  renderer.addClass(this._document.body, 'modal-open'),
                backdropCmptRef &&
                  backdropCmptRef.instance &&
                  this._applyBackdropOptions(backdropCmptRef.instance, options),
                ngbModalRef
              );
            }
            dismissAll(reason) {
              this._modalRefs.forEach(ngbModalRef =>
                ngbModalRef.dismiss(reason)
              );
            }
            hasOpenModals() {
              return this._modalRefs.length > 0;
            }
            _attachBackdrop(moduleCFR, containerEl) {
              let backdropCmptRef = moduleCFR
                .resolveComponentFactory(ng_bootstrap_NgbModalBackdrop)
                .create(this._injector);
              return (
                this._applicationRef.attachView(backdropCmptRef.hostView),
                containerEl.appendChild(backdropCmptRef.location.nativeElement),
                backdropCmptRef
              );
            }
            _attachWindowComponent(moduleCFR, containerEl, contentRef) {
              let windowCmptRef = moduleCFR
                .resolveComponentFactory(ng_bootstrap_NgbModalWindow)
                .create(this._injector, contentRef.nodes);
              return (
                this._applicationRef.attachView(windowCmptRef.hostView),
                containerEl.appendChild(windowCmptRef.location.nativeElement),
                windowCmptRef
              );
            }
            _applyWindowOptions(windowInstance, options) {
              this._windowAttributes.forEach(optionName => {
                isDefined(options[optionName]) &&
                  (windowInstance[optionName] = options[optionName]);
              });
            }
            _applyBackdropOptions(backdropInstance, options) {
              this._backdropAttributes.forEach(optionName => {
                isDefined(options[optionName]) &&
                  (backdropInstance[optionName] = options[optionName]);
              });
            }
            _getContentRef(
              moduleCFR,
              contentInjector,
              content,
              activeModal,
              options
            ) {
              return content
                ? content instanceof core.K
                  ? this._createFromTemplateRef(content, activeModal)
                  : isString(content)
                  ? this._createFromString(content)
                  : this._createFromComponent(
                      moduleCFR,
                      contentInjector,
                      content,
                      activeModal,
                      options
                    )
                : new ContentRef([]);
            }
            _createFromTemplateRef(content, activeModal) {
              const viewRef = content.createEmbeddedView({
                $implicit: activeModal,
                close(result) {
                  activeModal.close(result);
                },
                dismiss(reason) {
                  activeModal.dismiss(reason);
                }
              });
              return (
                this._applicationRef.attachView(viewRef),
                new ContentRef([viewRef.rootNodes], viewRef)
              );
            }
            _createFromString(content) {
              const component = this._document.createTextNode('' + content);
              return new ContentRef([[component]]);
            }
            _createFromComponent(
              moduleCFR,
              contentInjector,
              content,
              context,
              options
            ) {
              const contentCmptFactory = moduleCFR.resolveComponentFactory(
                  content
                ),
                modalContentInjector = core.r.create({
                  providers: [{ provide: NgbActiveModal, useValue: context }],
                  parent: contentInjector
                }),
                componentRef = contentCmptFactory.create(modalContentInjector),
                componentNativeEl = componentRef.location.nativeElement;
              return (
                options.scrollable &&
                  componentNativeEl.classList.add('component-host-scrollable'),
                this._applicationRef.attachView(componentRef.hostView),
                new ContentRef(
                  [[componentNativeEl]],
                  componentRef.hostView,
                  componentRef
                )
              );
            }
            _setAriaHidden(element) {
              const parent = element.parentElement;
              parent &&
                element !== this._document.body &&
                (Array.from(parent.children).forEach(sibling => {
                  sibling !== element &&
                    'SCRIPT' !== sibling.nodeName &&
                    (this._ariaHiddenValues.set(
                      sibling,
                      sibling.getAttribute('aria-hidden')
                    ),
                    sibling.setAttribute('aria-hidden', 'true'));
                }),
                this._setAriaHidden(parent));
            }
            _revertAriaHidden() {
              this._ariaHiddenValues.forEach((value, element) => {
                value
                  ? element.setAttribute('aria-hidden', value)
                  : element.removeAttribute('aria-hidden');
              }),
                this._ariaHiddenValues.clear();
            }
            _registerModalRef(ngbModalRef) {
              const unregisterModalRef = () => {
                const index = this._modalRefs.indexOf(ngbModalRef);
                index > -1 && this._modalRefs.splice(index, 1);
              };
              this._modalRefs.push(ngbModalRef),
                ngbModalRef.result.then(unregisterModalRef, unregisterModalRef);
            }
            _registerWindowCmpt(ngbWindowCmpt) {
              this._windowCmpts.push(ngbWindowCmpt),
                this._activeWindowCmptHasChanged.next(),
                ngbWindowCmpt.onDestroy(() => {
                  const index = this._windowCmpts.indexOf(ngbWindowCmpt);
                  index > -1 &&
                    (this._windowCmpts.splice(index, 1),
                    this._activeWindowCmptHasChanged.next());
                });
            }
          }
          return (
            (NgbModalStack.ɵfac = function(t) {
              return new (t || NgbModalStack)(
                core.Yb(core.g),
                core.Yb(core.r),
                core.Yb(common.c),
                core.Yb(ng_bootstrap_ScrollBar),
                core.Yb(core.E)
              );
            }),
            (NgbModalStack.ɵprov = core.Hb({
              token: NgbModalStack,
              factory: NgbModalStack.ɵfac,
              providedIn: 'root'
            })),
            (NgbModalStack.ngInjectableDef = Object(core.Hb)({
              factory: function() {
                return new NgbModalStack(
                  Object(core.Yb)(core.g),
                  Object(core.Yb)(core.o),
                  Object(core.Yb)(common.c),
                  Object(core.Yb)(ng_bootstrap_ScrollBar),
                  Object(core.Yb)(core.E)
                );
              },
              token: NgbModalStack,
              providedIn: 'root'
            })),
            NgbModalStack
          );
        })(),
        ng_bootstrap_NgbModal = (() => {
          class NgbModal {
            constructor(_moduleCFR, _injector, _modalStack, _config) {
              (this._moduleCFR = _moduleCFR),
                (this._injector = _injector),
                (this._modalStack = _modalStack),
                (this._config = _config);
            }
            open(content, options = {}) {
              const combinedOptions = Object.assign({}, this._config, options);
              return this._modalStack.open(
                this._moduleCFR,
                this._injector,
                content,
                combinedOptions
              );
            }
            dismissAll(reason) {
              this._modalStack.dismissAll(reason);
            }
            hasOpenModals() {
              return this._modalStack.hasOpenModals();
            }
          }
          return (
            (NgbModal.ɵfac = function(t) {
              return new (t || NgbModal)(
                core.Yb(core.j),
                core.Yb(core.r),
                core.Yb(ng_bootstrap_NgbModalStack),
                core.Yb(ng_bootstrap_NgbModalConfig)
              );
            }),
            (NgbModal.ɵprov = core.Hb({
              token: NgbModal,
              factory: NgbModal.ɵfac,
              providedIn: 'root'
            })),
            (NgbModal.ngInjectableDef = Object(core.Hb)({
              factory: function() {
                return new NgbModal(
                  Object(core.Yb)(core.j),
                  Object(core.Yb)(core.o),
                  Object(core.Yb)(ng_bootstrap_NgbModalStack),
                  Object(core.Yb)(ng_bootstrap_NgbModalConfig)
                );
              },
              token: NgbModal,
              providedIn: 'root'
            })),
            NgbModal
          );
        })(),
        ng_bootstrap_NgbModalModule = (() => {
          class NgbModalModule {}
          return (
            (NgbModalModule.ɵmod = core.Jb({ type: NgbModalModule })),
            (NgbModalModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbModalModule)();
              },
              providers: [ng_bootstrap_NgbModal]
            })),
            NgbModalModule
          );
        })(),
        ng_bootstrap_NgbPaginationModule = (() => {
          class NgbPaginationModule {}
          return (
            (NgbPaginationModule.ɵmod = core.Jb({ type: NgbPaginationModule })),
            (NgbPaginationModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbPaginationModule)();
              },
              imports: [[common.b]]
            })),
            NgbPaginationModule
          );
        })(),
        ng_bootstrap_NgbPopoverModule = (() => {
          class NgbPopoverModule {}
          return (
            (NgbPopoverModule.ɵmod = core.Jb({ type: NgbPopoverModule })),
            (NgbPopoverModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbPopoverModule)();
              },
              imports: [[common.b]]
            })),
            NgbPopoverModule
          );
        })(),
        ng_bootstrap_NgbProgressbarConfig = (() => {
          class NgbProgressbarConfig {
            constructor() {
              (this.max = 100),
                (this.animated = !1),
                (this.striped = !1),
                (this.showValue = !1);
            }
          }
          return (
            (NgbProgressbarConfig.ɵfac = function(t) {
              return new (t || NgbProgressbarConfig)();
            }),
            (NgbProgressbarConfig.ɵprov = core.Hb({
              token: NgbProgressbarConfig,
              factory: NgbProgressbarConfig.ɵfac,
              providedIn: 'root'
            })),
            (NgbProgressbarConfig.ngInjectableDef = Object(core.Hb)({
              factory: function() {
                return new NgbProgressbarConfig();
              },
              token: NgbProgressbarConfig,
              providedIn: 'root'
            })),
            NgbProgressbarConfig
          );
        })(),
        ng_bootstrap_NgbProgressbar = (() => {
          class NgbProgressbar {
            constructor(config) {
              (this.value = 0),
                (this.max = config.max),
                (this.animated = config.animated),
                (this.striped = config.striped),
                (this.type = config.type),
                (this.showValue = config.showValue),
                (this.height = config.height);
            }
            getValue() {
              return (function(value, max, min = 0) {
                return Math.max(Math.min(value, max), min);
              })(this.value, this.max);
            }
            getPercentValue() {
              return (100 * this.getValue()) / this.max;
            }
          }
          return (
            (NgbProgressbar.ɵfac = function(t) {
              return new (t || NgbProgressbar)(
                core.Lb(ng_bootstrap_NgbProgressbarConfig)
              );
            }),
            (NgbProgressbar.ɵcmp = core.Fb({
              type: NgbProgressbar,
              selectors: [['ngb-progressbar']],
              inputs: {
                value: 'value',
                max: 'max',
                animated: 'animated',
                striped: 'striped',
                type: 'type',
                showValue: 'showValue',
                height: 'height'
              },
              ngContentSelectors: _c4,
              decls: 10,
              vars: 12,
              consts: [
                [1, 'progress'],
                ['role', 'progressbar', 'aria-valuemin', '0'],
                [4, 'ngIf']
              ],
              template: function(rf, ctx) {
                1 & rf &&
                  (core.jc(),
                  core.Fc(0, '\n    '),
                  core.Qb(1, 'div', 0),
                  core.Fc(2, '\n      '),
                  core.Qb(3, 'div', 1),
                  core.Fc(4, '\n        '),
                  core.Dc(5, NgbProgressbar_span_5_Template, 2, 1, 'span', 2),
                  core.ic(6),
                  core.Fc(7, '\n      '),
                  core.Pb(),
                  core.Fc(8, '\n    '),
                  core.Pb(),
                  core.Fc(9, '\n  ')),
                  2 & rf &&
                    (core.xb(1),
                    core.Cc('height', ctx.height),
                    core.xb(2),
                    core.Cb(
                      'progress-bar',
                      ctx.type ? ' bg-' + ctx.type : '',
                      '',
                      ctx.animated ? ' progress-bar-animated' : '',
                      '',
                      ctx.striped ? ' progress-bar-striped' : '',
                      ''
                    ),
                    core.Cc('width', ctx.getPercentValue(), '%'),
                    core.yb('aria-valuenow', ctx.getValue())(
                      'aria-valuemax',
                      ctx.max
                    ),
                    core.xb(2),
                    core.kc('ngIf', ctx.showValue));
              },
              directives: [common.k],
              encapsulation: 2,
              changeDetection: 0
            })),
            NgbProgressbar
          );
        })(),
        ng_bootstrap_NgbProgressbarModule = (() => {
          class NgbProgressbarModule {}
          return (
            (NgbProgressbarModule.ɵmod = core.Jb({
              type: NgbProgressbarModule
            })),
            (NgbProgressbarModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbProgressbarModule)();
              },
              imports: [[common.b]]
            })),
            NgbProgressbarModule
          );
        })(),
        ng_bootstrap_NgbRatingModule = (() => {
          class NgbRatingModule {}
          return (
            (NgbRatingModule.ɵmod = core.Jb({ type: NgbRatingModule })),
            (NgbRatingModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbRatingModule)();
              },
              imports: [[common.b]]
            })),
            NgbRatingModule
          );
        })(),
        ng_bootstrap_NgbTabsetConfig = (() => {
          class NgbTabsetConfig {
            constructor() {
              (this.justify = 'start'),
                (this.orientation = 'horizontal'),
                (this.type = 'tabs');
            }
          }
          return (
            (NgbTabsetConfig.ɵfac = function(t) {
              return new (t || NgbTabsetConfig)();
            }),
            (NgbTabsetConfig.ɵprov = core.Hb({
              token: NgbTabsetConfig,
              factory: NgbTabsetConfig.ɵfac,
              providedIn: 'root'
            })),
            (NgbTabsetConfig.ngInjectableDef = Object(core.Hb)({
              factory: function() {
                return new NgbTabsetConfig();
              },
              token: NgbTabsetConfig,
              providedIn: 'root'
            })),
            NgbTabsetConfig
          );
        })(),
        nextId$4 = 0,
        ng_bootstrap_NgbTabTitle = (() => {
          class NgbTabTitle {
            constructor(templateRef) {
              this.templateRef = templateRef;
            }
          }
          return (
            (NgbTabTitle.ɵfac = function(t) {
              return new (t || NgbTabTitle)(core.Lb(core.K));
            }),
            (NgbTabTitle.ɵdir = core.Gb({
              type: NgbTabTitle,
              selectors: [['ng-template', 'ngbTabTitle', '']]
            })),
            NgbTabTitle
          );
        })(),
        ng_bootstrap_NgbTabContent = (() => {
          class NgbTabContent {
            constructor(templateRef) {
              this.templateRef = templateRef;
            }
          }
          return (
            (NgbTabContent.ɵfac = function(t) {
              return new (t || NgbTabContent)(core.Lb(core.K));
            }),
            (NgbTabContent.ɵdir = core.Gb({
              type: NgbTabContent,
              selectors: [['ng-template', 'ngbTabContent', '']]
            })),
            NgbTabContent
          );
        })(),
        ng_bootstrap_NgbTab = (() => {
          class NgbTab {
            constructor() {
              (this.id = 'ngb-tab-' + nextId$4++), (this.disabled = !1);
            }
            ngAfterContentChecked() {
              (this.titleTpl = this.titleTpls.first),
                (this.contentTpl = this.contentTpls.first);
            }
          }
          return (
            (NgbTab.ɵfac = function(t) {
              return new (t || NgbTab)();
            }),
            (NgbTab.ɵdir = core.Gb({
              type: NgbTab,
              selectors: [['ngb-tab']],
              contentQueries: function(rf, ctx, dirIndex) {
                var _t;
                1 & rf &&
                  (core.Eb(dirIndex, ng_bootstrap_NgbTabTitle, !1),
                  core.Eb(dirIndex, ng_bootstrap_NgbTabContent, !1)),
                  2 & rf &&
                    (core.sc((_t = core.cc())) && (ctx.titleTpls = _t),
                    core.sc((_t = core.cc())) && (ctx.contentTpls = _t));
              },
              inputs: { id: 'id', disabled: 'disabled', title: 'title' }
            })),
            NgbTab
          );
        })(),
        ng_bootstrap_NgbTabset = (() => {
          class NgbTabset {
            constructor(config) {
              (this.destroyOnHide = !0),
                (this.tabChange = new core.n()),
                (this.type = config.type),
                (this.justify = config.justify),
                (this.orientation = config.orientation);
            }
            set justify(className) {
              this.justifyClass =
                'fill' === className || 'justified' === className
                  ? 'nav-' + className
                  : 'justify-content-' + className;
            }
            select(tabId) {
              let selectedTab = this._getTabById(tabId);
              if (
                selectedTab &&
                !selectedTab.disabled &&
                this.activeId !== selectedTab.id
              ) {
                let defaultPrevented = !1;
                this.tabChange.emit({
                  activeId: this.activeId,
                  nextId: selectedTab.id,
                  preventDefault: () => {
                    defaultPrevented = !0;
                  }
                }),
                  defaultPrevented || (this.activeId = selectedTab.id);
              }
            }
            ngAfterContentChecked() {
              let activeTab = this._getTabById(this.activeId);
              this.activeId = activeTab
                ? activeTab.id
                : this.tabs.length
                ? this.tabs.first.id
                : null;
            }
            _getTabById(id) {
              let tabsWithId = this.tabs.filter(tab => tab.id === id);
              return tabsWithId.length ? tabsWithId[0] : null;
            }
          }
          return (
            (NgbTabset.ɵfac = function(t) {
              return new (t || NgbTabset)(
                core.Lb(ng_bootstrap_NgbTabsetConfig)
              );
            }),
            (NgbTabset.ɵcmp = core.Fb({
              type: NgbTabset,
              selectors: [['ngb-tabset']],
              contentQueries: function(rf, ctx, dirIndex) {
                var _t;
                1 & rf && core.Eb(dirIndex, ng_bootstrap_NgbTab, !1),
                  2 & rf && core.sc((_t = core.cc())) && (ctx.tabs = _t);
              },
              inputs: {
                destroyOnHide: 'destroyOnHide',
                type: 'type',
                justify: 'justify',
                orientation: 'orientation',
                activeId: 'activeId'
              },
              outputs: { tabChange: 'tabChange' },
              exportAs: ['ngbTabset'],
              decls: 11,
              vars: 4,
              consts: [
                ['role', 'tablist'],
                ['class', 'nav-item', 4, 'ngFor', 'ngForOf'],
                [1, 'tab-content'],
                ['ngFor', '', 3, 'ngForOf'],
                [1, 'nav-item'],
                ['href', '', 'role', 'tab', 1, 'nav-link', 3, 'id', 'click'],
                [3, 'ngTemplateOutlet'],
                ['role', 'tabpanel', 3, 'class', 'id', 4, 'ngIf'],
                ['role', 'tabpanel', 3, 'id']
              ],
              template: function(rf, ctx) {
                1 & rf &&
                  (core.Fc(0, '\n    '),
                  core.Qb(1, 'ul', 0),
                  core.Fc(2, '\n      '),
                  core.Dc(3, NgbTabset_li_3_Template, 7, 11, 'li', 1),
                  core.Fc(4, '\n    '),
                  core.Pb(),
                  core.Fc(5, '\n    '),
                  core.Qb(6, 'div', 2),
                  core.Fc(7, '\n      '),
                  core.Dc(
                    8,
                    NgbTabset_ng_template_8_Template,
                    3,
                    1,
                    'ng-template',
                    3
                  ),
                  core.Fc(9, '\n    '),
                  core.Pb(),
                  core.Fc(10, '\n  ')),
                  2 & rf &&
                    (core.xb(1),
                    core.zb(
                      'nav nav-' +
                        ctx.type +
                        ('horizontal' == ctx.orientation
                          ? ' ' + ctx.justifyClass
                          : ' flex-column')
                    ),
                    core.xb(2),
                    core.kc('ngForOf', ctx.tabs),
                    core.xb(5),
                    core.kc('ngForOf', ctx.tabs));
              },
              directives: [common.j, common.m, common.k],
              encapsulation: 2
            })),
            NgbTabset
          );
        })(),
        ng_bootstrap_NgbTabsetModule = (() => {
          class NgbTabsetModule {}
          return (
            (NgbTabsetModule.ɵmod = core.Jb({ type: NgbTabsetModule })),
            (NgbTabsetModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbTabsetModule)();
              },
              imports: [[common.b]]
            })),
            NgbTabsetModule
          );
        })(),
        ng_bootstrap_NgbTimepickerModule = (() => {
          class NgbTimepickerModule {}
          return (
            (NgbTimepickerModule.ɵmod = core.Jb({ type: NgbTimepickerModule })),
            (NgbTimepickerModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbTimepickerModule)();
              },
              imports: [[common.b]]
            })),
            NgbTimepickerModule
          );
        })(),
        ng_bootstrap_NgbToastModule = (() => {
          class NgbToastModule {}
          return (
            (NgbToastModule.ɵmod = core.Jb({ type: NgbToastModule })),
            (NgbToastModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbToastModule)();
              },
              imports: [[common.b]]
            })),
            NgbToastModule
          );
        })(),
        ng_bootstrap_NgbTooltipModule = (() => {
          class NgbTooltipModule {}
          return (
            (NgbTooltipModule.ɵmod = core.Jb({ type: NgbTooltipModule })),
            (NgbTooltipModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbTooltipModule)();
              }
            })),
            NgbTooltipModule
          );
        })(),
        ng_bootstrap_NgbTypeaheadModule = (() => {
          class NgbTypeaheadModule {}
          return (
            (NgbTypeaheadModule.ɵmod = core.Jb({ type: NgbTypeaheadModule })),
            (NgbTypeaheadModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || NgbTypeaheadModule)();
              },
              imports: [[common.b]]
            })),
            NgbTypeaheadModule
          );
        })();
      const NGB_MODULES = [
        ng_bootstrap_NgbAccordionModule,
        ng_bootstrap_NgbAlertModule,
        ng_bootstrap_NgbButtonsModule,
        ng_bootstrap_NgbCarouselModule,
        ng_bootstrap_NgbCollapseModule,
        ng_bootstrap_NgbDatepickerModule,
        ng_bootstrap_NgbDropdownModule,
        ng_bootstrap_NgbModalModule,
        ng_bootstrap_NgbPaginationModule,
        ng_bootstrap_NgbPopoverModule,
        ng_bootstrap_NgbProgressbarModule,
        ng_bootstrap_NgbRatingModule,
        ng_bootstrap_NgbTabsetModule,
        ng_bootstrap_NgbTimepickerModule,
        ng_bootstrap_NgbToastModule,
        ng_bootstrap_NgbTooltipModule,
        ng_bootstrap_NgbTypeaheadModule
      ];
      let ng_bootstrap_NgbModule = (() => {
        class NgbModule {}
        return (
          (NgbModule.ɵmod = core.Jb({ type: NgbModule })),
          (NgbModule.ɵinj = core.Ib({
            factory: function(t) {
              return new (t || NgbModule)();
            },
            imports: [
              NGB_MODULES,
              ng_bootstrap_NgbAccordionModule,
              ng_bootstrap_NgbAlertModule,
              ng_bootstrap_NgbButtonsModule,
              ng_bootstrap_NgbCarouselModule,
              ng_bootstrap_NgbCollapseModule,
              ng_bootstrap_NgbDatepickerModule,
              ng_bootstrap_NgbDropdownModule,
              ng_bootstrap_NgbModalModule,
              ng_bootstrap_NgbPaginationModule,
              ng_bootstrap_NgbPopoverModule,
              ng_bootstrap_NgbProgressbarModule,
              ng_bootstrap_NgbRatingModule,
              ng_bootstrap_NgbTabsetModule,
              ng_bootstrap_NgbTimepickerModule,
              ng_bootstrap_NgbToastModule,
              ng_bootstrap_NgbTooltipModule,
              ng_bootstrap_NgbTypeaheadModule
            ]
          })),
          NgbModule
        );
      })();
    },
    '2QA8': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return rxSubscriber;
      });
      const rxSubscriber = (() =>
        'function' == typeof Symbol
          ? Symbol('rxSubscriber')
          : '@@rxSubscriber_' + Math.random())();
    },
    '2Vo4': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return BehaviorSubject;
      });
      var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__('XNiG'),
        _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          '9ppp'
        );
      class BehaviorSubject extends _Subject__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(_value) {
          super(), (this._value = _value);
        }
        get value() {
          return this.getValue();
        }
        _subscribe(subscriber) {
          const subscription = super._subscribe(subscriber);
          return (
            subscription &&
              !subscription.closed &&
              subscriber.next(this._value),
            subscription
          );
        }
        getValue() {
          if (this.hasError) throw this.thrownError;
          if (this.closed)
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__.a();
          return this._value;
        }
        next(value) {
          super.next((this._value = value));
        }
      }
    },
    '2fFW': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return config;
      });
      let _enable_super_gross_mode_that_will_cause_bad_things = !1;
      const config = {
        Promise: void 0,
        set useDeprecatedSynchronousErrorHandling(value) {
          if (value) {
            const error = new Error();
            console.warn(
              'DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' +
                error.stack
            );
          } else
            _enable_super_gross_mode_that_will_cause_bad_things &&
              console.log(
                'RxJS: Back to a better error behavior. Thank you. <3'
              );
          _enable_super_gross_mode_that_will_cause_bad_things = value;
        },
        get useDeprecatedSynchronousErrorHandling() {
          return _enable_super_gross_mode_that_will_cause_bad_things;
        }
      };
    },
    '2oRo': function(module, exports) {
      var O = 'object',
        check = function(it) {
          return it && it.Math == Math && it;
        };
      module.exports =
        check(typeof globalThis == O && globalThis) ||
        check(typeof window == O && window) ||
        check(typeof self == O && self) ||
        check(typeof global == O && global) ||
        Function('return this')();
    },
    '33Wh': function(module, exports, __webpack_require__) {
      var internalObjectKeys = __webpack_require__('yoRg'),
        enumBugKeys = __webpack_require__('eDl+');
      module.exports =
        Object.keys ||
        function(O) {
          return internalObjectKeys(O, enumBugKeys);
        };
    },
    '3N8a': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return AsyncAction_AsyncAction;
      });
      var Subscription = __webpack_require__('quSY');
      class Action_Action extends Subscription.a {
        constructor(scheduler, work) {
          super();
        }
        schedule(state, delay = 0) {
          return this;
        }
      }
      class AsyncAction_AsyncAction extends Action_Action {
        constructor(scheduler, work) {
          super(scheduler, work),
            (this.scheduler = scheduler),
            (this.work = work),
            (this.pending = !1);
        }
        schedule(state, delay = 0) {
          if (this.closed) return this;
          this.state = state;
          const id = this.id,
            scheduler = this.scheduler;
          return (
            null != id && (this.id = this.recycleAsyncId(scheduler, id, delay)),
            (this.pending = !0),
            (this.delay = delay),
            (this.id =
              this.id || this.requestAsyncId(scheduler, this.id, delay)),
            this
          );
        }
        requestAsyncId(scheduler, id, delay = 0) {
          return setInterval(scheduler.flush.bind(scheduler, this), delay);
        }
        recycleAsyncId(scheduler, id, delay = 0) {
          if (null !== delay && this.delay === delay && !1 === this.pending)
            return id;
          clearInterval(id);
        }
        execute(state, delay) {
          if (this.closed) return new Error('executing a cancelled action');
          this.pending = !1;
          const error = this._execute(state, delay);
          if (error) return error;
          !1 === this.pending &&
            null != this.id &&
            (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
        }
        _execute(state, delay) {
          let errored = !1,
            errorValue = void 0;
          try {
            this.work(state);
          } catch (e) {
            (errored = !0), (errorValue = (!!e && e) || new Error(e));
          }
          if (errored) return this.unsubscribe(), errorValue;
        }
        _unsubscribe() {
          const id = this.id,
            scheduler = this.scheduler,
            actions = scheduler.actions,
            index = actions.indexOf(this);
          (this.work = null),
            (this.state = null),
            (this.pending = !1),
            (this.scheduler = null),
            -1 !== index && actions.splice(index, 1),
            null != id && (this.id = this.recycleAsyncId(scheduler, id, null)),
            (this.delay = null);
        }
      }
    },
    '3Pt+': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return forms_FormsModule;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return NG_VALIDATORS;
        }),
        __webpack_require__.d(__webpack_exports__, 'c', function() {
          return NG_VALUE_ACCESSOR;
        }),
        __webpack_require__.d(__webpack_exports__, 'd', function() {
          return forms_NgControlStatusGroup;
        }),
        __webpack_require__.d(__webpack_exports__, 'e', function() {
          return forms_NgForm;
        }),
        __webpack_require__.d(__webpack_exports__, 'f', function() {
          return forms_NgSelectOption;
        }),
        __webpack_require__.d(__webpack_exports__, 'g', function() {
          return forms_NgSelectMultipleOption;
        }),
        __webpack_require__.d(__webpack_exports__, 'h', function() {
          return forms_NgNoValidate;
        });
      var core = __webpack_require__('fXoL'),
        Observable = (__webpack_require__('ofXK'), __webpack_require__('HDdC')),
        isArray = __webpack_require__('DH7j'),
        map = __webpack_require__('lJxs'),
        isObject = __webpack_require__('XoHu'),
        from = __webpack_require__('Cfvw');
      function forkJoinInternal(sources, keys) {
        return new Observable.a(subscriber => {
          const len = sources.length;
          if (0 === len) return void subscriber.complete();
          const values = new Array(len);
          let completed = 0,
            emitted = 0;
          for (let i = 0; i < len; i++) {
            const source = Object(from.a)(sources[i]);
            let hasValue = !1;
            subscriber.add(
              source.subscribe({
                next: value => {
                  hasValue || ((hasValue = !0), emitted++), (values[i] = value);
                },
                error: err => subscriber.error(err),
                complete: () => {
                  completed++,
                    (completed !== len && hasValue) ||
                      (emitted === len &&
                        subscriber.next(
                          keys
                            ? keys.reduce(
                                (result, key, i) => (
                                  (result[key] = values[i]), result
                                ),
                                {}
                              )
                            : values
                        ),
                      subscriber.complete());
                }
              })
            );
          }
        });
      }
      const NG_VALUE_ACCESSOR = new core.q('NgValueAccessor');
      let forms_AbstractControlDirective = (() => {
          class AbstractControlDirective {
            get value() {
              return this.control ? this.control.value : null;
            }
            get valid() {
              return this.control ? this.control.valid : null;
            }
            get invalid() {
              return this.control ? this.control.invalid : null;
            }
            get pending() {
              return this.control ? this.control.pending : null;
            }
            get disabled() {
              return this.control ? this.control.disabled : null;
            }
            get enabled() {
              return this.control ? this.control.enabled : null;
            }
            get errors() {
              return this.control ? this.control.errors : null;
            }
            get pristine() {
              return this.control ? this.control.pristine : null;
            }
            get dirty() {
              return this.control ? this.control.dirty : null;
            }
            get touched() {
              return this.control ? this.control.touched : null;
            }
            get status() {
              return this.control ? this.control.status : null;
            }
            get untouched() {
              return this.control ? this.control.untouched : null;
            }
            get statusChanges() {
              return this.control ? this.control.statusChanges : null;
            }
            get valueChanges() {
              return this.control ? this.control.valueChanges : null;
            }
            get path() {
              return null;
            }
            reset(value) {
              this.control && this.control.reset(value);
            }
            hasError(errorCode, path) {
              return !!this.control && this.control.hasError(errorCode, path);
            }
            getError(errorCode, path) {
              return this.control
                ? this.control.getError(errorCode, path)
                : null;
            }
          }
          return (
            (AbstractControlDirective.ɵfac = function(t) {
              return new (t || AbstractControlDirective)();
            }),
            (AbstractControlDirective.ɵdir = core.Gb({
              type: AbstractControlDirective
            })),
            AbstractControlDirective
          );
        })(),
        forms_ControlContainer = (() => {
          class ControlContainer extends forms_AbstractControlDirective {
            get formDirective() {
              return null;
            }
            get path() {
              return null;
            }
          }
          return (
            (ControlContainer.ɵfac = function(t) {
              return ɵControlContainer_BaseFactory(t || ControlContainer);
            }),
            (ControlContainer.ɵdir = core.Gb({
              type: ControlContainer,
              features: [core.ub]
            })),
            ControlContainer
          );
        })();
      const ɵControlContainer_BaseFactory = core.Sb(forms_ControlContainer);
      let forms_NgControlStatusGroup = (() => {
        class NgControlStatusGroup extends class {
          constructor(cd) {
            this._cd = cd;
          }
          get ngClassUntouched() {
            return !!this._cd.control && this._cd.control.untouched;
          }
          get ngClassTouched() {
            return !!this._cd.control && this._cd.control.touched;
          }
          get ngClassPristine() {
            return !!this._cd.control && this._cd.control.pristine;
          }
          get ngClassDirty() {
            return !!this._cd.control && this._cd.control.dirty;
          }
          get ngClassValid() {
            return !!this._cd.control && this._cd.control.valid;
          }
          get ngClassInvalid() {
            return !!this._cd.control && this._cd.control.invalid;
          }
          get ngClassPending() {
            return !!this._cd.control && this._cd.control.pending;
          }
        } {
          constructor(cd) {
            super(cd);
          }
        }
        return (
          (NgControlStatusGroup.ɵfac = function(t) {
            return new (t || NgControlStatusGroup)(
              core.Lb(forms_ControlContainer, 2)
            );
          }),
          (NgControlStatusGroup.ɵdir = core.Gb({
            type: NgControlStatusGroup,
            selectors: [
              ['', 'formGroupName', ''],
              ['', 'formArrayName', ''],
              ['', 'ngModelGroup', ''],
              ['', 'formGroup', ''],
              ['form', 3, 'ngNoForm', ''],
              ['', 'ngForm', '']
            ],
            hostVars: 14,
            hostBindings: function(rf, ctx) {
              2 & rf &&
                core.Db('ng-untouched', ctx.ngClassUntouched)(
                  'ng-touched',
                  ctx.ngClassTouched
                )('ng-pristine', ctx.ngClassPristine)(
                  'ng-dirty',
                  ctx.ngClassDirty
                )('ng-valid', ctx.ngClassValid)(
                  'ng-invalid',
                  ctx.ngClassInvalid
                )('ng-pending', ctx.ngClassPending);
            },
            features: [core.ub]
          })),
          NgControlStatusGroup
        );
      })();
      function isEmptyInputValue(value) {
        return null == value || 0 === value.length;
      }
      function hasValidLength(value) {
        return null != value && 'number' == typeof value.length;
      }
      const NG_VALIDATORS = new core.q('NgValidators'),
        NG_ASYNC_VALIDATORS = new core.q('NgAsyncValidators'),
        EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
      class forms_Validators {
        static min(min) {
          return control => {
            if (isEmptyInputValue(control.value) || isEmptyInputValue(min))
              return null;
            const value = parseFloat(control.value);
            return !isNaN(value) && value < min
              ? { min: { min: min, actual: control.value } }
              : null;
          };
        }
        static max(max) {
          return control => {
            if (isEmptyInputValue(control.value) || isEmptyInputValue(max))
              return null;
            const value = parseFloat(control.value);
            return !isNaN(value) && value > max
              ? { max: { max: max, actual: control.value } }
              : null;
          };
        }
        static required(control) {
          return isEmptyInputValue(control.value) ? { required: !0 } : null;
        }
        static requiredTrue(control) {
          return !0 === control.value ? null : { required: !0 };
        }
        static email(control) {
          return isEmptyInputValue(control.value) ||
            EMAIL_REGEXP.test(control.value)
            ? null
            : { email: !0 };
        }
        static minLength(minLength) {
          return control =>
            isEmptyInputValue(control.value) || !hasValidLength(control.value)
              ? null
              : control.value.length < minLength
              ? {
                  minlength: {
                    requiredLength: minLength,
                    actualLength: control.value.length
                  }
                }
              : null;
        }
        static maxLength(maxLength) {
          return control =>
            hasValidLength(control.value) && control.value.length > maxLength
              ? {
                  maxlength: {
                    requiredLength: maxLength,
                    actualLength: control.value.length
                  }
                }
              : null;
        }
        static pattern(pattern) {
          if (!pattern) return forms_Validators.nullValidator;
          let regex, regexStr;
          return (
            'string' == typeof pattern
              ? ((regexStr = ''),
                '^' !== pattern.charAt(0) && (regexStr += '^'),
                (regexStr += pattern),
                '$' !== pattern.charAt(pattern.length - 1) && (regexStr += '$'),
                (regex = new RegExp(regexStr)))
              : ((regexStr = pattern.toString()), (regex = pattern)),
            control => {
              if (isEmptyInputValue(control.value)) return null;
              const value = control.value;
              return regex.test(value)
                ? null
                : {
                    pattern: { requiredPattern: regexStr, actualValue: value }
                  };
            }
          );
        }
        static nullValidator(control) {
          return null;
        }
        static compose(validators) {
          if (!validators) return null;
          const presentValidators = validators.filter(isPresent);
          return 0 == presentValidators.length
            ? null
            : function(control) {
                return _mergeErrors(
                  (function(control, validators) {
                    return validators.map(v => v(control));
                  })(control, presentValidators)
                );
              };
        }
        static composeAsync(validators) {
          if (!validators) return null;
          const presentValidators = validators.filter(isPresent);
          return 0 == presentValidators.length
            ? null
            : function(control) {
                return (function(...sources) {
                  if (1 === sources.length) {
                    const first = sources[0];
                    if (Object(isArray.a)(first))
                      return forkJoinInternal(first, null);
                    if (
                      Object(isObject.a)(first) &&
                      Object.getPrototypeOf(first) === Object.prototype
                    ) {
                      const keys = Object.keys(first);
                      return forkJoinInternal(
                        keys.map(key => first[key]),
                        keys
                      );
                    }
                  }
                  if ('function' == typeof sources[sources.length - 1]) {
                    const resultSelector = sources.pop();
                    return forkJoinInternal(
                      (sources =
                        1 === sources.length && Object(isArray.a)(sources[0])
                          ? sources[0]
                          : sources),
                      null
                    ).pipe(Object(map.a)(args => resultSelector(...args)));
                  }
                  return forkJoinInternal(sources, null);
                })(
                  (function(control, validators) {
                    return validators.map(v => v(control));
                  })(control, presentValidators).map(toObservable)
                ).pipe(Object(map.a)(_mergeErrors));
              };
        }
      }
      function isPresent(o) {
        return null != o;
      }
      function toObservable(r) {
        const obs = Object(core.pb)(r) ? Object(from.a)(r) : r;
        if (!Object(core.ob)(obs))
          throw new Error(
            'Expected validator to return Promise or Observable.'
          );
        return obs;
      }
      function _mergeErrors(arrayOfErrors) {
        let res = {};
        return (
          arrayOfErrors.forEach(errors => {
            res =
              null != errors
                ? Object.assign(Object.assign({}, res), errors)
                : res;
          }),
          0 === Object.keys(res).length ? null : res
        );
      }
      function normalizeValidator(validator) {
        return validator.validate ? c => validator.validate(c) : validator;
      }
      function normalizeAsyncValidator(validator) {
        return validator.validate ? c => validator.validate(c) : validator;
      }
      let forms_RadioControlRegistry = (() => {
        class RadioControlRegistry {
          constructor() {
            this._accessors = [];
          }
          add(control, accessor) {
            this._accessors.push([control, accessor]);
          }
          remove(accessor) {
            for (let i = this._accessors.length - 1; i >= 0; --i)
              if (this._accessors[i][1] === accessor)
                return void this._accessors.splice(i, 1);
          }
          select(accessor) {
            this._accessors.forEach(c => {
              this._isSameGroup(c, accessor) &&
                c[1] !== accessor &&
                c[1].fireUncheck(accessor.value);
            });
          }
          _isSameGroup(controlPair, accessor) {
            return (
              !!controlPair[0].control &&
              controlPair[0]._parent === accessor._control._parent &&
              controlPair[1].name === accessor.name
            );
          }
        }
        return (
          (RadioControlRegistry.ɵfac = function(t) {
            return new (t || RadioControlRegistry)();
          }),
          (RadioControlRegistry.ɵprov = core.Hb({
            token: RadioControlRegistry,
            factory: RadioControlRegistry.ɵfac
          })),
          RadioControlRegistry
        );
      })();
      const SELECT_VALUE_ACCESSOR = {
        provide: NG_VALUE_ACCESSOR,
        useExisting: Object(core.S)(() => forms_SelectControlValueAccessor),
        multi: !0
      };
      function _buildValueString(id, value) {
        return null == id
          ? '' + value
          : (value && 'object' == typeof value && (value = 'Object'),
            `${id}: ${value}`.slice(0, 50));
      }
      let forms_SelectControlValueAccessor = (() => {
          class SelectControlValueAccessor {
            constructor(_renderer, _elementRef) {
              (this._renderer = _renderer),
                (this._elementRef = _elementRef),
                (this._optionMap = new Map()),
                (this._idCounter = 0),
                (this.onChange = _ => {}),
                (this.onTouched = () => {}),
                (this._compareWith = Object.is);
            }
            set compareWith(fn) {
              if ('function' != typeof fn)
                throw new Error(
                  'compareWith must be a function, but received ' +
                    JSON.stringify(fn)
                );
              this._compareWith = fn;
            }
            writeValue(value) {
              this.value = value;
              const id = this._getOptionId(value);
              null == id &&
                this._renderer.setProperty(
                  this._elementRef.nativeElement,
                  'selectedIndex',
                  -1
                );
              const valueString = _buildValueString(id, value);
              this._renderer.setProperty(
                this._elementRef.nativeElement,
                'value',
                valueString
              );
            }
            registerOnChange(fn) {
              this.onChange = valueString => {
                (this.value = this._getOptionValue(valueString)),
                  fn(this.value);
              };
            }
            registerOnTouched(fn) {
              this.onTouched = fn;
            }
            setDisabledState(isDisabled) {
              this._renderer.setProperty(
                this._elementRef.nativeElement,
                'disabled',
                isDisabled
              );
            }
            _registerOption() {
              return (this._idCounter++).toString();
            }
            _getOptionId(value) {
              for (const id of Array.from(this._optionMap.keys()))
                if (this._compareWith(this._optionMap.get(id), value))
                  return id;
              return null;
            }
            _getOptionValue(valueString) {
              const id = (function(valueString) {
                return valueString.split(':')[0];
              })(valueString);
              return this._optionMap.has(id)
                ? this._optionMap.get(id)
                : valueString;
            }
          }
          return (
            (SelectControlValueAccessor.ɵfac = function(t) {
              return new (t || SelectControlValueAccessor)(
                core.Lb(core.D),
                core.Lb(core.l)
              );
            }),
            (SelectControlValueAccessor.ɵdir = core.Gb({
              type: SelectControlValueAccessor,
              selectors: [
                ['select', 'formControlName', '', 3, 'multiple', ''],
                ['select', 'formControl', '', 3, 'multiple', ''],
                ['select', 'ngModel', '', 3, 'multiple', '']
              ],
              hostBindings: function(rf, ctx) {
                1 & rf &&
                  core.bc('change', function($event) {
                    return ctx.onChange($event.target.value);
                  })('blur', function() {
                    return ctx.onTouched();
                  });
              },
              inputs: { compareWith: 'compareWith' },
              features: [core.wb([SELECT_VALUE_ACCESSOR])]
            })),
            SelectControlValueAccessor
          );
        })(),
        forms_NgSelectOption = (() => {
          class NgSelectOption {
            constructor(_element, _renderer, _select) {
              (this._element = _element),
                (this._renderer = _renderer),
                (this._select = _select),
                this._select && (this.id = this._select._registerOption());
            }
            set ngValue(value) {
              null != this._select &&
                (this._select._optionMap.set(this.id, value),
                this._setElementValue(_buildValueString(this.id, value)),
                this._select.writeValue(this._select.value));
            }
            set value(value) {
              this._setElementValue(value),
                this._select && this._select.writeValue(this._select.value);
            }
            _setElementValue(value) {
              this._renderer.setProperty(
                this._element.nativeElement,
                'value',
                value
              );
            }
            ngOnDestroy() {
              this._select &&
                (this._select._optionMap.delete(this.id),
                this._select.writeValue(this._select.value));
            }
          }
          return (
            (NgSelectOption.ɵfac = function(t) {
              return new (t || NgSelectOption)(
                core.Lb(core.l),
                core.Lb(core.D),
                core.Lb(forms_SelectControlValueAccessor, 9)
              );
            }),
            (NgSelectOption.ɵdir = core.Gb({
              type: NgSelectOption,
              selectors: [['option']],
              inputs: { ngValue: 'ngValue', value: 'value' }
            })),
            NgSelectOption
          );
        })();
      const SELECT_MULTIPLE_VALUE_ACCESSOR = {
        provide: NG_VALUE_ACCESSOR,
        useExisting: Object(core.S)(
          () => forms_SelectMultipleControlValueAccessor
        ),
        multi: !0
      };
      function _buildValueString$1(id, value) {
        return null == id
          ? '' + value
          : ('string' == typeof value && (value = `'${value}'`),
            value && 'object' == typeof value && (value = 'Object'),
            `${id}: ${value}`.slice(0, 50));
      }
      let forms_SelectMultipleControlValueAccessor = (() => {
          class SelectMultipleControlValueAccessor {
            constructor(_renderer, _elementRef) {
              (this._renderer = _renderer),
                (this._elementRef = _elementRef),
                (this._optionMap = new Map()),
                (this._idCounter = 0),
                (this.onChange = _ => {}),
                (this.onTouched = () => {}),
                (this._compareWith = Object.is);
            }
            set compareWith(fn) {
              if ('function' != typeof fn)
                throw new Error(
                  'compareWith must be a function, but received ' +
                    JSON.stringify(fn)
                );
              this._compareWith = fn;
            }
            writeValue(value) {
              let optionSelectedStateSetter;
              if (((this.value = value), Array.isArray(value))) {
                const ids = value.map(v => this._getOptionId(v));
                optionSelectedStateSetter = (opt, o) => {
                  opt._setSelected(ids.indexOf(o.toString()) > -1);
                };
              } else
                optionSelectedStateSetter = (opt, o) => {
                  opt._setSelected(!1);
                };
              this._optionMap.forEach(optionSelectedStateSetter);
            }
            registerOnChange(fn) {
              this.onChange = _ => {
                const selected = [];
                if (void 0 !== _.selectedOptions) {
                  const options = _.selectedOptions;
                  for (let i = 0; i < options.length; i++) {
                    const opt = options.item(i),
                      val = this._getOptionValue(opt.value);
                    selected.push(val);
                  }
                } else {
                  const options = _.options;
                  for (let i = 0; i < options.length; i++) {
                    const opt = options.item(i);
                    if (opt.selected) {
                      const val = this._getOptionValue(opt.value);
                      selected.push(val);
                    }
                  }
                }
                (this.value = selected), fn(selected);
              };
            }
            registerOnTouched(fn) {
              this.onTouched = fn;
            }
            setDisabledState(isDisabled) {
              this._renderer.setProperty(
                this._elementRef.nativeElement,
                'disabled',
                isDisabled
              );
            }
            _registerOption(value) {
              const id = (this._idCounter++).toString();
              return this._optionMap.set(id, value), id;
            }
            _getOptionId(value) {
              for (const id of Array.from(this._optionMap.keys()))
                if (this._compareWith(this._optionMap.get(id)._value, value))
                  return id;
              return null;
            }
            _getOptionValue(valueString) {
              const id = (function(valueString) {
                return valueString.split(':')[0];
              })(valueString);
              return this._optionMap.has(id)
                ? this._optionMap.get(id)._value
                : valueString;
            }
          }
          return (
            (SelectMultipleControlValueAccessor.ɵfac = function(t) {
              return new (t || SelectMultipleControlValueAccessor)(
                core.Lb(core.D),
                core.Lb(core.l)
              );
            }),
            (SelectMultipleControlValueAccessor.ɵdir = core.Gb({
              type: SelectMultipleControlValueAccessor,
              selectors: [
                ['select', 'multiple', '', 'formControlName', ''],
                ['select', 'multiple', '', 'formControl', ''],
                ['select', 'multiple', '', 'ngModel', '']
              ],
              hostBindings: function(rf, ctx) {
                1 & rf &&
                  core.bc('change', function($event) {
                    return ctx.onChange($event.target);
                  })('blur', function() {
                    return ctx.onTouched();
                  });
              },
              inputs: { compareWith: 'compareWith' },
              features: [core.wb([SELECT_MULTIPLE_VALUE_ACCESSOR])]
            })),
            SelectMultipleControlValueAccessor
          );
        })(),
        forms_NgSelectMultipleOption = (() => {
          class ɵNgSelectMultipleOption {
            constructor(_element, _renderer, _select) {
              (this._element = _element),
                (this._renderer = _renderer),
                (this._select = _select),
                this._select && (this.id = this._select._registerOption(this));
            }
            set ngValue(value) {
              null != this._select &&
                ((this._value = value),
                this._setElementValue(_buildValueString$1(this.id, value)),
                this._select.writeValue(this._select.value));
            }
            set value(value) {
              this._select
                ? ((this._value = value),
                  this._setElementValue(_buildValueString$1(this.id, value)),
                  this._select.writeValue(this._select.value))
                : this._setElementValue(value);
            }
            _setElementValue(value) {
              this._renderer.setProperty(
                this._element.nativeElement,
                'value',
                value
              );
            }
            _setSelected(selected) {
              this._renderer.setProperty(
                this._element.nativeElement,
                'selected',
                selected
              );
            }
            ngOnDestroy() {
              this._select &&
                (this._select._optionMap.delete(this.id),
                this._select.writeValue(this._select.value));
            }
          }
          return (
            (ɵNgSelectMultipleOption.ɵfac = function(t) {
              return new (t || ɵNgSelectMultipleOption)(
                core.Lb(core.l),
                core.Lb(core.D),
                core.Lb(forms_SelectMultipleControlValueAccessor, 9)
              );
            }),
            (ɵNgSelectMultipleOption.ɵdir = core.Gb({
              type: ɵNgSelectMultipleOption,
              selectors: [['option']],
              inputs: { ngValue: 'ngValue', value: 'value' }
            })),
            ɵNgSelectMultipleOption
          );
        })();
      function updateControl(control, dir) {
        control._pendingDirty && control.markAsDirty(),
          control.setValue(control._pendingValue, {
            emitModelToViewChange: !1
          }),
          dir.viewToModelUpdate(control._pendingValue),
          (control._pendingChange = !1);
      }
      function _throwError(dir, message) {
        let messageEnd;
        throw ((messageEnd =
          dir.path.length > 1
            ? `path: '${dir.path.join(' -> ')}'`
            : dir.path[0]
            ? `name: '${dir.path}'`
            : 'unspecified name attribute'),
        new Error(`${message} ${messageEnd}`));
      }
      function composeValidators(validators) {
        return null != validators
          ? forms_Validators.compose(validators.map(normalizeValidator))
          : null;
      }
      function composeAsyncValidators(validators) {
        return null != validators
          ? forms_Validators.composeAsync(
              validators.map(normalizeAsyncValidator)
            )
          : null;
      }
      function coerceToValidator(validatorOrOpts) {
        const validator = isOptionsObj(validatorOrOpts)
          ? validatorOrOpts.validators
          : validatorOrOpts;
        return Array.isArray(validator)
          ? composeValidators(validator)
          : validator || null;
      }
      function coerceToAsyncValidator(asyncValidator, validatorOrOpts) {
        const origAsyncValidator = isOptionsObj(validatorOrOpts)
          ? validatorOrOpts.asyncValidators
          : asyncValidator;
        return Array.isArray(origAsyncValidator)
          ? composeAsyncValidators(origAsyncValidator)
          : origAsyncValidator || null;
      }
      function isOptionsObj(validatorOrOpts) {
        return (
          null != validatorOrOpts &&
          !Array.isArray(validatorOrOpts) &&
          'object' == typeof validatorOrOpts
        );
      }
      class forms_AbstractControl {
        constructor(validator, asyncValidator) {
          (this.validator = validator),
            (this.asyncValidator = asyncValidator),
            (this._onCollectionChange = () => {}),
            (this.pristine = !0),
            (this.touched = !1),
            (this._onDisabledChange = []);
        }
        get parent() {
          return this._parent;
        }
        get valid() {
          return 'VALID' === this.status;
        }
        get invalid() {
          return 'INVALID' === this.status;
        }
        get pending() {
          return 'PENDING' == this.status;
        }
        get disabled() {
          return 'DISABLED' === this.status;
        }
        get enabled() {
          return 'DISABLED' !== this.status;
        }
        get dirty() {
          return !this.pristine;
        }
        get untouched() {
          return !this.touched;
        }
        get updateOn() {
          return this._updateOn
            ? this._updateOn
            : this.parent
            ? this.parent.updateOn
            : 'change';
        }
        setValidators(newValidator) {
          this.validator = coerceToValidator(newValidator);
        }
        setAsyncValidators(newValidator) {
          this.asyncValidator = coerceToAsyncValidator(newValidator);
        }
        clearValidators() {
          this.validator = null;
        }
        clearAsyncValidators() {
          this.asyncValidator = null;
        }
        markAsTouched(opts = {}) {
          (this.touched = !0),
            this._parent && !opts.onlySelf && this._parent.markAsTouched(opts);
        }
        markAllAsTouched() {
          this.markAsTouched({ onlySelf: !0 }),
            this._forEachChild(control => control.markAllAsTouched());
        }
        markAsUntouched(opts = {}) {
          (this.touched = !1),
            (this._pendingTouched = !1),
            this._forEachChild(control => {
              control.markAsUntouched({ onlySelf: !0 });
            }),
            this._parent && !opts.onlySelf && this._parent._updateTouched(opts);
        }
        markAsDirty(opts = {}) {
          (this.pristine = !1),
            this._parent && !opts.onlySelf && this._parent.markAsDirty(opts);
        }
        markAsPristine(opts = {}) {
          (this.pristine = !0),
            (this._pendingDirty = !1),
            this._forEachChild(control => {
              control.markAsPristine({ onlySelf: !0 });
            }),
            this._parent &&
              !opts.onlySelf &&
              this._parent._updatePristine(opts);
        }
        markAsPending(opts = {}) {
          (this.status = 'PENDING'),
            !1 !== opts.emitEvent && this.statusChanges.emit(this.status),
            this._parent && !opts.onlySelf && this._parent.markAsPending(opts);
        }
        disable(opts = {}) {
          const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
          (this.status = 'DISABLED'),
            (this.errors = null),
            this._forEachChild(control => {
              control.disable(
                Object.assign(Object.assign({}, opts), { onlySelf: !0 })
              );
            }),
            this._updateValue(),
            !1 !== opts.emitEvent &&
              (this.valueChanges.emit(this.value),
              this.statusChanges.emit(this.status)),
            this._updateAncestors(
              Object.assign(Object.assign({}, opts), {
                skipPristineCheck: skipPristineCheck
              })
            ),
            this._onDisabledChange.forEach(changeFn => changeFn(!0));
        }
        enable(opts = {}) {
          const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
          (this.status = 'VALID'),
            this._forEachChild(control => {
              control.enable(
                Object.assign(Object.assign({}, opts), { onlySelf: !0 })
              );
            }),
            this.updateValueAndValidity({
              onlySelf: !0,
              emitEvent: opts.emitEvent
            }),
            this._updateAncestors(
              Object.assign(Object.assign({}, opts), {
                skipPristineCheck: skipPristineCheck
              })
            ),
            this._onDisabledChange.forEach(changeFn => changeFn(!1));
        }
        _updateAncestors(opts) {
          this._parent &&
            !opts.onlySelf &&
            (this._parent.updateValueAndValidity(opts),
            opts.skipPristineCheck || this._parent._updatePristine(),
            this._parent._updateTouched());
        }
        setParent(parent) {
          this._parent = parent;
        }
        updateValueAndValidity(opts = {}) {
          this._setInitialStatus(),
            this._updateValue(),
            this.enabled &&
              (this._cancelExistingSubscription(),
              (this.errors = this._runValidator()),
              (this.status = this._calculateStatus()),
              ('VALID' !== this.status && 'PENDING' !== this.status) ||
                this._runAsyncValidator(opts.emitEvent)),
            !1 !== opts.emitEvent &&
              (this.valueChanges.emit(this.value),
              this.statusChanges.emit(this.status)),
            this._parent &&
              !opts.onlySelf &&
              this._parent.updateValueAndValidity(opts);
        }
        _updateTreeValidity(opts = { emitEvent: !0 }) {
          this._forEachChild(ctrl => ctrl._updateTreeValidity(opts)),
            this.updateValueAndValidity({
              onlySelf: !0,
              emitEvent: opts.emitEvent
            });
        }
        _setInitialStatus() {
          this.status = this._allControlsDisabled() ? 'DISABLED' : 'VALID';
        }
        _runValidator() {
          return this.validator ? this.validator(this) : null;
        }
        _runAsyncValidator(emitEvent) {
          if (this.asyncValidator) {
            this.status = 'PENDING';
            const obs = toObservable(this.asyncValidator(this));
            this._asyncValidationSubscription = obs.subscribe(errors =>
              this.setErrors(errors, { emitEvent: emitEvent })
            );
          }
        }
        _cancelExistingSubscription() {
          this._asyncValidationSubscription &&
            this._asyncValidationSubscription.unsubscribe();
        }
        setErrors(errors, opts = {}) {
          (this.errors = errors),
            this._updateControlsErrors(!1 !== opts.emitEvent);
        }
        get(path) {
          return (function(control, path, delimiter) {
            if (null == path) return null;
            if (
              (Array.isArray(path) || (path = path.split('.')),
              Array.isArray(path) && 0 === path.length)
            )
              return null;
            let controlToFind = control;
            return (
              path.forEach(name => {
                controlToFind =
                  controlToFind instanceof FormGroup
                    ? controlToFind.controls.hasOwnProperty(name)
                      ? controlToFind.controls[name]
                      : null
                    : (controlToFind instanceof FormArray &&
                        controlToFind.at(name)) ||
                      null;
              }),
              controlToFind
            );
          })(this, path);
        }
        getError(errorCode, path) {
          const control = path ? this.get(path) : this;
          return control && control.errors ? control.errors[errorCode] : null;
        }
        hasError(errorCode, path) {
          return !!this.getError(errorCode, path);
        }
        get root() {
          let x = this;
          for (; x._parent; ) x = x._parent;
          return x;
        }
        _updateControlsErrors(emitEvent) {
          (this.status = this._calculateStatus()),
            emitEvent && this.statusChanges.emit(this.status),
            this._parent && this._parent._updateControlsErrors(emitEvent);
        }
        _initObservables() {
          (this.valueChanges = new core.n()),
            (this.statusChanges = new core.n());
        }
        _calculateStatus() {
          return this._allControlsDisabled()
            ? 'DISABLED'
            : this.errors
            ? 'INVALID'
            : this._anyControlsHaveStatus('PENDING')
            ? 'PENDING'
            : this._anyControlsHaveStatus('INVALID')
            ? 'INVALID'
            : 'VALID';
        }
        _anyControlsHaveStatus(status) {
          return this._anyControls(control => control.status === status);
        }
        _anyControlsDirty() {
          return this._anyControls(control => control.dirty);
        }
        _anyControlsTouched() {
          return this._anyControls(control => control.touched);
        }
        _updatePristine(opts = {}) {
          (this.pristine = !this._anyControlsDirty()),
            this._parent &&
              !opts.onlySelf &&
              this._parent._updatePristine(opts);
        }
        _updateTouched(opts = {}) {
          (this.touched = this._anyControlsTouched()),
            this._parent && !opts.onlySelf && this._parent._updateTouched(opts);
        }
        _isBoxedValue(formState) {
          return (
            'object' == typeof formState &&
            null !== formState &&
            2 === Object.keys(formState).length &&
            'value' in formState &&
            'disabled' in formState
          );
        }
        _registerOnCollectionChange(fn) {
          this._onCollectionChange = fn;
        }
        _setUpdateStrategy(opts) {
          isOptionsObj(opts) &&
            null != opts.updateOn &&
            (this._updateOn = opts.updateOn);
        }
        _parentMarkedDirty(onlySelf) {
          return (
            !onlySelf &&
            this._parent &&
            this._parent.dirty &&
            !this._parent._anyControlsDirty()
          );
        }
      }
      class FormControl extends forms_AbstractControl {
        constructor(formState = null, validatorOrOpts, asyncValidator) {
          super(
            coerceToValidator(validatorOrOpts),
            coerceToAsyncValidator(asyncValidator, validatorOrOpts)
          ),
            (this._onChange = []),
            this._applyFormState(formState),
            this._setUpdateStrategy(validatorOrOpts),
            this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }),
            this._initObservables();
        }
        setValue(value, options = {}) {
          (this.value = this._pendingValue = value),
            this._onChange.length &&
              !1 !== options.emitModelToViewChange &&
              this._onChange.forEach(changeFn =>
                changeFn(this.value, !1 !== options.emitViewToModelChange)
              ),
            this.updateValueAndValidity(options);
        }
        patchValue(value, options = {}) {
          this.setValue(value, options);
        }
        reset(formState = null, options = {}) {
          this._applyFormState(formState),
            this.markAsPristine(options),
            this.markAsUntouched(options),
            this.setValue(this.value, options),
            (this._pendingChange = !1);
        }
        _updateValue() {}
        _anyControls(condition) {
          return !1;
        }
        _allControlsDisabled() {
          return this.disabled;
        }
        registerOnChange(fn) {
          this._onChange.push(fn);
        }
        _clearChangeFns() {
          (this._onChange = []),
            (this._onDisabledChange = []),
            (this._onCollectionChange = () => {});
        }
        registerOnDisabledChange(fn) {
          this._onDisabledChange.push(fn);
        }
        _forEachChild(cb) {}
        _syncPendingControls() {
          return !(
            'submit' !== this.updateOn ||
            (this._pendingDirty && this.markAsDirty(),
            this._pendingTouched && this.markAsTouched(),
            !this._pendingChange) ||
            (this.setValue(this._pendingValue, {
              onlySelf: !0,
              emitModelToViewChange: !1
            }),
            0)
          );
        }
        _applyFormState(formState) {
          this._isBoxedValue(formState)
            ? ((this.value = this._pendingValue = formState.value),
              formState.disabled
                ? this.disable({ onlySelf: !0, emitEvent: !1 })
                : this.enable({ onlySelf: !0, emitEvent: !1 }))
            : (this.value = this._pendingValue = formState);
        }
      }
      class FormGroup extends forms_AbstractControl {
        constructor(controls, validatorOrOpts, asyncValidator) {
          super(
            coerceToValidator(validatorOrOpts),
            coerceToAsyncValidator(asyncValidator, validatorOrOpts)
          ),
            (this.controls = controls),
            this._initObservables(),
            this._setUpdateStrategy(validatorOrOpts),
            this._setUpControls(),
            this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 });
        }
        registerControl(name, control) {
          return this.controls[name]
            ? this.controls[name]
            : ((this.controls[name] = control),
              control.setParent(this),
              control._registerOnCollectionChange(this._onCollectionChange),
              control);
        }
        addControl(name, control) {
          this.registerControl(name, control),
            this.updateValueAndValidity(),
            this._onCollectionChange();
        }
        removeControl(name) {
          this.controls[name] &&
            this.controls[name]._registerOnCollectionChange(() => {}),
            delete this.controls[name],
            this.updateValueAndValidity(),
            this._onCollectionChange();
        }
        setControl(name, control) {
          this.controls[name] &&
            this.controls[name]._registerOnCollectionChange(() => {}),
            delete this.controls[name],
            control && this.registerControl(name, control),
            this.updateValueAndValidity(),
            this._onCollectionChange();
        }
        contains(controlName) {
          return (
            this.controls.hasOwnProperty(controlName) &&
            this.controls[controlName].enabled
          );
        }
        setValue(value, options = {}) {
          this._checkAllValuesPresent(value),
            Object.keys(value).forEach(name => {
              this._throwIfControlMissing(name),
                this.controls[name].setValue(value[name], {
                  onlySelf: !0,
                  emitEvent: options.emitEvent
                });
            }),
            this.updateValueAndValidity(options);
        }
        patchValue(value, options = {}) {
          Object.keys(value).forEach(name => {
            this.controls[name] &&
              this.controls[name].patchValue(value[name], {
                onlySelf: !0,
                emitEvent: options.emitEvent
              });
          }),
            this.updateValueAndValidity(options);
        }
        reset(value = {}, options = {}) {
          this._forEachChild((control, name) => {
            control.reset(value[name], {
              onlySelf: !0,
              emitEvent: options.emitEvent
            });
          }),
            this._updatePristine(options),
            this._updateTouched(options),
            this.updateValueAndValidity(options);
        }
        getRawValue() {
          return this._reduceChildren(
            {},
            (acc, control, name) => (
              (acc[name] =
                control instanceof FormControl
                  ? control.value
                  : control.getRawValue()),
              acc
            )
          );
        }
        _syncPendingControls() {
          let subtreeUpdated = this._reduceChildren(
            !1,
            (updated, child) => !!child._syncPendingControls() || updated
          );
          return (
            subtreeUpdated && this.updateValueAndValidity({ onlySelf: !0 }),
            subtreeUpdated
          );
        }
        _throwIfControlMissing(name) {
          if (!Object.keys(this.controls).length)
            throw new Error(
              "\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "
            );
          if (!this.controls[name])
            throw new Error(`Cannot find form control with name: ${name}.`);
        }
        _forEachChild(cb) {
          Object.keys(this.controls).forEach(k => cb(this.controls[k], k));
        }
        _setUpControls() {
          this._forEachChild(control => {
            control.setParent(this),
              control._registerOnCollectionChange(this._onCollectionChange);
          });
        }
        _updateValue() {
          this.value = this._reduceValue();
        }
        _anyControls(condition) {
          for (const controlName of Object.keys(this.controls)) {
            const control = this.controls[controlName];
            if (this.contains(controlName) && condition(control)) return !0;
          }
          return !1;
        }
        _reduceValue() {
          return this._reduceChildren(
            {},
            (acc, control, name) => (
              (control.enabled || this.disabled) && (acc[name] = control.value),
              acc
            )
          );
        }
        _reduceChildren(initValue, fn) {
          let res = initValue;
          return (
            this._forEachChild((control, name) => {
              res = fn(res, control, name);
            }),
            res
          );
        }
        _allControlsDisabled() {
          for (const controlName of Object.keys(this.controls))
            if (this.controls[controlName].enabled) return !1;
          return Object.keys(this.controls).length > 0 || this.disabled;
        }
        _checkAllValuesPresent(value) {
          this._forEachChild((control, name) => {
            if (void 0 === value[name])
              throw new Error(
                `Must supply a value for form control with name: '${name}'.`
              );
          });
        }
      }
      class FormArray extends forms_AbstractControl {
        constructor(controls, validatorOrOpts, asyncValidator) {
          super(
            coerceToValidator(validatorOrOpts),
            coerceToAsyncValidator(asyncValidator, validatorOrOpts)
          ),
            (this.controls = controls),
            this._initObservables(),
            this._setUpdateStrategy(validatorOrOpts),
            this._setUpControls(),
            this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 });
        }
        at(index) {
          return this.controls[index];
        }
        push(control) {
          this.controls.push(control),
            this._registerControl(control),
            this.updateValueAndValidity(),
            this._onCollectionChange();
        }
        insert(index, control) {
          this.controls.splice(index, 0, control),
            this._registerControl(control),
            this.updateValueAndValidity();
        }
        removeAt(index) {
          this.controls[index] &&
            this.controls[index]._registerOnCollectionChange(() => {}),
            this.controls.splice(index, 1),
            this.updateValueAndValidity();
        }
        setControl(index, control) {
          this.controls[index] &&
            this.controls[index]._registerOnCollectionChange(() => {}),
            this.controls.splice(index, 1),
            control &&
              (this.controls.splice(index, 0, control),
              this._registerControl(control)),
            this.updateValueAndValidity(),
            this._onCollectionChange();
        }
        get length() {
          return this.controls.length;
        }
        setValue(value, options = {}) {
          this._checkAllValuesPresent(value),
            value.forEach((newValue, index) => {
              this._throwIfControlMissing(index),
                this.at(index).setValue(newValue, {
                  onlySelf: !0,
                  emitEvent: options.emitEvent
                });
            }),
            this.updateValueAndValidity(options);
        }
        patchValue(value, options = {}) {
          value.forEach((newValue, index) => {
            this.at(index) &&
              this.at(index).patchValue(newValue, {
                onlySelf: !0,
                emitEvent: options.emitEvent
              });
          }),
            this.updateValueAndValidity(options);
        }
        reset(value = [], options = {}) {
          this._forEachChild((control, index) => {
            control.reset(value[index], {
              onlySelf: !0,
              emitEvent: options.emitEvent
            });
          }),
            this._updatePristine(options),
            this._updateTouched(options),
            this.updateValueAndValidity(options);
        }
        getRawValue() {
          return this.controls.map(control =>
            control instanceof FormControl
              ? control.value
              : control.getRawValue()
          );
        }
        clear() {
          this.controls.length < 1 ||
            (this._forEachChild(control =>
              control._registerOnCollectionChange(() => {})
            ),
            this.controls.splice(0),
            this.updateValueAndValidity());
        }
        _syncPendingControls() {
          let subtreeUpdated = this.controls.reduce(
            (updated, child) => !!child._syncPendingControls() || updated,
            !1
          );
          return (
            subtreeUpdated && this.updateValueAndValidity({ onlySelf: !0 }),
            subtreeUpdated
          );
        }
        _throwIfControlMissing(index) {
          if (!this.controls.length)
            throw new Error(
              "\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "
            );
          if (!this.at(index))
            throw new Error('Cannot find form control at index ' + index);
        }
        _forEachChild(cb) {
          this.controls.forEach((control, index) => {
            cb(control, index);
          });
        }
        _updateValue() {
          this.value = this.controls
            .filter(control => control.enabled || this.disabled)
            .map(control => control.value);
        }
        _anyControls(condition) {
          return this.controls.some(
            control => control.enabled && condition(control)
          );
        }
        _setUpControls() {
          this._forEachChild(control => this._registerControl(control));
        }
        _checkAllValuesPresent(value) {
          this._forEachChild((control, i) => {
            if (void 0 === value[i])
              throw new Error(
                `Must supply a value for form control at index: ${i}.`
              );
          });
        }
        _allControlsDisabled() {
          for (const control of this.controls) if (control.enabled) return !1;
          return this.controls.length > 0 || this.disabled;
        }
        _registerControl(control) {
          control.setParent(this),
            control._registerOnCollectionChange(this._onCollectionChange);
        }
      }
      const formDirectiveProvider = {
          provide: forms_ControlContainer,
          useExisting: Object(core.S)(() => forms_NgForm)
        },
        resolvedPromise = (() => Promise.resolve(null))();
      let forms_NgForm = (() => {
          class NgForm extends forms_ControlContainer {
            constructor(validators, asyncValidators) {
              super(),
                (this.submitted = !1),
                (this._directives = []),
                (this.ngSubmit = new core.n()),
                (this.form = new FormGroup(
                  {},
                  composeValidators(validators),
                  composeAsyncValidators(asyncValidators)
                ));
            }
            ngAfterViewInit() {
              this._setUpdateStrategy();
            }
            get formDirective() {
              return this;
            }
            get control() {
              return this.form;
            }
            get path() {
              return [];
            }
            get controls() {
              return this.form.controls;
            }
            addControl(dir) {
              resolvedPromise.then(() => {
                const container = this._findContainer(dir.path);
                (dir.control = container.registerControl(
                  dir.name,
                  dir.control
                )),
                  (function(control, dir) {
                    control || _throwError(dir, 'Cannot find control with'),
                      dir.valueAccessor ||
                        _throwError(
                          dir,
                          'No value accessor for form control with'
                        ),
                      (control.validator = forms_Validators.compose([
                        control.validator,
                        dir.validator
                      ])),
                      (control.asyncValidator = forms_Validators.composeAsync([
                        control.asyncValidator,
                        dir.asyncValidator
                      ])),
                      dir.valueAccessor.writeValue(control.value),
                      (function(control, dir) {
                        dir.valueAccessor.registerOnChange(newValue => {
                          (control._pendingValue = newValue),
                            (control._pendingChange = !0),
                            (control._pendingDirty = !0),
                            'change' === control.updateOn &&
                              updateControl(control, dir);
                        });
                      })(control, dir),
                      (function(control, dir) {
                        control.registerOnChange((newValue, emitModelEvent) => {
                          dir.valueAccessor.writeValue(newValue),
                            emitModelEvent && dir.viewToModelUpdate(newValue);
                        });
                      })(control, dir),
                      (function(control, dir) {
                        dir.valueAccessor.registerOnTouched(() => {
                          (control._pendingTouched = !0),
                            'blur' === control.updateOn &&
                              control._pendingChange &&
                              updateControl(control, dir),
                            'submit' !== control.updateOn &&
                              control.markAsTouched();
                        });
                      })(control, dir),
                      dir.valueAccessor.setDisabledState &&
                        control.registerOnDisabledChange(isDisabled => {
                          dir.valueAccessor.setDisabledState(isDisabled);
                        }),
                      dir._rawValidators.forEach(validator => {
                        validator.registerOnValidatorChange &&
                          validator.registerOnValidatorChange(() =>
                            control.updateValueAndValidity()
                          );
                      }),
                      dir._rawAsyncValidators.forEach(validator => {
                        validator.registerOnValidatorChange &&
                          validator.registerOnValidatorChange(() =>
                            control.updateValueAndValidity()
                          );
                      });
                  })(dir.control, dir),
                  dir.control.updateValueAndValidity({ emitEvent: !1 }),
                  this._directives.push(dir);
              });
            }
            getControl(dir) {
              return this.form.get(dir.path);
            }
            removeControl(dir) {
              resolvedPromise.then(() => {
                const container = this._findContainer(dir.path);
                container && container.removeControl(dir.name),
                  (function(list, el) {
                    const index = list.indexOf(el);
                    index > -1 && list.splice(index, 1);
                  })(this._directives, dir);
              });
            }
            addFormGroup(dir) {
              resolvedPromise.then(() => {
                const container = this._findContainer(dir.path),
                  group = new FormGroup({});
                (function(control, dir) {
                  null == control &&
                    _throwError(dir, 'Cannot find control with'),
                    (control.validator = forms_Validators.compose([
                      control.validator,
                      dir.validator
                    ])),
                    (control.asyncValidator = forms_Validators.composeAsync([
                      control.asyncValidator,
                      dir.asyncValidator
                    ]));
                })(group, dir),
                  container.registerControl(dir.name, group),
                  group.updateValueAndValidity({ emitEvent: !1 });
              });
            }
            removeFormGroup(dir) {
              resolvedPromise.then(() => {
                const container = this._findContainer(dir.path);
                container && container.removeControl(dir.name);
              });
            }
            getFormGroup(dir) {
              return this.form.get(dir.path);
            }
            updateModel(dir, value) {
              resolvedPromise.then(() => {
                this.form.get(dir.path).setValue(value);
              });
            }
            setValue(value) {
              this.control.setValue(value);
            }
            onSubmit($event) {
              return (
                (this.submitted = !0),
                (directives = this._directives),
                this.form._syncPendingControls(),
                directives.forEach(dir => {
                  const control = dir.control;
                  'submit' === control.updateOn &&
                    control._pendingChange &&
                    (dir.viewToModelUpdate(control._pendingValue),
                    (control._pendingChange = !1));
                }),
                this.ngSubmit.emit($event),
                !1
              );
              var directives;
            }
            onReset() {
              this.resetForm();
            }
            resetForm(value) {
              this.form.reset(value), (this.submitted = !1);
            }
            _setUpdateStrategy() {
              this.options &&
                null != this.options.updateOn &&
                (this.form._updateOn = this.options.updateOn);
            }
            _findContainer(path) {
              return path.pop(), path.length ? this.form.get(path) : this.form;
            }
          }
          return (
            (NgForm.ɵfac = function(t) {
              return new (t || NgForm)(
                core.Lb(NG_VALIDATORS, 10),
                core.Lb(NG_ASYNC_VALIDATORS, 10)
              );
            }),
            (NgForm.ɵdir = core.Gb({
              type: NgForm,
              selectors: [
                ['form', 3, 'ngNoForm', '', 3, 'formGroup', ''],
                ['ng-form'],
                ['', 'ngForm', '']
              ],
              hostBindings: function(rf, ctx) {
                1 & rf &&
                  core.bc('submit', function($event) {
                    return ctx.onSubmit($event);
                  })('reset', function() {
                    return ctx.onReset();
                  });
              },
              inputs: { options: ['ngFormOptions', 'options'] },
              outputs: { ngSubmit: 'ngSubmit' },
              exportAs: ['ngForm'],
              features: [core.wb([formDirectiveProvider]), core.ub]
            })),
            NgForm
          );
        })(),
        forms_NgNoValidate = (() => {
          class ɵNgNoValidate {}
          return (
            (ɵNgNoValidate.ɵfac = function(t) {
              return new (t || ɵNgNoValidate)();
            }),
            (ɵNgNoValidate.ɵdir = core.Gb({
              type: ɵNgNoValidate,
              selectors: [
                ['form', 3, 'ngNoForm', '', 3, 'ngNativeValidate', '']
              ],
              hostAttrs: ['novalidate', '']
            })),
            ɵNgNoValidate
          );
        })(),
        forms_InternalFormsSharedModule = (() => {
          class ɵInternalFormsSharedModule {}
          return (
            (ɵInternalFormsSharedModule.ɵmod = core.Jb({
              type: ɵInternalFormsSharedModule
            })),
            (ɵInternalFormsSharedModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || ɵInternalFormsSharedModule)();
              }
            })),
            ɵInternalFormsSharedModule
          );
        })(),
        forms_FormsModule = (() => {
          class FormsModule {}
          return (
            (FormsModule.ɵmod = core.Jb({ type: FormsModule })),
            (FormsModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || FormsModule)();
              },
              providers: [forms_RadioControlRegistry],
              imports: [forms_InternalFormsSharedModule]
            })),
            FormsModule
          );
        })();
    },
    '3UD+': function(module, exports) {
      module.exports = function(originalModule) {
        if (!originalModule.webpackPolyfill) {
          var module = Object.create(originalModule);
          module.children || (module.children = []),
            Object.defineProperty(module, 'loaded', {
              enumerable: !0,
              get: function() {
                return module.l;
              }
            }),
            Object.defineProperty(module, 'id', {
              enumerable: !0,
              get: function() {
                return module.i;
              }
            }),
            Object.defineProperty(module, 'exports', { enumerable: !0 }),
            (module.webpackPolyfill = 1);
        }
        return module;
      };
    },
    '3bBZ': function(module, exports, __webpack_require__) {
      var global = __webpack_require__('2oRo'),
        DOMIterables = __webpack_require__('/byt'),
        ArrayIteratorMethods = __webpack_require__('4mDm'),
        hide = __webpack_require__('X2U+'),
        wellKnownSymbol = __webpack_require__('tiKp'),
        ITERATOR = wellKnownSymbol('iterator'),
        TO_STRING_TAG = wellKnownSymbol('toStringTag'),
        ArrayValues = ArrayIteratorMethods.values;
      for (var COLLECTION_NAME in DOMIterables) {
        var Collection = global[COLLECTION_NAME],
          CollectionPrototype = Collection && Collection.prototype;
        if (CollectionPrototype) {
          if (CollectionPrototype[ITERATOR] !== ArrayValues)
            try {
              hide(CollectionPrototype, ITERATOR, ArrayValues);
            } catch (error) {
              CollectionPrototype[ITERATOR] = ArrayValues;
            }
          if (
            (CollectionPrototype[TO_STRING_TAG] ||
              hide(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME),
            DOMIterables[COLLECTION_NAME])
          )
            for (var METHOD_NAME in ArrayIteratorMethods)
              if (
                CollectionPrototype[METHOD_NAME] !==
                ArrayIteratorMethods[METHOD_NAME]
              )
                try {
                  hide(
                    CollectionPrototype,
                    METHOD_NAME,
                    ArrayIteratorMethods[METHOD_NAME]
                  );
                } catch (error) {
                  CollectionPrototype[METHOD_NAME] =
                    ArrayIteratorMethods[METHOD_NAME];
                }
        }
      }
    },
    '4I5i': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return ArgumentOutOfRangeError;
      });
      const ArgumentOutOfRangeError = (() => {
        function ArgumentOutOfRangeErrorImpl() {
          return (
            Error.call(this),
            (this.message = 'argument out of range'),
            (this.name = 'ArgumentOutOfRangeError'),
            this
          );
        }
        return (
          (ArgumentOutOfRangeErrorImpl.prototype = Object.create(
            Error.prototype
          )),
          ArgumentOutOfRangeErrorImpl
        );
      })();
    },
    '4WJ2': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'b', function() {
        return extract;
      }),
        __webpack_require__.d(__webpack_exports__, 'a', function() {
          return I18nService;
        });
      var _logger_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'fSl4'
        ),
        _translations_en_US_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'A/Ql'
        ),
        _translations_es_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'CBKz'
        ),
        _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          'fXoL'
        ),
        _ngx_translate_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          'sYmb'
        ),
        _angular_platform_browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          'jhN1'
        );
      const log = new _logger_service__WEBPACK_IMPORTED_MODULE_0__.a(
        'I18nService'
      );
      function extract(s) {
        return s;
      }
      let I18nService = (() => {
        class I18nService {
          constructor(translateService, _meta, _title) {
            (this.translateService = translateService),
              (this._meta = _meta),
              (this._title = _title),
              translateService.setTranslation(
                'en-US',
                _translations_en_US_json__WEBPACK_IMPORTED_MODULE_1__
              ),
              translateService.setTranslation(
                'es',
                _translations_es_json__WEBPACK_IMPORTED_MODULE_2__
              );
          }
          init(defaultLanguage, supportedLanguages) {
            (this.defaultLanguage = defaultLanguage),
              (this.supportedLanguages = supportedLanguages),
              (this.language = ''),
              (this.langChangeSubscription = this.translateService.onLangChange.subscribe(
                event => {
                  localStorage.setItem('language', event.lang);
                }
              ));
          }
          destroy() {
            this.langChangeSubscription &&
              this.langChangeSubscription.unsubscribe();
          }
          set language(language) {
            language =
              language ||
              localStorage.getItem('language') ||
              this.translateService.getBrowserCultureLang();
            let isSupportedLanguage = this.supportedLanguages.includes(
              language
            );
            language &&
              !isSupportedLanguage &&
              ((language = language.split('-')[0]),
              (language =
                this.supportedLanguages.find(supportedLanguage =>
                  supportedLanguage.startsWith(language)
                ) || ''),
              (isSupportedLanguage = Boolean(language))),
              isSupportedLanguage || (language = this.defaultLanguage),
              log.debug('Language set to ' + language),
              this.translateService.use(language);
          }
          get language() {
            return this.translateService.currentLang;
          }
          updateSeoTags(title, keywords) {
            this.translateService.get([title, keywords]).subscribe(metaData => {
              this._title.setTitle(metaData[title]),
                this._meta.updateTag({
                  name: 'keywords',
                  content: metaData[keywords]
                });
            });
          }
        }
        return (
          (I18nService.ɵfac = function(t) {
            return new (t || I18nService)(
              _angular_core__WEBPACK_IMPORTED_MODULE_3__.Yb(
                _ngx_translate_core__WEBPACK_IMPORTED_MODULE_4__.c
              ),
              _angular_core__WEBPACK_IMPORTED_MODULE_3__.Yb(
                _angular_platform_browser__WEBPACK_IMPORTED_MODULE_5__.c
              ),
              _angular_core__WEBPACK_IMPORTED_MODULE_3__.Yb(
                _angular_platform_browser__WEBPACK_IMPORTED_MODULE_5__.d
              )
            );
          }),
          (I18nService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_3__.Hb({
            token: I18nService,
            factory: I18nService.ɵfac,
            providedIn: 'root'
          })),
          I18nService
        );
      })();
    },
    '4WOD': function(module, exports, __webpack_require__) {
      var has = __webpack_require__('UTVS'),
        toObject = __webpack_require__('ewvW'),
        sharedKey = __webpack_require__('93I0'),
        CORRECT_PROTOTYPE_GETTER = __webpack_require__('4Xet'),
        IE_PROTO = sharedKey('IE_PROTO'),
        ObjectPrototype = Object.prototype;
      module.exports = CORRECT_PROTOTYPE_GETTER
        ? Object.getPrototypeOf
        : function(O) {
            return (
              (O = toObject(O)),
              has(O, IE_PROTO)
                ? O[IE_PROTO]
                : 'function' == typeof O.constructor &&
                  O instanceof O.constructor
                ? O.constructor.prototype
                : O instanceof Object
                ? ObjectPrototype
                : null
            );
          };
    },
    '4Xet': function(module, exports, __webpack_require__) {
      var fails = __webpack_require__('0Dky');
      module.exports = !fails(function() {
        function F() {}
        return (
          (F.prototype.constructor = null),
          Object.getPrototypeOf(new F()) !== F.prototype
        );
      });
    },
    '4l63': function(module, exports, __webpack_require__) {
      var $ = __webpack_require__('I+eb'),
        parseIntImplementation = __webpack_require__('5YOQ');
      $(
        { global: !0, forced: parseInt != parseIntImplementation },
        { parseInt: parseIntImplementation }
      );
    },
    '4mDm': function(module, exports, __webpack_require__) {
      'use strict';
      var toIndexedObject = __webpack_require__('/GqU'),
        addToUnscopables = __webpack_require__('RNIs'),
        Iterators = __webpack_require__('P4y1'),
        InternalStateModule = __webpack_require__('afO8'),
        defineIterator = __webpack_require__('fdAy'),
        setInternalState = InternalStateModule.set,
        getInternalState = InternalStateModule.getterFor('Array Iterator');
      (module.exports = defineIterator(
        Array,
        'Array',
        function(iterated, kind) {
          setInternalState(this, {
            type: 'Array Iterator',
            target: toIndexedObject(iterated),
            index: 0,
            kind: kind
          });
        },
        function() {
          var state = getInternalState(this),
            target = state.target,
            kind = state.kind,
            index = state.index++;
          return !target || index >= target.length
            ? ((state.target = void 0), { value: void 0, done: !0 })
            : 'keys' == kind
            ? { value: index, done: !1 }
            : 'values' == kind
            ? { value: target[index], done: !1 }
            : { value: [index, target[index]], done: !1 };
        },
        'values'
      )),
        (Iterators.Arguments = Iterators.Array),
        addToUnscopables('keys'),
        addToUnscopables('values'),
        addToUnscopables('entries');
    },
    '4syw': function(module, exports, __webpack_require__) {
      var redefine = __webpack_require__('busE');
      module.exports = function(target, src, options) {
        for (var key in src) redefine(target, key, src[key], options);
        return target;
      };
    },
    '5+tZ': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return mergeMap;
      });
      var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'ZUHj'
        ),
        _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'l7GE'
        ),
        _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          '51Dv'
        ),
        _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__('lJxs'),
        _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          'Cfvw'
        );
      function mergeMap(
        project,
        resultSelector,
        concurrent = Number.POSITIVE_INFINITY
      ) {
        return 'function' == typeof resultSelector
          ? source =>
              source.pipe(
                mergeMap(
                  (a, i) =>
                    Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__.a)(
                      project(a, i)
                    ).pipe(
                      Object(_map__WEBPACK_IMPORTED_MODULE_3__.a)((b, ii) =>
                        resultSelector(a, b, i, ii)
                      )
                    ),
                  concurrent
                )
              )
          : ('number' == typeof resultSelector && (concurrent = resultSelector),
            source => source.lift(new MergeMapOperator(project, concurrent)));
      }
      class MergeMapOperator {
        constructor(project, concurrent = Number.POSITIVE_INFINITY) {
          (this.project = project), (this.concurrent = concurrent);
        }
        call(observer, source) {
          return source.subscribe(
            new MergeMapSubscriber(observer, this.project, this.concurrent)
          );
        }
      }
      class MergeMapSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a {
        constructor(
          destination,
          project,
          concurrent = Number.POSITIVE_INFINITY
        ) {
          super(destination),
            (this.project = project),
            (this.concurrent = concurrent),
            (this.hasCompleted = !1),
            (this.buffer = []),
            (this.active = 0),
            (this.index = 0);
        }
        _next(value) {
          this.active < this.concurrent
            ? this._tryNext(value)
            : this.buffer.push(value);
        }
        _tryNext(value) {
          let result;
          const index = this.index++;
          try {
            result = this.project(value, index);
          } catch (err) {
            return void this.destination.error(err);
          }
          this.active++, this._innerSub(result, value, index);
        }
        _innerSub(ish, value, index) {
          const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__.a(
            this,
            void 0,
            void 0
          );
          this.destination.add(innerSubscriber),
            Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_0__.a)(
              this,
              ish,
              value,
              index,
              innerSubscriber
            );
        }
        _complete() {
          (this.hasCompleted = !0),
            0 === this.active &&
              0 === this.buffer.length &&
              this.destination.complete(),
            this.unsubscribe();
        }
        notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(innerValue);
        }
        notifyComplete(innerSub) {
          const buffer = this.buffer;
          this.remove(innerSub),
            this.active--,
            buffer.length > 0
              ? this._next(buffer.shift())
              : 0 === this.active &&
                this.hasCompleted &&
                this.destination.complete();
        }
      }
    },
    '51Dv': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return InnerSubscriber;
      });
      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        '7o/Q'
      );
      class InnerSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(parent, outerValue, outerIndex) {
          super(),
            (this.parent = parent),
            (this.outerValue = outerValue),
            (this.outerIndex = outerIndex),
            (this.index = 0);
        }
        _next(value) {
          this.parent.notifyNext(
            this.outerValue,
            value,
            this.outerIndex,
            this.index++,
            this
          );
        }
        _error(error) {
          this.parent.notifyError(error, this), this.unsubscribe();
        }
        _complete() {
          this.parent.notifyComplete(this), this.unsubscribe();
        }
      }
    },
    '5YOQ': function(module, exports, __webpack_require__) {
      var global = __webpack_require__('2oRo'),
        trim = __webpack_require__('WKiH').trim,
        whitespaces = __webpack_require__('WJkJ'),
        nativeParseInt = global.parseInt,
        hex = /^[+-]?0[Xx]/,
        FORCED =
          8 !== nativeParseInt(whitespaces + '08') ||
          22 !== nativeParseInt(whitespaces + '0x16');
      module.exports = FORCED
        ? function(string, radix) {
            var S = trim(String(string));
            return nativeParseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));
          }
        : nativeParseInt;
    },
    '6JNq': function(module, exports, __webpack_require__) {
      var has = __webpack_require__('UTVS'),
        ownKeys = __webpack_require__('Vu81'),
        getOwnPropertyDescriptorModule = __webpack_require__('Bs8V'),
        definePropertyModule = __webpack_require__('m/L8');
      module.exports = function(target, source) {
        for (
          var keys = ownKeys(source),
            defineProperty = definePropertyModule.f,
            getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f,
            i = 0;
          i < keys.length;
          i++
        ) {
          var key = keys[i];
          has(target, key) ||
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      };
    },
    '6LWA': function(module, exports, __webpack_require__) {
      var classof = __webpack_require__('xrYK');
      module.exports =
        Array.isArray ||
        function(arg) {
          return 'Array' == classof(arg);
        };
    },
    '6NWb': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return angular_fontawesome_FaIconComponent;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return angular_fontawesome_FontAwesomeModule;
        });
      var core = __webpack_require__('fXoL');
      function _typeof(obj) {
        return (_typeof =
          'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
            ? function(obj) {
                return typeof obj;
              }
            : function(obj) {
                return obj &&
                  'function' == typeof Symbol &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj;
              })(obj);
      }
      function _defineProperty(obj, key, value) {
        return (
          key in obj
            ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
            : (obj[key] = value),
          obj
        );
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = null != arguments[i] ? arguments[i] : {},
            ownKeys = Object.keys(source);
          'function' == typeof Object.getOwnPropertySymbols &&
            (ownKeys = ownKeys.concat(
              Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
              })
            )),
            ownKeys.forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
        }
        return target;
      }
      function _slicedToArray(arr, i) {
        return (
          (function(arr) {
            if (Array.isArray(arr)) return arr;
          })(arr) ||
          (function(arr, i) {
            var _arr = [],
              _n = !0,
              _d = !1,
              _e = void 0;
            try {
              for (
                var _s, _i = arr[Symbol.iterator]();
                !(_n = (_s = _i.next()).done) &&
                (_arr.push(_s.value), !i || _arr.length !== i);
                _n = !0
              );
            } catch (err) {
              (_d = !0), (_e = err);
            } finally {
              try {
                _n || null == _i.return || _i.return();
              } finally {
                if (_d) throw _e;
              }
            }
            return _arr;
          })(arr, i) ||
          (function() {
            throw new TypeError(
              'Invalid attempt to destructure non-iterable instance'
            );
          })()
        );
      }
      var _WINDOW = {},
        _DOCUMENT = {};
      try {
        'undefined' != typeof window && (_WINDOW = window),
          'undefined' != typeof document && (_DOCUMENT = document),
          'undefined' != typeof MutationObserver && MutationObserver,
          'undefined' != typeof performance && performance;
      } catch (e) {}
      var _ref$userAgent = (_WINDOW.navigator || {}).userAgent,
        userAgent = void 0 === _ref$userAgent ? '' : _ref$userAgent,
        WINDOW = _WINDOW,
        DOCUMENT = _DOCUMENT,
        IS_DOM =
          !!DOCUMENT.documentElement &&
          !!DOCUMENT.head &&
          'function' == typeof DOCUMENT.addEventListener &&
          'function' == typeof DOCUMENT.createElement,
        oneToTen =
          (~userAgent.indexOf('MSIE') || userAgent.indexOf('Trident/'),
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
        oneToTwenty = oneToTen.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]),
        DUOTONE_CLASSES = {
          GROUP: 'group',
          SWAP_OPACITY: 'swap-opacity',
          PRIMARY: 'primary',
          SECONDARY: 'secondary'
        },
        initial =
          ([
            'xs',
            'sm',
            'lg',
            'fw',
            'ul',
            'li',
            'border',
            'pull-left',
            'pull-right',
            'spin',
            'pulse',
            'rotate-90',
            'rotate-180',
            'rotate-270',
            'flip-horizontal',
            'flip-vertical',
            'flip-both',
            'stack',
            'stack-1x',
            'stack-2x',
            'inverse',
            'layers',
            'layers-text',
            'layers-counter',
            DUOTONE_CLASSES.GROUP,
            DUOTONE_CLASSES.SWAP_OPACITY,
            DUOTONE_CLASSES.PRIMARY,
            DUOTONE_CLASSES.SECONDARY
          ]
            .concat(
              oneToTen.map(function(n) {
                return ''.concat(n, 'x');
              })
            )
            .concat(
              oneToTwenty.map(function(n) {
                return 'w-'.concat(n);
              })
            ),
          WINDOW.FontAwesomeConfig || {});
      DOCUMENT &&
        'function' == typeof DOCUMENT.querySelector &&
        [
          ['data-family-prefix', 'familyPrefix'],
          ['data-replacement-class', 'replacementClass'],
          ['data-auto-replace-svg', 'autoReplaceSvg'],
          ['data-auto-add-css', 'autoAddCss'],
          ['data-auto-a11y', 'autoA11y'],
          ['data-search-pseudo-elements', 'searchPseudoElements'],
          ['data-observe-mutations', 'observeMutations'],
          ['data-mutate-approach', 'mutateApproach'],
          ['data-keep-original-source', 'keepOriginalSource'],
          ['data-measure-performance', 'measurePerformance'],
          ['data-show-missing-icons', 'showMissingIcons']
        ].forEach(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[1],
            val = (function(val) {
              return '' === val || ('false' !== val && ('true' === val || val));
            })(
              (function(attr) {
                var element = DOCUMENT.querySelector('script[' + attr + ']');
                if (element) return element.getAttribute(attr);
              })(_ref2[0])
            );
          null != val && (initial[key] = val);
        });
      var _config = _objectSpread(
        {},
        {
          familyPrefix: 'fa',
          replacementClass: 'svg-inline--fa',
          autoReplaceSvg: !0,
          autoAddCss: !0,
          autoA11y: !0,
          searchPseudoElements: !1,
          observeMutations: !0,
          mutateApproach: 'async',
          keepOriginalSource: !0,
          measurePerformance: !1,
          showMissingIcons: !0
        },
        initial
      );
      _config.autoReplaceSvg || (_config.observeMutations = !1);
      var config = _objectSpread({}, _config);
      WINDOW.FontAwesomeConfig = config;
      var w = WINDOW || {};
      w.___FONT_AWESOME___ || (w.___FONT_AWESOME___ = {}),
        w.___FONT_AWESOME___.styles || (w.___FONT_AWESOME___.styles = {}),
        w.___FONT_AWESOME___.hooks || (w.___FONT_AWESOME___.hooks = {}),
        w.___FONT_AWESOME___.shims || (w.___FONT_AWESOME___.shims = []);
      var namespace = w.___FONT_AWESOME___,
        functions = [];
      IS_DOM &&
        ((DOCUMENT.documentElement.doScroll
          ? /^loaded|^c/
          : /^loaded|^i|^c/
        ).test(DOCUMENT.readyState) ||
          DOCUMENT.addEventListener('DOMContentLoaded', function listener() {
            DOCUMENT.removeEventListener('DOMContentLoaded', listener),
              functions.map(function(fn) {
                return fn();
              });
          }));
      var asyncTimer,
        NOOP = function() {},
        isNode =
          'undefined' != typeof global &&
          void 0 !== global.process &&
          'function' == typeof global.process.emit,
        asyncSetTimer =
          'undefined' == typeof setImmediate ? setTimeout : setImmediate,
        asyncQueue = [];
      function asyncFlush() {
        for (var i = 0; i < asyncQueue.length; i++)
          asyncQueue[i][0](asyncQueue[i][1]);
        (asyncQueue = []), (asyncTimer = !1);
      }
      function asyncCall(callback, arg) {
        asyncQueue.push([callback, arg]),
          asyncTimer || ((asyncTimer = !0), asyncSetTimer(asyncFlush, 0));
      }
      function invokeCallback(subscriber) {
        var owner = subscriber.owner,
          settled = owner._state,
          value = owner._data,
          callback = subscriber[settled],
          promise = subscriber.then;
        if ('function' == typeof callback) {
          settled = 'fulfilled';
          try {
            value = callback(value);
          } catch (e) {
            reject(promise, e);
          }
        }
        handleThenable(promise, value) ||
          ('fulfilled' === settled && resolve(promise, value),
          'rejected' === settled && reject(promise, value));
      }
      function handleThenable(promise, value) {
        var resolved;
        try {
          if (promise === value)
            throw new TypeError(
              'A promises callback cannot return that same promise.'
            );
          if (
            value &&
            ('function' == typeof value || 'object' === _typeof(value))
          ) {
            var then = value.then;
            if ('function' == typeof then)
              return (
                then.call(
                  value,
                  function(val) {
                    resolved ||
                      ((resolved = !0),
                      value === val
                        ? fulfill(promise, val)
                        : resolve(promise, val));
                  },
                  function(reason) {
                    resolved || ((resolved = !0), reject(promise, reason));
                  }
                ),
                !0
              );
          }
        } catch (e) {
          return resolved || reject(promise, e), !0;
        }
        return !1;
      }
      function resolve(promise, value) {
        (promise !== value && handleThenable(promise, value)) ||
          fulfill(promise, value);
      }
      function fulfill(promise, value) {
        'pending' === promise._state &&
          ((promise._state = 'settled'),
          (promise._data = value),
          asyncCall(publishFulfillment, promise));
      }
      function reject(promise, reason) {
        'pending' === promise._state &&
          ((promise._state = 'settled'),
          (promise._data = reason),
          asyncCall(publishRejection, promise));
      }
      function publish(promise) {
        promise._then = promise._then.forEach(invokeCallback);
      }
      function publishFulfillment(promise) {
        (promise._state = 'fulfilled'), publish(promise);
      }
      function publishRejection(promise) {
        (promise._state = 'rejected'),
          publish(promise),
          !promise._handled &&
            isNode &&
            global.process.emit('unhandledRejection', promise._data, promise);
      }
      function notifyRejectionHandled(promise) {
        global.process.emit('rejectionHandled', promise);
      }
      function P(resolver) {
        if ('function' != typeof resolver)
          throw new TypeError(
            'Promise resolver ' + resolver + ' is not a function'
          );
        if (this instanceof P == 0)
          throw new TypeError(
            "Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."
          );
        (this._then = []),
          (function(resolver, promise) {
            function rejectPromise(reason) {
              reject(promise, reason);
            }
            try {
              resolver(function(value) {
                resolve(promise, value);
              }, rejectPromise);
            } catch (e) {
              rejectPromise(e);
            }
          })(resolver, this);
      }
      (P.prototype = {
        constructor: P,
        _state: 'pending',
        _then: null,
        _data: void 0,
        _handled: !1,
        then: function(onFulfillment, onRejection) {
          var subscriber = {
            owner: this,
            then: new this.constructor(NOOP),
            fulfilled: onFulfillment,
            rejected: onRejection
          };
          return (
            (!onRejection && !onFulfillment) ||
              this._handled ||
              ((this._handled = !0),
              'rejected' === this._state &&
                isNode &&
                asyncCall(notifyRejectionHandled, this)),
            'fulfilled' === this._state || 'rejected' === this._state
              ? asyncCall(invokeCallback, subscriber)
              : this._then.push(subscriber),
            subscriber.then
          );
        },
        catch: function(onRejection) {
          return this.then(null, onRejection);
        }
      }),
        (P.all = function(promises) {
          if (!Array.isArray(promises))
            throw new TypeError('You must pass an array to Promise.all().');
          return new P(function(resolve, reject) {
            var results = [],
              remaining = 0;
            function resolver(index) {
              return (
                remaining++,
                function(value) {
                  (results[index] = value), --remaining || resolve(results);
                }
              );
            }
            for (var promise, i = 0; i < promises.length; i++)
              (promise = promises[i]) && 'function' == typeof promise.then
                ? promise.then(resolver(i), reject)
                : (results[i] = promise);
            remaining || resolve(results);
          });
        }),
        (P.race = function(promises) {
          if (!Array.isArray(promises))
            throw new TypeError('You must pass an array to Promise.race().');
          return new P(function(resolve, reject) {
            for (var promise, i = 0; i < promises.length; i++)
              (promise = promises[i]) && 'function' == typeof promise.then
                ? promise.then(resolve, reject)
                : resolve(promise);
          });
        }),
        (P.resolve = function(value) {
          return value && 'object' === _typeof(value) && value.constructor === P
            ? value
            : new P(function(resolve) {
                resolve(value);
              });
        }),
        (P.reject = function(reason) {
          return new P(function(resolve, reject) {
            reject(reason);
          });
        });
      var meaninglessTransform = {
        size: 16,
        x: 0,
        y: 0,
        rotate: 0,
        flipX: !1,
        flipY: !1
      };
      function nextUniqueId() {
        for (var size = 12, id = ''; size-- > 0; )
          id += '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'[
            (62 * Math.random()) | 0
          ];
        return id;
      }
      function htmlEscape(str) {
        return ''
          .concat(str)
          .replace(/&/g, '&amp;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }
      function joinStyles(styles) {
        return Object.keys(styles || {}).reduce(function(acc, styleName) {
          return (
            acc + ''.concat(styleName, ': ').concat(styles[styleName], ';')
          );
        }, '');
      }
      function transformIsMeaningful(transform) {
        return (
          transform.size !== meaninglessTransform.size ||
          transform.x !== meaninglessTransform.x ||
          transform.y !== meaninglessTransform.y ||
          transform.rotate !== meaninglessTransform.rotate ||
          transform.flipX ||
          transform.flipY
        );
      }
      function transformForSvg(_ref) {
        var transform = _ref.transform,
          iconWidth = _ref.iconWidth,
          outer = {
            transform: 'translate('.concat(_ref.containerWidth / 2, ' 256)')
          },
          innerTranslate = 'translate('
            .concat(32 * transform.x, ', ')
            .concat(32 * transform.y, ') '),
          innerScale = 'scale('
            .concat((transform.size / 16) * (transform.flipX ? -1 : 1), ', ')
            .concat((transform.size / 16) * (transform.flipY ? -1 : 1), ') '),
          innerRotate = 'rotate('.concat(transform.rotate, ' 0 0)');
        return {
          outer: outer,
          inner: {
            transform: ''
              .concat(innerTranslate, ' ')
              .concat(innerScale, ' ')
              .concat(innerRotate)
          },
          path: {
            transform: 'translate('.concat((iconWidth / 2) * -1, ' -256)')
          }
        };
      }
      var ALL_SPACE = { x: 0, y: 0, width: '100%', height: '100%' };
      function fillBlack(abstract) {
        var force =
          !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        return (
          abstract.attributes &&
            (abstract.attributes.fill || force) &&
            (abstract.attributes.fill = 'black'),
          abstract
        );
      }
      function makeInlineSvgAbstract(params) {
        var _params$icons = params.icons,
          main = _params$icons.main,
          mask = _params$icons.mask,
          prefix = params.prefix,
          iconName = params.iconName,
          transform = params.transform,
          symbol = params.symbol,
          title = params.title,
          extra = params.extra,
          _params$watchable = params.watchable,
          watchable = void 0 !== _params$watchable && _params$watchable,
          _ref = mask.found ? mask : main,
          width = _ref.width,
          height = _ref.height,
          widthClass = 'fa-w-'.concat(Math.ceil((width / height) * 16)),
          attrClass = [
            config.replacementClass,
            iconName
              ? ''.concat(config.familyPrefix, '-').concat(iconName)
              : '',
            widthClass
          ]
            .filter(function(c) {
              return -1 === extra.classes.indexOf(c);
            })
            .concat(extra.classes)
            .join(' '),
          content = {
            children: [],
            attributes: _objectSpread({}, extra.attributes, {
              'data-prefix': prefix,
              'data-icon': iconName,
              class: attrClass,
              role: extra.attributes.role || 'img',
              xmlns: 'http://www.w3.org/2000/svg',
              viewBox: '0 0 '.concat(width, ' ').concat(height)
            })
          };
        watchable && (content.attributes['data-fa-i2svg'] = ''),
          title &&
            content.children.push({
              tag: 'title',
              attributes: {
                id:
                  content.attributes['aria-labelledby'] ||
                  'title-'.concat(nextUniqueId())
              },
              children: [title]
            });
        var args = _objectSpread({}, content, {
            prefix: prefix,
            iconName: iconName,
            main: main,
            mask: mask,
            transform: transform,
            symbol: symbol,
            styles: extra.styles
          }),
          _ref2 =
            mask.found && main.found
              ? (function(_ref) {
                  var abstract,
                    children = _ref.children,
                    attributes = _ref.attributes,
                    main = _ref.main,
                    mask = _ref.mask,
                    mainPath = main.icon,
                    maskPath = mask.icon,
                    trans = transformForSvg({
                      transform: _ref.transform,
                      containerWidth: mask.width,
                      iconWidth: main.width
                    }),
                    maskRect = {
                      tag: 'rect',
                      attributes: _objectSpread({}, ALL_SPACE, {
                        fill: 'white'
                      })
                    },
                    maskInnerGroupChildrenMixin = mainPath.children
                      ? { children: mainPath.children.map(fillBlack) }
                      : {},
                    maskInnerGroup = {
                      tag: 'g',
                      attributes: _objectSpread({}, trans.inner),
                      children: [
                        fillBlack(
                          _objectSpread(
                            {
                              tag: mainPath.tag,
                              attributes: _objectSpread(
                                {},
                                mainPath.attributes,
                                trans.path
                              )
                            },
                            maskInnerGroupChildrenMixin
                          )
                        )
                      ]
                    },
                    maskOuterGroup = {
                      tag: 'g',
                      attributes: _objectSpread({}, trans.outer),
                      children: [maskInnerGroup]
                    },
                    maskId = 'mask-'.concat(nextUniqueId()),
                    clipId = 'clip-'.concat(nextUniqueId()),
                    maskTag = {
                      tag: 'mask',
                      attributes: _objectSpread({}, ALL_SPACE, {
                        id: maskId,
                        maskUnits: 'userSpaceOnUse',
                        maskContentUnits: 'userSpaceOnUse'
                      }),
                      children: [maskRect, maskOuterGroup]
                    },
                    defs = {
                      tag: 'defs',
                      children: [
                        {
                          tag: 'clipPath',
                          attributes: { id: clipId },
                          children:
                            ((abstract = maskPath),
                            'g' === abstract.tag
                              ? abstract.children
                              : [abstract])
                        },
                        maskTag
                      ]
                    };
                  return (
                    children.push(defs, {
                      tag: 'rect',
                      attributes: _objectSpread(
                        {
                          fill: 'currentColor',
                          'clip-path': 'url(#'.concat(clipId, ')'),
                          mask: 'url(#'.concat(maskId, ')')
                        },
                        ALL_SPACE
                      )
                    }),
                    { children: children, attributes: attributes }
                  );
                })(args)
              : (function(_ref) {
                  var children = _ref.children,
                    attributes = _ref.attributes,
                    main = _ref.main,
                    transform = _ref.transform,
                    styleString = joinStyles(_ref.styles);
                  if (
                    (styleString.length > 0 && (attributes.style = styleString),
                    transformIsMeaningful(transform))
                  ) {
                    var trans = transformForSvg({
                      transform: transform,
                      containerWidth: main.width,
                      iconWidth: main.width
                    });
                    children.push({
                      tag: 'g',
                      attributes: _objectSpread({}, trans.outer),
                      children: [
                        {
                          tag: 'g',
                          attributes: _objectSpread({}, trans.inner),
                          children: [
                            {
                              tag: main.icon.tag,
                              children: main.icon.children,
                              attributes: _objectSpread(
                                {},
                                main.icon.attributes,
                                trans.path
                              )
                            }
                          ]
                        }
                      ]
                    });
                  } else children.push(main.icon);
                  return { children: children, attributes: attributes };
                })(args),
          attributes = _ref2.attributes;
        return (
          (args.children = _ref2.children),
          (args.attributes = attributes),
          symbol
            ? (function(_ref) {
                var iconName = _ref.iconName,
                  children = _ref.children,
                  symbol = _ref.symbol;
                return [
                  {
                    tag: 'svg',
                    attributes: { style: 'display: none;' },
                    children: [
                      {
                        tag: 'symbol',
                        attributes: _objectSpread({}, _ref.attributes, {
                          id:
                            !0 === symbol
                              ? ''
                                  .concat(_ref.prefix, '-')
                                  .concat(config.familyPrefix, '-')
                                  .concat(iconName)
                              : symbol
                        }),
                        children: children
                      }
                    ]
                  }
                ];
              })(args)
            : (function(_ref) {
                var children = _ref.children,
                  main = _ref.main,
                  mask = _ref.mask,
                  attributes = _ref.attributes,
                  styles = _ref.styles,
                  transform = _ref.transform;
                if (
                  transformIsMeaningful(transform) &&
                  main.found &&
                  !mask.found
                ) {
                  var offset = { x: main.width / main.height / 2, y: 0.5 };
                  attributes.style = joinStyles(
                    _objectSpread({}, styles, {
                      'transform-origin': ''
                        .concat(offset.x + transform.x / 16, 'em ')
                        .concat(offset.y + transform.y / 16, 'em')
                    })
                  );
                }
                return [
                  { tag: 'svg', attributes: attributes, children: children }
                ];
              })(args)
        );
      }
      var reduce = function(subject, fn, initialValue, thisContext) {
        var i,
          key,
          result,
          keys = Object.keys(subject),
          length = keys.length,
          iterator =
            void 0 !== thisContext
              ? (function(func, thisContext) {
                  return function(a, b, c, d) {
                    return func.call(thisContext, a, b, c, d);
                  };
                })(fn, thisContext)
              : fn;
        for (
          void 0 === initialValue
            ? ((i = 1), (result = subject[keys[0]]))
            : ((i = 0), (result = initialValue));
          i < length;
          i++
        )
          result = iterator(result, subject[(key = keys[i])], key, subject);
        return result;
      };
      function defineIcons(prefix, icons) {
        var params =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
          _params$skipHooks = params.skipHooks,
          skipHooks = void 0 !== _params$skipHooks && _params$skipHooks,
          normalized = Object.keys(icons).reduce(function(acc, iconName) {
            var icon = icons[iconName];
            return (
              icon.icon
                ? (acc[icon.iconName] = icon.icon)
                : (acc[iconName] = icon),
              acc
            );
          }, {});
        'function' != typeof namespace.hooks.addPack || skipHooks
          ? (namespace.styles[prefix] = _objectSpread(
              {},
              namespace.styles[prefix] || {},
              normalized
            ))
          : namespace.hooks.addPack(prefix, normalized),
          'fas' === prefix && defineIcons('fa', icons);
      }
      var styles = namespace.styles,
        shims = namespace.shims,
        build = function() {
          var lookup = function(reducer) {
            return reduce(
              styles,
              function(o, style, prefix) {
                return (o[prefix] = reduce(style, reducer, {})), o;
              },
              {}
            );
          };
          lookup(function(acc, icon, iconName) {
            return icon[3] && (acc[icon[3]] = iconName), acc;
          }),
            lookup(function(acc, icon, iconName) {
              var ligatures = icon[2];
              return (
                (acc[iconName] = iconName),
                ligatures.forEach(function(ligature) {
                  acc[ligature] = iconName;
                }),
                acc
              );
            });
          var hasRegular = 'far' in styles;
          reduce(
            shims,
            function(acc, shim) {
              var prefix = shim[1];
              return (
                'far' !== prefix || hasRegular || (prefix = 'fas'),
                (acc[shim[0]] = { prefix: prefix, iconName: shim[2] }),
                acc
              );
            },
            {}
          );
        };
      function iconFromMapping(mapping, prefix, iconName) {
        if (mapping && mapping[prefix] && mapping[prefix][iconName])
          return {
            prefix: prefix,
            iconName: iconName,
            icon: mapping[prefix][iconName]
          };
      }
      function toHtml(abstractNodes) {
        var tag = abstractNodes.tag,
          _abstractNodes$attrib = abstractNodes.attributes,
          attributes =
            void 0 === _abstractNodes$attrib ? {} : _abstractNodes$attrib,
          _abstractNodes$childr = abstractNodes.children,
          children =
            void 0 === _abstractNodes$childr ? [] : _abstractNodes$childr;
        return 'string' == typeof abstractNodes
          ? htmlEscape(abstractNodes)
          : '<'
              .concat(tag, ' ')
              .concat(
                (function(attributes) {
                  return Object.keys(attributes || {})
                    .reduce(function(acc, attributeName) {
                      return (
                        acc +
                        ''
                          .concat(attributeName, '="')
                          .concat(htmlEscape(attributes[attributeName]), '" ')
                      );
                    }, '')
                    .trim();
                })(attributes),
                '>'
              )
              .concat(children.map(toHtml).join(''), '</')
              .concat(tag, '>');
      }
      function MissingIcon(error) {
        (this.name = 'MissingIcon'),
          (this.message = error || 'Icon unavailable'),
          (this.stack = new Error().stack);
      }
      build(),
        ((MissingIcon.prototype = Object.create(
          Error.prototype
        )).constructor = MissingIcon);
      var FILL = { fill: 'currentColor' },
        ANIMATION_BASE = {
          attributeType: 'XML',
          repeatCount: 'indefinite',
          dur: '2s'
        },
        OPACITY_ANIMATE =
          (_objectSpread({}, FILL, {
            d:
              'M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z'
          }),
          _objectSpread({}, ANIMATION_BASE, { attributeName: 'opacity' }));
      function asFoundIcon(icon) {
        var width = icon[0],
          height = icon[1],
          vectorData = _slicedToArray(icon.slice(4), 1)[0];
        return {
          found: !0,
          width: width,
          height: height,
          icon: Array.isArray(vectorData)
            ? {
                tag: 'g',
                attributes: {
                  class: ''
                    .concat(config.familyPrefix, '-')
                    .concat(DUOTONE_CLASSES.GROUP)
                },
                children: [
                  {
                    tag: 'path',
                    attributes: {
                      class: ''
                        .concat(config.familyPrefix, '-')
                        .concat(DUOTONE_CLASSES.SECONDARY),
                      fill: 'currentColor',
                      d: vectorData[0]
                    }
                  },
                  {
                    tag: 'path',
                    attributes: {
                      class: ''
                        .concat(config.familyPrefix, '-')
                        .concat(DUOTONE_CLASSES.PRIMARY),
                      fill: 'currentColor',
                      d: vectorData[1]
                    }
                  }
                ]
              }
            : {
                tag: 'path',
                attributes: { fill: 'currentColor', d: vectorData }
              }
        };
      }
      function ensureCss() {
        config.autoAddCss &&
          !_cssInserted &&
          ((function(css) {
            if (css && IS_DOM) {
              var style = DOCUMENT.createElement('style');
              style.setAttribute('type', 'text/css'), (style.innerHTML = css);
              for (
                var headChildren = DOCUMENT.head.childNodes,
                  beforeChild = null,
                  i = headChildren.length - 1;
                i > -1;
                i--
              ) {
                var child = headChildren[i],
                  tagName = (child.tagName || '').toUpperCase();
                ['STYLE', 'LINK'].indexOf(tagName) > -1 &&
                  (beforeChild = child);
              }
              DOCUMENT.head.insertBefore(style, beforeChild);
            }
          })(
            (function() {
              var drc = 'svg-inline--fa',
                fp = config.familyPrefix,
                rc = config.replacementClass,
                s =
                  'svg:not(:root).svg-inline--fa {\n  overflow: visible;\n}\n\n.svg-inline--fa {\n  display: inline-block;\n  font-size: inherit;\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.225em;\n}\n.svg-inline--fa.fa-w-1 {\n  width: 0.0625em;\n}\n.svg-inline--fa.fa-w-2 {\n  width: 0.125em;\n}\n.svg-inline--fa.fa-w-3 {\n  width: 0.1875em;\n}\n.svg-inline--fa.fa-w-4 {\n  width: 0.25em;\n}\n.svg-inline--fa.fa-w-5 {\n  width: 0.3125em;\n}\n.svg-inline--fa.fa-w-6 {\n  width: 0.375em;\n}\n.svg-inline--fa.fa-w-7 {\n  width: 0.4375em;\n}\n.svg-inline--fa.fa-w-8 {\n  width: 0.5em;\n}\n.svg-inline--fa.fa-w-9 {\n  width: 0.5625em;\n}\n.svg-inline--fa.fa-w-10 {\n  width: 0.625em;\n}\n.svg-inline--fa.fa-w-11 {\n  width: 0.6875em;\n}\n.svg-inline--fa.fa-w-12 {\n  width: 0.75em;\n}\n.svg-inline--fa.fa-w-13 {\n  width: 0.8125em;\n}\n.svg-inline--fa.fa-w-14 {\n  width: 0.875em;\n}\n.svg-inline--fa.fa-w-15 {\n  width: 0.9375em;\n}\n.svg-inline--fa.fa-w-16 {\n  width: 1em;\n}\n.svg-inline--fa.fa-w-17 {\n  width: 1.0625em;\n}\n.svg-inline--fa.fa-w-18 {\n  width: 1.125em;\n}\n.svg-inline--fa.fa-w-19 {\n  width: 1.1875em;\n}\n.svg-inline--fa.fa-w-20 {\n  width: 1.25em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-border {\n  height: 1.5em;\n}\n.svg-inline--fa.fa-li {\n  width: 2em;\n}\n.svg-inline--fa.fa-fw {\n  width: 1.25em;\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: #ff253a;\n  border-radius: 1em;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #fff;\n  height: 1.5em;\n  line-height: 1;\n  max-width: 5em;\n  min-width: 1.5em;\n  overflow: hidden;\n  padding: 0.25em;\n  right: 0;\n  text-overflow: ellipsis;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: 0;\n  right: 0;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: 0;\n  left: 0;\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  right: 0;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: 0;\n  right: auto;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-lg {\n  font-size: 1.3333333333em;\n  line-height: 0.75em;\n  vertical-align: -0.0667em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit;\n}\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: 0.1em;\n  padding: 0.2em 0.25em 0.15em;\n}\n\n.fa-pull-left {\n  float: left;\n}\n\n.fa-pull-right {\n  float: right;\n}\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: 0.3em;\n}\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: 0.3em;\n}\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear;\n}\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8);\n}\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical,\n:root .fa-flip-both {\n  -webkit-filter: none;\n          filter: none;\n}\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: #fff;\n}\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse {\n  color: #fff;\n}';
              if ('fa' !== fp || rc !== drc) {
                var dPatt = new RegExp('\\.'.concat('fa', '\\-'), 'g'),
                  customPropPatt = new RegExp('\\--'.concat('fa', '\\-'), 'g'),
                  rPatt = new RegExp('\\.'.concat(drc), 'g');
                s = s
                  .replace(dPatt, '.'.concat(fp, '-'))
                  .replace(customPropPatt, '--'.concat(fp, '-'))
                  .replace(rPatt, '.'.concat(rc));
              }
              return s;
            })()
          ),
          (_cssInserted = !0));
      }
      function apiObject(val, abstractCreator) {
        return (
          Object.defineProperty(val, 'abstract', { get: abstractCreator }),
          Object.defineProperty(val, 'html', {
            get: function() {
              return val.abstract.map(function(a) {
                return toHtml(a);
              });
            }
          }),
          Object.defineProperty(val, 'node', {
            get: function() {
              if (IS_DOM) {
                var container = DOCUMENT.createElement('div');
                return (container.innerHTML = val.html), container.children;
              }
            }
          }),
          val
        );
      }
      function findIconDefinition(iconLookup) {
        var _iconLookup$prefix = iconLookup.prefix,
          prefix = void 0 === _iconLookup$prefix ? 'fa' : _iconLookup$prefix,
          iconName = iconLookup.iconName;
        if (iconName)
          return (
            iconFromMapping(library.definitions, prefix, iconName) ||
            iconFromMapping(namespace.styles, prefix, iconName)
          );
      }
      _objectSpread({}, FILL, { cx: '256', cy: '364', r: '28' }),
        _objectSpread({}, ANIMATION_BASE, {
          attributeName: 'r',
          values: '28;14;28;28;14;28;'
        }),
        _objectSpread({}, OPACITY_ANIMATE, { values: '1;0;1;1;0;1;' }),
        _objectSpread({}, FILL, {
          opacity: '1',
          d:
            'M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z'
        }),
        _objectSpread({}, OPACITY_ANIMATE, { values: '1;0;0;0;0;1;' }),
        _objectSpread({}, FILL, {
          opacity: '0',
          d:
            'M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z'
        }),
        _objectSpread({}, OPACITY_ANIMATE, { values: '0;0;1;1;0;0;' });
      var next,
        library = new ((function() {
          function Library() {
            !(function(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError('Cannot call a class as a function');
            })(this, Library),
              (this.definitions = {});
          }
          var protoProps;
          return (
            (protoProps = [
              {
                key: 'add',
                value: function() {
                  for (
                    var _this = this,
                      _len = arguments.length,
                      definitions = new Array(_len),
                      _key = 0;
                    _key < _len;
                    _key++
                  )
                    definitions[_key] = arguments[_key];
                  var additions = definitions.reduce(this._pullDefinitions, {});
                  Object.keys(additions).forEach(function(key) {
                    (_this.definitions[key] = _objectSpread(
                      {},
                      _this.definitions[key] || {},
                      additions[key]
                    )),
                      defineIcons(key, additions[key]),
                      build();
                  });
                }
              },
              {
                key: 'reset',
                value: function() {
                  this.definitions = {};
                }
              },
              {
                key: '_pullDefinitions',
                value: function(additions, definition) {
                  var normalized =
                    definition.prefix && definition.iconName && definition.icon
                      ? { 0: definition }
                      : definition;
                  return (
                    Object.keys(normalized).map(function(key) {
                      var _normalized$key = normalized[key],
                        prefix = _normalized$key.prefix,
                        iconName = _normalized$key.iconName,
                        icon = _normalized$key.icon;
                      additions[prefix] || (additions[prefix] = {}),
                        (additions[prefix][iconName] = icon);
                    }),
                    additions
                  );
                }
              }
            ]) &&
              (function(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  (descriptor.enumerable = descriptor.enumerable || !1),
                    (descriptor.configurable = !0),
                    'value' in descriptor && (descriptor.writable = !0),
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
              })(Library.prototype, protoProps),
            Library
          );
        })())(),
        _cssInserted = !1,
        icon =
          ((next = function(iconDefinition) {
            var params =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {},
              _params$transform = params.transform,
              transform =
                void 0 === _params$transform
                  ? meaninglessTransform
                  : _params$transform,
              _params$symbol = params.symbol,
              symbol = void 0 !== _params$symbol && _params$symbol,
              _params$mask = params.mask,
              mask = void 0 === _params$mask ? null : _params$mask,
              _params$title = params.title,
              title = void 0 === _params$title ? null : _params$title,
              _params$classes = params.classes,
              classes = void 0 === _params$classes ? [] : _params$classes,
              _params$attributes = params.attributes,
              attributes =
                void 0 === _params$attributes ? {} : _params$attributes,
              _params$styles = params.styles,
              styles = void 0 === _params$styles ? {} : _params$styles;
            if (iconDefinition) {
              var prefix = iconDefinition.prefix,
                iconName = iconDefinition.iconName,
                icon = iconDefinition.icon;
              return apiObject(
                _objectSpread({ type: 'icon' }, iconDefinition),
                function() {
                  return (
                    ensureCss(),
                    config.autoA11y &&
                      (title
                        ? (attributes['aria-labelledby'] = ''
                            .concat(config.replacementClass, '-title-')
                            .concat(nextUniqueId()))
                        : ((attributes['aria-hidden'] = 'true'),
                          (attributes.focusable = 'false'))),
                    makeInlineSvgAbstract({
                      icons: {
                        main: asFoundIcon(icon),
                        mask: mask
                          ? asFoundIcon(mask.icon)
                          : { found: !1, width: null, height: null, icon: {} }
                      },
                      prefix: prefix,
                      iconName: iconName,
                      transform: _objectSpread(
                        {},
                        meaninglessTransform,
                        transform
                      ),
                      symbol: symbol,
                      title: title,
                      extra: {
                        attributes: attributes,
                        styles: styles,
                        classes: classes
                      }
                    })
                  );
                }
              );
            }
          }),
          function(maybeIconDefinition) {
            var params =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {},
              iconDefinition = (maybeIconDefinition || {}).icon
                ? maybeIconDefinition
                : findIconDefinition(maybeIconDefinition || {}),
              mask = params.mask;
            return (
              mask &&
                (mask = (mask || {}).icon
                  ? mask
                  : findIconDefinition(mask || {})),
              next(iconDefinition, _objectSpread({}, params, { mask: mask }))
            );
          }),
        platform_browser = __webpack_require__('jhN1');
      let angular_fontawesome_FaConfig = (() => {
          class FaConfig {
            constructor() {
              (this.defaultPrefix = 'fas'), (this.globalLibrary = 'unset');
            }
          }
          return (
            (FaConfig.ɵfac = function(t) {
              return new (t || FaConfig)();
            }),
            (FaConfig.ɵprov = core.Hb({
              token: FaConfig,
              factory: FaConfig.ɵfac,
              providedIn: 'root'
            })),
            (FaConfig.ngInjectableDef = Object(core.Hb)({
              factory: function() {
                return new FaConfig();
              },
              token: FaConfig,
              providedIn: 'root'
            })),
            FaConfig
          );
        })(),
        angular_fontawesome_FaIconLibrary = (() => {
          class FaIconLibrary {
            constructor() {
              this.definitions = {};
            }
            addIcons(...icons) {
              for (let i = 0; i < icons.length; i++) {
                const icon = icons[i];
                icon.prefix in this.definitions ||
                  (this.definitions[icon.prefix] = {}),
                  (this.definitions[icon.prefix][icon.iconName] = icon);
              }
            }
            addIconPacks(...packs) {
              for (let i = 0; i < packs.length; i++) {
                const pack = packs[i],
                  icons = Object.keys(pack).map(key => pack[key]);
                this.addIcons(...icons);
              }
            }
            getIconDefinition(prefix, name) {
              return prefix in this.definitions &&
                name in this.definitions[prefix]
                ? this.definitions[prefix][name]
                : null;
            }
          }
          return (
            (FaIconLibrary.ɵfac = function(t) {
              return new (t || FaIconLibrary)();
            }),
            (FaIconLibrary.ɵprov = core.Hb({
              token: FaIconLibrary,
              factory: FaIconLibrary.ɵfac,
              providedIn: 'root'
            })),
            (FaIconLibrary.ngInjectableDef = Object(core.Hb)({
              factory: function() {
                return new FaIconLibrary();
              },
              token: FaIconLibrary,
              providedIn: 'root'
            })),
            FaIconLibrary
          );
        })();
      const faClassList = props => {
        const classes = {
          'fa-spin': props.spin,
          'fa-pulse': props.pulse,
          'fa-fw': props.fixedWidth,
          'fa-border': props.border,
          'fa-li': props.listItem,
          'fa-inverse': props.inverse,
          'fa-layers-counter': props.counter,
          'fa-flip-horizontal':
            'horizontal' === props.flip || 'both' === props.flip,
          'fa-flip-vertical':
            'vertical' === props.flip || 'both' === props.flip,
          ['fa-' + props.size]: null !== props.size,
          ['fa-rotate-' + props.rotate]: null !== props.rotate,
          ['fa-pull-' + props.pull]: null !== props.pull,
          ['fa-stack-' + props.stackItemSize]: null != props.stackItemSize
        };
        return Object.keys(classes)
          .map(key => (classes[key] ? key : null))
          .filter(key => key);
      };
      let angular_fontawesome_FaStackItemSizeDirective = (() => {
          class FaStackItemSizeDirective {
            constructor() {
              this.stackItemSize = '1x';
            }
            ngOnChanges(changes) {
              if ('size' in changes)
                throw new Error(
                  'fa-icon is not allowed to customize size when used inside fa-stack. Set size on the enclosing fa-stack instead: <fa-stack size="4x">...</fa-stack>.'
                );
            }
          }
          return (
            (FaStackItemSizeDirective.ɵfac = function(t) {
              return new (t || FaStackItemSizeDirective)();
            }),
            (FaStackItemSizeDirective.ɵdir = core.Gb({
              type: FaStackItemSizeDirective,
              selectors: [
                ['fa-icon', 'stackItemSize', ''],
                ['fa-duotone-icon', 'stackItemSize', '']
              ],
              inputs: { stackItemSize: 'stackItemSize', size: 'size' },
              features: [core.vb]
            })),
            FaStackItemSizeDirective
          );
        })(),
        angular_fontawesome_FaIconComponent = (() => {
          class FaIconComponent {
            constructor(sanitizer, config, iconLibrary, stackItem) {
              (this.sanitizer = sanitizer),
                (this.config = config),
                (this.iconLibrary = iconLibrary),
                (this.stackItem = stackItem),
                (this.classes = []);
            }
            get iconProp() {
              return this.icon;
            }
            set iconProp(value) {
              this.icon = value;
            }
            ngOnChanges(changes) {
              if (null != this.icon) {
                if (changes) {
                  const iconDefinition = this.findIconDefinition(this.icon);
                  if (null != iconDefinition) {
                    const params = this.buildParams();
                    this.renderIcon(iconDefinition, params);
                  }
                }
              } else
                console.error(
                  'FontAwesome: Property `icon` is required for `fa-icon`/`fa-duotone-icon` components. This warning will become a hard error in 0.6.0.'
                );
            }
            render() {
              this.ngOnChanges({});
            }
            findIconDefinition(i) {
              const lookup = ((iconSpec, defaultPrefix) => {
                return void 0 !== (i = iconSpec).prefix && void 0 !== i.iconName
                  ? iconSpec
                  : Array.isArray(iconSpec) && 2 === iconSpec.length
                  ? { prefix: iconSpec[0], iconName: iconSpec[1] }
                  : 'string' == typeof iconSpec
                  ? { prefix: defaultPrefix, iconName: iconSpec }
                  : void 0;
                var i;
              })(i, this.config.defaultPrefix);
              if ('icon' in lookup) return lookup;
              const definition = this.iconLibrary.getIconDefinition(
                lookup.prefix,
                lookup.iconName
              );
              if (null != definition) return definition;
              const globalDefinition = findIconDefinition(lookup);
              if (null != globalDefinition) {
                const message =
                  'Global icon library is deprecated. Consult https://github.com/FortAwesome/angular-fontawesome/blob/master/UPGRADING.md for the migration instructions.';
                if ('unset' === this.config.globalLibrary)
                  console.error('FontAwesome: ' + message);
                else if (!this.config.globalLibrary) throw new Error(message);
                return globalDefinition;
              }
              var iconSpec;
              return (
                (iconSpec = lookup),
                console.error(
                  `FontAwesome: Could not find icon with iconName=${iconSpec.iconName} and prefix=${iconSpec.prefix}. This warning will become a hard error in 0.6.0.`
                ),
                null
              );
            }
            buildParams() {
              const classOpts = {
                  flip: this.flip,
                  spin: this.spin,
                  pulse: this.pulse,
                  border: this.border,
                  inverse: this.inverse,
                  listItem: this.listItem,
                  size: this.size || null,
                  pull: this.pull || null,
                  rotate: this.rotate || null,
                  fixedWidth: this.fixedWidth,
                  stackItemSize:
                    null != this.stackItem ? this.stackItem.stackItemSize : null
                },
                parsedTransform =
                  'string' == typeof this.transform
                    ? (function(transformString) {
                        var transform = {
                          size: 16,
                          x: 0,
                          y: 0,
                          flipX: !1,
                          flipY: !1,
                          rotate: 0
                        };
                        return transformString
                          ? transformString
                              .toLowerCase()
                              .split(' ')
                              .reduce(function(acc, n) {
                                var parts = n.toLowerCase().split('-'),
                                  first = parts[0],
                                  rest = parts.slice(1).join('-');
                                if (first && 'h' === rest)
                                  return (acc.flipX = !0), acc;
                                if (first && 'v' === rest)
                                  return (acc.flipY = !0), acc;
                                if (((rest = parseFloat(rest)), isNaN(rest)))
                                  return acc;
                                switch (first) {
                                  case 'grow':
                                    acc.size = acc.size + rest;
                                    break;
                                  case 'shrink':
                                    acc.size = acc.size - rest;
                                    break;
                                  case 'left':
                                    acc.x = acc.x - rest;
                                    break;
                                  case 'right':
                                    acc.x = acc.x + rest;
                                    break;
                                  case 'up':
                                    acc.y = acc.y - rest;
                                    break;
                                  case 'down':
                                    acc.y = acc.y + rest;
                                    break;
                                  case 'rotate':
                                    acc.rotate = acc.rotate + rest;
                                }
                                return acc;
                              }, transform)
                          : transform;
                      })(this.transform)
                    : this.transform;
              return {
                title: this.title,
                transform: parsedTransform,
                classes: [...faClassList(classOpts), ...this.classes],
                mask:
                  null != this.mask ? this.findIconDefinition(this.mask) : null,
                styles: null != this.styles ? this.styles : {},
                symbol: this.symbol,
                attributes: { role: this.a11yRole }
              };
            }
            renderIcon(definition, params) {
              const renderedIcon = icon(definition, params);
              this.renderedIconHTML = this.sanitizer.bypassSecurityTrustHtml(
                renderedIcon.html.join('\n')
              );
            }
          }
          return (
            (FaIconComponent.ɵfac = function(t) {
              return new (t || FaIconComponent)(
                core.Lb(platform_browser.b),
                core.Lb(angular_fontawesome_FaConfig),
                core.Lb(angular_fontawesome_FaIconLibrary),
                core.Lb(angular_fontawesome_FaStackItemSizeDirective, 8)
              );
            }),
            (FaIconComponent.ɵcmp = core.Fb({
              type: FaIconComponent,
              selectors: [['fa-icon']],
              hostAttrs: [1, 'ng-fa-icon'],
              hostVars: 2,
              hostBindings: function(rf, ctx) {
                2 & rf &&
                  (core.Tb('innerHTML', ctx.renderedIconHTML, core.wc),
                  core.yb('title', ctx.title));
              },
              inputs: {
                classes: 'classes',
                icon: 'icon',
                title: 'title',
                spin: 'spin',
                pulse: 'pulse',
                mask: 'mask',
                styles: 'styles',
                flip: 'flip',
                size: 'size',
                pull: 'pull',
                border: 'border',
                inverse: 'inverse',
                symbol: 'symbol',
                listItem: 'listItem',
                rotate: 'rotate',
                fixedWidth: 'fixedWidth',
                transform: 'transform',
                a11yRole: 'a11yRole'
              },
              features: [core.vb],
              decls: 0,
              vars: 0,
              template: function(rf, ctx) {},
              encapsulation: 2
            })),
            FaIconComponent
          );
        })(),
        angular_fontawesome_FontAwesomeModule = (() => {
          class FontAwesomeModule {}
          return (
            (FontAwesomeModule.ɵmod = core.Jb({ type: FontAwesomeModule })),
            (FontAwesomeModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || FontAwesomeModule)();
              }
            })),
            FontAwesomeModule
          );
        })();
    },
    '6VoE': function(module, exports, __webpack_require__) {
      var wellKnownSymbol = __webpack_require__('tiKp'),
        Iterators = __webpack_require__('P4y1'),
        ITERATOR = wellKnownSymbol('iterator'),
        ArrayPrototype = Array.prototype;
      module.exports = function(it) {
        return (
          void 0 !== it &&
          (Iterators.Array === it || ArrayPrototype[ITERATOR] === it)
        );
      };
    },
    '7o/Q': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return Subscriber;
      });
      var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'n6bG'
        ),
        _Observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__('gRHU'),
        _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'quSY'
        ),
        _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          '2QA8'
        ),
        _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__('2fFW'),
        _util_hostReportError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          'NJ4a'
        );
      class Subscriber extends _Subscription__WEBPACK_IMPORTED_MODULE_2__.a {
        constructor(destinationOrNext, error, complete) {
          switch (
            (super(),
            (this.syncErrorValue = null),
            (this.syncErrorThrown = !1),
            (this.syncErrorThrowable = !1),
            (this.isStopped = !1),
            arguments.length)
          ) {
            case 0:
              this.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__.a;
              break;
            case 1:
              if (!destinationOrNext) {
                this.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__.a;
                break;
              }
              if ('object' == typeof destinationOrNext) {
                destinationOrNext instanceof Subscriber
                  ? ((this.syncErrorThrowable =
                      destinationOrNext.syncErrorThrowable),
                    (this.destination = destinationOrNext),
                    destinationOrNext.add(this))
                  : ((this.syncErrorThrowable = !0),
                    (this.destination = new SafeSubscriber(
                      this,
                      destinationOrNext
                    )));
                break;
              }
            default:
              (this.syncErrorThrowable = !0),
                (this.destination = new SafeSubscriber(
                  this,
                  destinationOrNext,
                  error,
                  complete
                ));
          }
        }
        [_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_3__.a]() {
          return this;
        }
        static create(next, error, complete) {
          const subscriber = new Subscriber(next, error, complete);
          return (subscriber.syncErrorThrowable = !1), subscriber;
        }
        next(value) {
          this.isStopped || this._next(value);
        }
        error(err) {
          this.isStopped || ((this.isStopped = !0), this._error(err));
        }
        complete() {
          this.isStopped || ((this.isStopped = !0), this._complete());
        }
        unsubscribe() {
          this.closed || ((this.isStopped = !0), super.unsubscribe());
        }
        _next(value) {
          this.destination.next(value);
        }
        _error(err) {
          this.destination.error(err), this.unsubscribe();
        }
        _complete() {
          this.destination.complete(), this.unsubscribe();
        }
        _unsubscribeAndRecycle() {
          const { _parentOrParents: _parentOrParents } = this;
          return (
            (this._parentOrParents = null),
            this.unsubscribe(),
            (this.closed = !1),
            (this.isStopped = !1),
            (this._parentOrParents = _parentOrParents),
            this
          );
        }
      }
      class SafeSubscriber extends Subscriber {
        constructor(_parentSubscriber, observerOrNext, error, complete) {
          let next;
          super(), (this._parentSubscriber = _parentSubscriber);
          let context = this;
          Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.a)(
            observerOrNext
          )
            ? (next = observerOrNext)
            : observerOrNext &&
              ((next = observerOrNext.next),
              (error = observerOrNext.error),
              (complete = observerOrNext.complete),
              observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_1__.a &&
                ((context = Object.create(observerOrNext)),
                Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.a)(
                  context.unsubscribe
                ) && this.add(context.unsubscribe.bind(context)),
                (context.unsubscribe = this.unsubscribe.bind(this)))),
            (this._context = context),
            (this._next = next),
            (this._error = error),
            (this._complete = complete);
        }
        next(value) {
          if (!this.isStopped && this._next) {
            const { _parentSubscriber: _parentSubscriber } = this;
            _config__WEBPACK_IMPORTED_MODULE_4__.a
              .useDeprecatedSynchronousErrorHandling &&
            _parentSubscriber.syncErrorThrowable
              ? this.__tryOrSetError(_parentSubscriber, this._next, value) &&
                this.unsubscribe()
              : this.__tryOrUnsub(this._next, value);
          }
        }
        error(err) {
          if (!this.isStopped) {
            const { _parentSubscriber: _parentSubscriber } = this,
              {
                useDeprecatedSynchronousErrorHandling: useDeprecatedSynchronousErrorHandling
              } = _config__WEBPACK_IMPORTED_MODULE_4__.a;
            if (this._error)
              useDeprecatedSynchronousErrorHandling &&
              _parentSubscriber.syncErrorThrowable
                ? (this.__tryOrSetError(_parentSubscriber, this._error, err),
                  this.unsubscribe())
                : (this.__tryOrUnsub(this._error, err), this.unsubscribe());
            else if (_parentSubscriber.syncErrorThrowable)
              useDeprecatedSynchronousErrorHandling
                ? ((_parentSubscriber.syncErrorValue = err),
                  (_parentSubscriber.syncErrorThrown = !0))
                : Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__.a)(
                    err
                  ),
                this.unsubscribe();
            else {
              if ((this.unsubscribe(), useDeprecatedSynchronousErrorHandling))
                throw err;
              Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__.a)(err);
            }
          }
        }
        complete() {
          if (!this.isStopped) {
            const { _parentSubscriber: _parentSubscriber } = this;
            if (this._complete) {
              const wrappedComplete = () => this._complete.call(this._context);
              _config__WEBPACK_IMPORTED_MODULE_4__.a
                .useDeprecatedSynchronousErrorHandling &&
              _parentSubscriber.syncErrorThrowable
                ? (this.__tryOrSetError(_parentSubscriber, wrappedComplete),
                  this.unsubscribe())
                : (this.__tryOrUnsub(wrappedComplete), this.unsubscribe());
            } else this.unsubscribe();
          }
        }
        __tryOrUnsub(fn, value) {
          try {
            fn.call(this._context, value);
          } catch (err) {
            if (
              (this.unsubscribe(),
              _config__WEBPACK_IMPORTED_MODULE_4__.a
                .useDeprecatedSynchronousErrorHandling)
            )
              throw err;
            Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__.a)(err);
          }
        }
        __tryOrSetError(parent, fn, value) {
          if (
            !_config__WEBPACK_IMPORTED_MODULE_4__.a
              .useDeprecatedSynchronousErrorHandling
          )
            throw new Error('bad call');
          try {
            fn.call(this._context, value);
          } catch (err) {
            return _config__WEBPACK_IMPORTED_MODULE_4__.a
              .useDeprecatedSynchronousErrorHandling
              ? ((parent.syncErrorValue = err),
                (parent.syncErrorThrown = !0),
                !0)
              : (Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__.a)(
                  err
                ),
                !0);
          }
          return !1;
        }
        _unsubscribe() {
          const { _parentSubscriber: _parentSubscriber } = this;
          (this._context = null),
            (this._parentSubscriber = null),
            _parentSubscriber.unsubscribe();
        }
      }
    },
    '8YOa': function(module, exports, __webpack_require__) {
      var hiddenKeys = __webpack_require__('0BK2'),
        isObject = __webpack_require__('hh1v'),
        has = __webpack_require__('UTVS'),
        defineProperty = __webpack_require__('m/L8').f,
        uid = __webpack_require__('kOOl'),
        FREEZING = __webpack_require__('uy83'),
        METADATA = uid('meta'),
        id = 0,
        isExtensible =
          Object.isExtensible ||
          function() {
            return !0;
          },
        setMetadata = function(it) {
          defineProperty(it, METADATA, {
            value: { objectID: 'O' + ++id, weakData: {} }
          });
        },
        meta = (module.exports = {
          REQUIRED: !1,
          fastKey: function(it, create) {
            if (!isObject(it))
              return 'symbol' == typeof it
                ? it
                : ('string' == typeof it ? 'S' : 'P') + it;
            if (!has(it, METADATA)) {
              if (!isExtensible(it)) return 'F';
              if (!create) return 'E';
              setMetadata(it);
            }
            return it[METADATA].objectID;
          },
          getWeakData: function(it, create) {
            if (!has(it, METADATA)) {
              if (!isExtensible(it)) return !0;
              if (!create) return !1;
              setMetadata(it);
            }
            return it[METADATA].weakData;
          },
          onFreeze: function(it) {
            return (
              FREEZING &&
                meta.REQUIRED &&
                isExtensible(it) &&
                !has(it, METADATA) &&
                setMetadata(it),
              it
            );
          }
        });
      hiddenKeys[METADATA] = !0;
    },
    '8mtn': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return FeatherComponent;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return FeatherModule;
        });
      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        'fXoL'
      );
      const _c0 = ['*'];
      class Icons {
        constructor(icons) {
          this.icons = icons;
        }
      }
      let FeatherComponent = (() => {
        let FeatherComponent = class {
          constructor(elem, changeDetector, icons) {
            (this.elem = elem),
              (this.changeDetector = changeDetector),
              (this.icons = icons);
          }
          ngOnChanges(changes) {
            const svg =
              Object.assign({}, ...this.icons)[
                ((str = changes.name.currentValue),
                str
                  .toLowerCase()
                  .replace(/(?:^\w|[A-Z]|\b\w)/g, firstLetter =>
                    firstLetter.toUpperCase()
                  )
                  .replace(/[-_]/g, ''))
              ] || '';
            var str;
            svg ||
              console.warn(
                `Icon not found: ${changes.name.currentValue}\nRefer to documentation on https://github.com/michaelbazos/angular-feather`
              ),
              (this.elem.nativeElement.innerHTML = svg),
              this.changeDetector.markForCheck();
          }
        };
        return (
          (FeatherComponent.ɵfac = function(t) {
            return new (t || FeatherComponent)(
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.l
              ),
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.h
              ),
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(Icons)
            );
          }),
          (FeatherComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Fb(
            {
              type: FeatherComponent,
              selectors: [['i-feather'], ['feather-icon']],
              inputs: { name: 'name' },
              features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb],
              ngContentSelectors: _c0,
              decls: 2,
              vars: 0,
              template: function(rf, ctx) {
                1 & rf &&
                  (_angular_core__WEBPACK_IMPORTED_MODULE_0__.jc(),
                  _angular_core__WEBPACK_IMPORTED_MODULE_0__.ic(0),
                  _angular_core__WEBPACK_IMPORTED_MODULE_0__.Fc(1, '\n'));
              },
              styles: [
                '[_nghost-%COMP%]{display:inline-block;width:24px;height:24px;fill:none;stroke:currentColor;stroke-width:2px;stroke-linecap:round;stroke-linejoin:round}'
              ]
            }
          )),
          FeatherComponent
        );
      })();
      var FeatherModule_1;
      let FeatherModule = (() => {
        let FeatherModule = (FeatherModule_1 = class {
          constructor(icons) {
            if (((this.icons = icons), !this.icons))
              throw new Error(
                "No icon provided. Make sure to use 'FeatherModule.pick({ ... })' when importing the module\nRefer to documentation on https://github.com/michaelbazos/angular-feather"
              );
          }
          static pick(icons) {
            return {
              ngModule: FeatherModule_1,
              providers: [{ provide: Icons, multi: !0, useValue: icons }]
            };
          }
        });
        return (
          (FeatherModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb({
            type: FeatherModule
          })),
          (FeatherModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ib({
            factory: function(t) {
              return new (t || FeatherModule)(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(Icons, 8)
              );
            }
          })),
          FeatherModule
        );
      })();
    },
    '8ynp': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return navbar_default_component_NavbarDefaultComponent;
      });
      var index_es = __webpack_require__('wHSu'),
        core = __webpack_require__('ey9i'),
        fesm2015_core = __webpack_require__('fXoL'),
        ngx_translate_core = __webpack_require__('sYmb'),
        ng_bootstrap = __webpack_require__('1kSV'),
        common = __webpack_require__('ofXK');
      function NavbarShellComponent_img_15_Template(rf, ctx) {
        1 & rf && fesm2015_core.Mb(0, 'img', 11);
      }
      function NavbarShellComponent_ng_template_17_Template(rf, ctx) {
        1 & rf &&
          (fesm2015_core.Fc(0, '\n        '),
          fesm2015_core.Mb(1, 'img', 12),
          fesm2015_core.Fc(2, '\n        '),
          fesm2015_core.Mb(3, 'img', 13),
          fesm2015_core.Fc(4, '\n      '));
      }
      const _c0 = function(a0, a1, a2) {
          return {
            'navbar-expanded': a0,
            'navbar-sticky': a1,
            'dark-link': a2
          };
        },
        _c1 = ['*'];
      let navbar_shell_component_NavbarShellComponent = (() => {
        class NavbarShellComponent {
          constructor() {}
          handleScroll() {
            const windowScroll = window.pageYOffset;
            this.navbarSticky = windowScroll >= 90;
          }
          ngOnInit() {}
          toggleNavbar() {
            this.navbarExpanded = !this.navbarExpanded;
          }
        }
        return (
          (NavbarShellComponent.ɵfac = function(t) {
            return new (t || NavbarShellComponent)();
          }),
          (NavbarShellComponent.ɵcmp = fesm2015_core.Fb({
            type: NavbarShellComponent,
            selectors: [['dc-navbar-shell']],
            hostBindings: function(rf, ctx) {
              1 & rf &&
                fesm2015_core.bc(
                  'scroll',
                  function($event) {
                    return ctx.handleScroll($event);
                  },
                  !1,
                  fesm2015_core.uc
                );
            },
            inputs: {
              useOnlyDarkLogo: 'useOnlyDarkLogo',
              darkLinks: 'darkLinks'
            },
            ngContentSelectors: _c1,
            decls: 36,
            vars: 7,
            consts: [
              [
                1,
                'navbar',
                'navbar-expand-md',
                'navigation',
                'sidebar-left',
                'fixed-top',
                3,
                'ngClass'
              ],
              [1, 'container'],
              ['type', 'button', 1, 'navbar-toggler', 3, 'click'],
              [1, 'icon-bar'],
              ['href', '#main', 1, 'navbar-brand'],
              [
                'src',
                'assets/img/logo.png',
                'alt',
                'EveryThink',
                'class',
                'logo logo-sticky',
                4,
                'ngIf',
                'ngIfElse'
              ],
              ['logos', ''],
              [1, 'collapse', 'navbar-collapse', 'ml-auto'],
              [1, 'sidebar-brand'],
              ['href', '#main'],
              [
                'src',
                'assets/img/logo.png',
                'alt',
                'EveryThink Toolbox',
                1,
                'logo'
              ],
              [
                'src',
                'assets/img/logo.png',
                'alt',
                'EveryThink',
                1,
                'logo',
                'logo-sticky'
              ],
              [
                'src',
                'assets/img/logo.png',
                'alt',
                'EveryThink',
                1,
                'logo',
                'logo-sticky',
                'd-block',
                'd-md-none'
              ],
              [
                'src',
                'assets/img/logo-light.png',
                'alt',
                'EveryThink',
                1,
                'logo',
                'd-none',
                'd-md-block'
              ]
            ],
            template: function(rf, ctx) {
              if (
                (1 & rf &&
                  (fesm2015_core.jc(),
                  fesm2015_core.Qb(0, 'nav', 0),
                  fesm2015_core.Fc(1, '\n  '),
                  fesm2015_core.Qb(2, 'div', 1),
                  fesm2015_core.Fc(3, '\n    '),
                  fesm2015_core.Qb(4, 'button', 2),
                  fesm2015_core.bc('click', function() {
                    return ctx.toggleNavbar();
                  }),
                  fesm2015_core.Fc(5, '\n      '),
                  fesm2015_core.Mb(6, 'span', 3),
                  fesm2015_core.Fc(7, '\n      '),
                  fesm2015_core.Mb(8, 'span', 3),
                  fesm2015_core.Fc(9, '\n      '),
                  fesm2015_core.Mb(10, 'span', 3),
                  fesm2015_core.Fc(11, '\n    '),
                  fesm2015_core.Pb(),
                  fesm2015_core.Fc(12, '\n\n    '),
                  fesm2015_core.Qb(13, 'a', 4),
                  fesm2015_core.Fc(14, '\n      '),
                  fesm2015_core.Dc(
                    15,
                    NavbarShellComponent_img_15_Template,
                    1,
                    0,
                    'img',
                    5
                  ),
                  fesm2015_core.Fc(16, '\n      '),
                  fesm2015_core.Dc(
                    17,
                    NavbarShellComponent_ng_template_17_Template,
                    5,
                    0,
                    'ng-template',
                    null,
                    6,
                    fesm2015_core.Ec
                  ),
                  fesm2015_core.Fc(19, '\n    '),
                  fesm2015_core.Pb(),
                  fesm2015_core.Fc(20, '\n\n    '),
                  fesm2015_core.Qb(21, 'div', 7),
                  fesm2015_core.Fc(22, '\n      '),
                  fesm2015_core.Qb(23, 'div', 8),
                  fesm2015_core.Fc(24, '\n        '),
                  fesm2015_core.Qb(25, 'a', 9),
                  fesm2015_core.Fc(26, '\n          '),
                  fesm2015_core.Mb(27, 'img', 10),
                  fesm2015_core.Fc(28, '\n        '),
                  fesm2015_core.Pb(),
                  fesm2015_core.Fc(29, '\n      '),
                  fesm2015_core.Pb(),
                  fesm2015_core.Fc(30, '\n\n      '),
                  fesm2015_core.ic(31),
                  fesm2015_core.Fc(32, '\n    '),
                  fesm2015_core.Pb(),
                  fesm2015_core.Fc(33, '\n  '),
                  fesm2015_core.Pb(),
                  fesm2015_core.Fc(34, '\n'),
                  fesm2015_core.Pb(),
                  fesm2015_core.Fc(35, '\n')),
                2 & rf)
              ) {
                const _r1 = fesm2015_core.tc(18);
                fesm2015_core.kc(
                  'ngClass',
                  fesm2015_core.qc(
                    3,
                    _c0,
                    ctx.navbarExpanded,
                    ctx.navbarSticky,
                    ctx.darkLinks
                  )
                ),
                  fesm2015_core.xb(15),
                  fesm2015_core.kc('ngIf', ctx.useOnlyDarkLogo)(
                    'ngIfElse',
                    _r1
                  );
              }
            },
            directives: [ng_bootstrap.t, common.i, common.k],
            styles: ['']
          })),
          NavbarShellComponent
        );
      })();
      var router = __webpack_require__('tyNb'),
        angular_fontawesome = __webpack_require__('6NWb');
      const navbar_default_component_c0 = function() {
          return ['/drones'];
        },
        navbar_default_component_c1 = function() {
          return ['/ai-agents'];
        },
        _c2 = function() {
          return ['/processes'];
        },
        _c3 = function(a0) {
          return { 'ml-md-auto': a0 };
        };
      let navbar_default_component_NavbarDefaultComponent = (() => {
        class NavbarDefaultComponent {
          constructor(i18nService, translate) {
            (this.i18nService = i18nService),
              (this.translate = translate),
              (this.signInAlt = index_es.s),
              (this.userPlus = index_es.v);
          }
          ngOnInit() {}
          setLanguage(lang) {
            this.i18nService.language = lang;
          }
          isRightPositioned() {
            return 'right' === this.position;
          }
        }
        return (
          (NavbarDefaultComponent.ɵfac = function(t) {
            return new (t || NavbarDefaultComponent)(
              fesm2015_core.Lb(core.a),
              fesm2015_core.Lb(ngx_translate_core.c)
            );
          }),
          (NavbarDefaultComponent.ɵcmp = fesm2015_core.Fb({
            type: NavbarDefaultComponent,
            selectors: [['dc-navbar-default']],
            inputs: {
              useOnlyDarkLogo: 'useOnlyDarkLogo',
              darkLinks: 'darkLinks',
              position: 'position'
            },
            decls: 115,
            vars: 56,
            consts: [
              [3, 'darkLinks', 'useOnlyDarkLogo'],
              [1, 'nav', 'navbar-nav'],
              [1, 'nav-item'],
              [1, 'nav-link', 3, 'routerLink'],
              [
                'href',
                'https://api.whatsapp.com/send?phone=5491164616122&text=i%20want%20to%20know%20more%20about%20defagent.ai',
                1,
                'nav-link'
              ],
              [
                'ngbDropdown',
                '',
                'placement',
                'bottom left right',
                1,
                'nav-item',
                'dropdown',
                'mega'
              ],
              [
                'ngbDropdownToggle',
                '',
                'href',
                'javascript:;',
                1,
                'nav-link',
                'dropdown-toggle'
              ],
              ['ngbDropdownMenu', '', 1, 'dropdown-menu', 'p-3'],
              [1, 'row'],
              [1, 'col-md-4'],
              [1, 'dropdown-heading', 'bold', 'mt-0', 'pt-0'],
              [1, 'dropdown-item', 3, 'routerLink'],
              [
                'ngbDropdown',
                '',
                'placement',
                'bottom-right',
                1,
                'nav-item',
                'dropdown'
              ],
              [
                'ngbDropdownMenu',
                '',
                1,
                'dropdown-menu',
                'dropdown-menu-right'
              ],
              [1, 'dropdown-item', 3, 'click'],
              [
                1,
                'nav',
                'navbar-nav',
                'justify-content-center',
                'mt-4',
                'mt-md-0',
                'flex-row',
                3,
                'ngClass'
              ],
              [
                'href',
                'https://everythink.ai/app/#/sessions/signin',
                1,
                'btn',
                'btn-rounded',
                'btn-outline',
                'mr-3',
                'px-3'
              ],
              [1, 'd-none', 'd-md-inline', 'mr-md-0', 'mr-lg-2', 3, 'icon'],
              [1, 'd-md-none', 'd-lg-inline'],
              [
                'href',
                'https://everythink.ai/app/#/sessions/signup',
                1,
                'btn',
                'btn-rounded',
                'btn-solid',
                'px-3'
              ]
            ],
            template: function(rf, ctx) {
              1 & rf &&
                (fesm2015_core.Qb(0, 'dc-navbar-shell', 0),
                fesm2015_core.Fc(1, '\n  '),
                fesm2015_core.Qb(2, 'ul', 1),
                fesm2015_core.Fc(3, '\n    '),
                fesm2015_core.Qb(4, 'li', 2),
                fesm2015_core.Fc(5, '\n      '),
                fesm2015_core.Qb(6, 'a', 3),
                fesm2015_core.Fc(7),
                fesm2015_core.gc(8, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(9, '\n    '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(10, '\n    '),
                fesm2015_core.Fc(11, '\n    '),
                fesm2015_core.Qb(12, 'li', 2),
                fesm2015_core.Fc(13, '\n      '),
                fesm2015_core.Qb(14, 'a', 4),
                fesm2015_core.Fc(15),
                fesm2015_core.gc(16, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(17, '\n    '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(18, '\n\n    '),
                fesm2015_core.Qb(19, 'li', 5),
                fesm2015_core.Fc(20, '\n      '),
                fesm2015_core.Qb(21, 'a', 6),
                fesm2015_core.Fc(22),
                fesm2015_core.gc(23, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(24, '\n      '),
                fesm2015_core.Qb(25, 'div', 7),
                fesm2015_core.Fc(26, '\n        '),
                fesm2015_core.Qb(27, 'div', 8),
                fesm2015_core.Fc(28, '\n          '),
                fesm2015_core.Qb(29, 'div', 9),
                fesm2015_core.Fc(30, '\n            '),
                fesm2015_core.Qb(31, 'p', 10),
                fesm2015_core.Fc(32),
                fesm2015_core.gc(33, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(34, '\n            '),
                fesm2015_core.Qb(35, 'a', 11),
                fesm2015_core.Fc(36),
                fesm2015_core.gc(37, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(38, '\n            '),
                fesm2015_core.Qb(39, 'a', 11),
                fesm2015_core.Fc(40),
                fesm2015_core.gc(41, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(42, '\n            '),
                fesm2015_core.Fc(43, '\n          '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(44, '\n\n          '),
                fesm2015_core.Qb(45, 'div', 9),
                fesm2015_core.Fc(46, '\n            '),
                fesm2015_core.Qb(47, 'p', 10),
                fesm2015_core.Fc(48),
                fesm2015_core.gc(49, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(50, '\n            '),
                fesm2015_core.Qb(51, 'a', 11),
                fesm2015_core.Fc(52),
                fesm2015_core.gc(53, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(54, '\n            '),
                fesm2015_core.Fc(55, '\n            '),
                fesm2015_core.Fc(56, '\n          '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(57, '\n          '),
                fesm2015_core.Fc(58, '\n          '),
                fesm2015_core.Fc(59, '\n          '),
                fesm2015_core.Fc(60, '\n          '),
                fesm2015_core.Fc(61, '\n\n          '),
                fesm2015_core.Qb(62, 'div', 9),
                fesm2015_core.Fc(63, '\n            '),
                fesm2015_core.Fc(64, '\n            '),
                fesm2015_core.Fc(65, '\n            '),
                fesm2015_core.Fc(66, '\n          '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(67, '\n        '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(68, '\n      '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(69, '\n    '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(70, '\n\n    '),
                fesm2015_core.Fc(71, '\n\n    '),
                fesm2015_core.Fc(72, '\n    '),
                fesm2015_core.Qb(73, 'li', 12),
                fesm2015_core.Fc(74, '\n      '),
                fesm2015_core.Qb(75, 'a', 6),
                fesm2015_core.Fc(76),
                fesm2015_core.gc(77, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(78, '\n      '),
                fesm2015_core.Qb(79, 'div', 13),
                fesm2015_core.Fc(80, '\n        '),
                fesm2015_core.Qb(81, 'a', 14),
                fesm2015_core.bc('click', function() {
                  return ctx.setLanguage('en-US');
                }),
                fesm2015_core.Fc(82),
                fesm2015_core.gc(83, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(84, '\n        '),
                fesm2015_core.Qb(85, 'a', 14),
                fesm2015_core.bc('click', function() {
                  return ctx.setLanguage('es');
                }),
                fesm2015_core.Fc(86),
                fesm2015_core.gc(87, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(88, '\n      '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(89, '\n    '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(90, '\n    '),
                fesm2015_core.Fc(91, '\n  '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(92, '\n\n  '),
                fesm2015_core.Qb(93, 'nav', 15),
                fesm2015_core.Fc(94, '\n    '),
                fesm2015_core.Qb(95, 'a', 16),
                fesm2015_core.Fc(96, '\n      '),
                fesm2015_core.Mb(97, 'fa-icon', 17),
                fesm2015_core.Fc(98, '\n      '),
                fesm2015_core.Qb(99, 'span', 18),
                fesm2015_core.Fc(100),
                fesm2015_core.gc(101, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(102, '\n    '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(103, '\n    '),
                fesm2015_core.Qb(104, 'a', 19),
                fesm2015_core.Fc(105, '\n      '),
                fesm2015_core.Mb(106, 'fa-icon', 17),
                fesm2015_core.Fc(107, '\n      '),
                fesm2015_core.Qb(108, 'span', 18),
                fesm2015_core.Fc(109),
                fesm2015_core.gc(110, 'translate'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(111, '\n    '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(112, '\n  '),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(113, '\n'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(114, '\n')),
                2 & rf &&
                  (fesm2015_core.kc('darkLinks', ctx.darkLinks)(
                    'useOnlyDarkLogo',
                    !!ctx.darkLinks || ctx.useOnlyDarkLogo
                  ),
                  fesm2015_core.xb(2),
                  fesm2015_core.Db('ml-auto', ctx.isRightPositioned()),
                  fesm2015_core.xb(4),
                  fesm2015_core.kc(
                    'routerLink',
                    fesm2015_core.nc(50, navbar_default_component_c0)
                  ),
                  fesm2015_core.xb(1),
                  fesm2015_core.Gc(
                    fesm2015_core.hc(8, 24, 'NAVBAR.DEFAULT.HOME')
                  ),
                  fesm2015_core.xb(8),
                  fesm2015_core.Gc(
                    fesm2015_core.hc(16, 26, 'NAVBAR.DEFAULT.CONTACT')
                  ),
                  fesm2015_core.xb(7),
                  fesm2015_core.Gc(
                    fesm2015_core.hc(23, 28, 'NAVBAR.DEFAULT.DEMOS')
                  ),
                  fesm2015_core.xb(10),
                  fesm2015_core.Hc(
                    '\n              ',
                    fesm2015_core.hc(33, 30, 'NAVBAR.DEFAULT.COMPANY'),
                    '\n            '
                  ),
                  fesm2015_core.xb(3),
                  fesm2015_core.kc(
                    'routerLink',
                    fesm2015_core.nc(51, navbar_default_component_c1)
                  ),
                  fesm2015_core.xb(1),
                  fesm2015_core.Gc(
                    fesm2015_core.hc(37, 32, 'NAVBAR.DEFAULT.HUMAN_RESOURCE')
                  ),
                  fesm2015_core.xb(3),
                  fesm2015_core.kc('routerLink', fesm2015_core.nc(52, _c2)),
                  fesm2015_core.xb(1),
                  fesm2015_core.Gc(
                    fesm2015_core.hc(41, 34, 'NAVBAR.DEFAULT.SALES')
                  ),
                  fesm2015_core.xb(8),
                  fesm2015_core.Hc(
                    '\n              ',
                    fesm2015_core.hc(49, 36, 'NAVBAR.DEFAULT.MODULES'),
                    '\n            '
                  ),
                  fesm2015_core.xb(3),
                  fesm2015_core.kc(
                    'routerLink',
                    fesm2015_core.nc(53, navbar_default_component_c0)
                  ),
                  fesm2015_core.xb(1),
                  fesm2015_core.Gc(
                    fesm2015_core.hc(53, 38, 'NAVBAR.DEFAULT.CALENDAR')
                  ),
                  fesm2015_core.xb(24),
                  fesm2015_core.Gc(
                    fesm2015_core.hc(77, 40, 'NAVBAR.DEFAULT.LANGUAGE')
                  ),
                  fesm2015_core.xb(6),
                  fesm2015_core.Gc(
                    fesm2015_core.hc(83, 42, 'NAVBAR.DEFAULT.EN')
                  ),
                  fesm2015_core.xb(4),
                  fesm2015_core.Gc(
                    fesm2015_core.hc(87, 44, 'NAVBAR.DEFAULT.ES')
                  ),
                  fesm2015_core.xb(7),
                  fesm2015_core.kc(
                    'ngClass',
                    fesm2015_core.oc(54, _c3, !ctx.isRightPositioned())
                  ),
                  fesm2015_core.xb(4),
                  fesm2015_core.kc('icon', ctx.signInAlt),
                  fesm2015_core.xb(3),
                  fesm2015_core.Gc(
                    fesm2015_core.hc(101, 46, 'NAVBAR.DEFAULT.LOGIN')
                  ),
                  fesm2015_core.xb(6),
                  fesm2015_core.kc('icon', ctx.userPlus),
                  fesm2015_core.xb(3),
                  fesm2015_core.Gc(
                    fesm2015_core.hc(110, 48, 'NAVBAR.DEFAULT.SIGNUP')
                  ));
            },
            directives: [
              navbar_shell_component_NavbarShellComponent,
              router.f,
              ng_bootstrap.d,
              ng_bootstrap.g,
              ng_bootstrap.e,
              common.i,
              angular_fontawesome.a
            ],
            pipes: [ngx_translate_core.b],
            styles: ['']
          })),
          NavbarDefaultComponent
        );
      })();
    },
    '9/5/': function(module, exports) {
      var reTrim = /^\s+|\s+$/g,
        reIsBadHex = /^[-+]0x[0-9a-f]+$/i,
        reIsBinary = /^0b[01]+$/i,
        reIsOctal = /^0o[0-7]+$/i,
        freeParseInt = parseInt,
        freeGlobal =
          'object' == typeof global &&
          global &&
          global.Object === Object &&
          global,
        freeSelf =
          'object' == typeof self && self && self.Object === Object && self,
        root = freeGlobal || freeSelf || Function('return this')(),
        objectToString = Object.prototype.toString,
        nativeMax = Math.max,
        nativeMin = Math.min,
        now = function() {
          return root.Date.now();
        };
      function isObject(value) {
        var type = typeof value;
        return !!value && ('object' == type || 'function' == type);
      }
      function toNumber(value) {
        if ('number' == typeof value) return value;
        if (
          (function(value) {
            return (
              'symbol' == typeof value ||
              ((function(value) {
                return !!value && 'object' == typeof value;
              })(value) &&
                '[object Symbol]' == objectToString.call(value))
            );
          })(value)
        )
          return NaN;
        if (isObject(value)) {
          var other =
            'function' == typeof value.valueOf ? value.valueOf() : value;
          value = isObject(other) ? other + '' : other;
        }
        if ('string' != typeof value) return 0 === value ? value : +value;
        value = value.replace(reTrim, '');
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value)
          ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
          : reIsBadHex.test(value)
          ? NaN
          : +value;
      }
      module.exports = function(func, wait, options) {
        var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = !1,
          maxing = !1,
          trailing = !0;
        if ('function' != typeof func)
          throw new TypeError('Expected a function');
        function invokeFunc(time) {
          var args = lastArgs,
            thisArg = lastThis;
          return (
            (lastArgs = lastThis = void 0),
            (lastInvokeTime = time),
            (result = func.apply(thisArg, args))
          );
        }
        function leadingEdge(time) {
          return (
            (lastInvokeTime = time),
            (timerId = setTimeout(timerExpired, wait)),
            leading ? invokeFunc(time) : result
          );
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime;
          return (
            void 0 === lastCallTime ||
            timeSinceLastCall >= wait ||
            timeSinceLastCall < 0 ||
            (maxing && time - lastInvokeTime >= maxWait)
          );
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) return trailingEdge(time);
          timerId = setTimeout(
            timerExpired,
            (function(time) {
              var result = wait - (time - lastCallTime);
              return maxing
                ? nativeMin(result, maxWait - (time - lastInvokeTime))
                : result;
            })(time)
          );
        }
        function trailingEdge(time) {
          return (
            (timerId = void 0),
            trailing && lastArgs
              ? invokeFunc(time)
              : ((lastArgs = lastThis = void 0), result)
          );
        }
        function debounced() {
          var time = now(),
            isInvoking = shouldInvoke(time);
          if (
            ((lastArgs = arguments),
            (lastThis = this),
            (lastCallTime = time),
            isInvoking)
          ) {
            if (void 0 === timerId) return leadingEdge(lastCallTime);
            if (maxing)
              return (
                (timerId = setTimeout(timerExpired, wait)),
                invokeFunc(lastCallTime)
              );
          }
          return (
            void 0 === timerId && (timerId = setTimeout(timerExpired, wait)),
            result
          );
        }
        return (
          (wait = toNumber(wait) || 0),
          isObject(options) &&
            ((leading = !!options.leading),
            (maxWait = (maxing = 'maxWait' in options)
              ? nativeMax(toNumber(options.maxWait) || 0, wait)
              : maxWait),
            (trailing = 'trailing' in options ? !!options.trailing : trailing)),
          (debounced.cancel = function() {
            void 0 !== timerId && clearTimeout(timerId),
              (lastInvokeTime = 0),
              (lastArgs = lastCallTime = lastThis = timerId = void 0);
          }),
          (debounced.flush = function() {
            return void 0 === timerId ? result : trailingEdge(now());
          }),
          debounced
        );
      };
    },
    '93I0': function(module, exports, __webpack_require__) {
      var shared = __webpack_require__('VpIT'),
        uid = __webpack_require__('kOOl'),
        keys = shared('keys');
      module.exports = function(key) {
        return keys[key] || (keys[key] = uid(key));
      };
    },
    '9a8T': function(module, exports, __webpack_require__) {
      module.exports = (function(e) {
        function t(o) {
          if (n[o]) return n[o].exports;
          var i = (n[o] = { exports: {}, id: o, loaded: !1 });
          return (
            e[o].call(i.exports, i, i.exports, t), (i.loaded = !0), i.exports
          );
        }
        var n = {};
        return (t.m = e), (t.c = n), (t.p = 'dist/'), t(0);
      })([
        function(e, t, n) {
          'use strict';
          function o(e) {
            return e && e.__esModule ? e : { default: e };
          }
          var i =
              Object.assign ||
              function(e) {
                for (var t = 1; t < arguments.length; t++) {
                  var n = arguments[t];
                  for (var o in n)
                    Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
                }
                return e;
              },
            a = (o(n(1)), n(6)),
            u = o(a),
            s = o(n(7)),
            d = o(n(8)),
            p = o(n(9)),
            b = o(n(10)),
            y = o(n(11)),
            h = o(n(14)),
            w = [],
            k = !1,
            x = {
              offset: 120,
              delay: 0,
              easing: 'ease',
              duration: 400,
              disable: !1,
              once: !1,
              startEvent: 'DOMContentLoaded',
              throttleDelay: 99,
              debounceDelay: 50,
              disableMutationObserver: !1
            },
            j = function() {
              var e =
                arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
              if ((e && (k = !0), k))
                return (w = (0, y.default)(w, x)), (0, b.default)(w, x.once), w;
            },
            O = function() {
              (w = (0, h.default)()), j();
            };
          e.exports = {
            init: function(e) {
              (x = i(x, e)), (w = (0, h.default)());
              var t = document.all && !window.atob;
              return (function(e) {
                return (
                  !0 === e ||
                  ('mobile' === e && p.default.mobile()) ||
                  ('phone' === e && p.default.phone()) ||
                  ('tablet' === e && p.default.tablet()) ||
                  ('function' == typeof e && !0 === e())
                );
              })(x.disable) || t
                ? void w.forEach(function(e, t) {
                    e.node.removeAttribute('data-aos'),
                      e.node.removeAttribute('data-aos-easing'),
                      e.node.removeAttribute('data-aos-duration'),
                      e.node.removeAttribute('data-aos-delay');
                  })
                : (x.disableMutationObserver ||
                    d.default.isSupported() ||
                    (console.info(
                      '\n      aos: MutationObserver is not supported on this browser,\n      code mutations observing has been disabled.\n      You may have to call "refreshHard()" by yourself.\n    '
                    ),
                    (x.disableMutationObserver = !0)),
                  document
                    .querySelector('body')
                    .setAttribute('data-aos-easing', x.easing),
                  document
                    .querySelector('body')
                    .setAttribute('data-aos-duration', x.duration),
                  document
                    .querySelector('body')
                    .setAttribute('data-aos-delay', x.delay),
                  'DOMContentLoaded' === x.startEvent &&
                  ['complete', 'interactive'].indexOf(document.readyState) > -1
                    ? j(!0)
                    : 'load' === x.startEvent
                    ? window.addEventListener(x.startEvent, function() {
                        j(!0);
                      })
                    : document.addEventListener(x.startEvent, function() {
                        j(!0);
                      }),
                  window.addEventListener(
                    'resize',
                    (0, s.default)(j, x.debounceDelay, !0)
                  ),
                  window.addEventListener(
                    'orientationchange',
                    (0, s.default)(j, x.debounceDelay, !0)
                  ),
                  window.addEventListener(
                    'scroll',
                    (0, u.default)(function() {
                      (0, b.default)(w, x.once);
                    }, x.throttleDelay)
                  ),
                  x.disableMutationObserver || d.default.ready('[data-aos]', O),
                  w);
            },
            refresh: j,
            refreshHard: O
          };
        },
        function(e, t) {},
        ,
        ,
        ,
        ,
        function(e, t) {
          (function(t) {
            'use strict';
            function i(e) {
              var t = void 0 === e ? 'undefined' : c(e);
              return !!e && ('object' == t || 'function' == t);
            }
            function u(e) {
              if ('number' == typeof e) return e;
              if (
                (function(e) {
                  return (
                    'symbol' == (void 0 === e ? 'undefined' : c(e)) ||
                    ((function(e) {
                      return (
                        !!e && 'object' == (void 0 === e ? 'undefined' : c(e))
                      );
                    })(e) &&
                      k.call(e) == d)
                  );
                })(e)
              )
                return f;
              if (i(e)) {
                var t = 'function' == typeof e.valueOf ? e.valueOf() : e;
                e = i(t) ? t + '' : t;
              }
              if ('string' != typeof e) return 0 === e ? e : +e;
              e = e.replace(l, '');
              var n = m.test(e);
              return n || b.test(e)
                ? v(e.slice(2), n ? 2 : 8)
                : p.test(e)
                ? f
                : +e;
            }
            var c =
                'function' == typeof Symbol &&
                'symbol' == typeof Symbol.iterator
                  ? function(e) {
                      return typeof e;
                    }
                  : function(e) {
                      return e &&
                        'function' == typeof Symbol &&
                        e.constructor === Symbol &&
                        e !== Symbol.prototype
                        ? 'symbol'
                        : typeof e;
                    },
              s = 'Expected a function',
              f = NaN,
              d = '[object Symbol]',
              l = /^\s+|\s+$/g,
              p = /^[-+]0x[0-9a-f]+$/i,
              m = /^0b[01]+$/i,
              b = /^0o[0-7]+$/i,
              v = parseInt,
              y =
                'object' == (void 0 === t ? 'undefined' : c(t)) &&
                t &&
                t.Object === Object &&
                t,
              g =
                'object' ==
                  ('undefined' == typeof self ? 'undefined' : c(self)) &&
                self &&
                self.Object === Object &&
                self,
              h = y || g || Function('return this')(),
              k = Object.prototype.toString,
              x = Math.max,
              j = Math.min,
              O = function() {
                return h.Date.now();
              };
            e.exports = function(e, t, o) {
              var r = !0,
                a = !0;
              if ('function' != typeof e) throw new TypeError(s);
              return (
                i(o) &&
                  ((r = 'leading' in o ? !!o.leading : r),
                  (a = 'trailing' in o ? !!o.trailing : a)),
                (function(e, t, n) {
                  function o(t) {
                    var n = b,
                      o = v;
                    return (b = v = void 0), (k = t), (g = e.apply(o, n));
                  }
                  function r(e) {
                    return (k = e), (h = setTimeout(f, t)), M ? o(e) : g;
                  }
                  function c(e) {
                    var n = e - w;
                    return void 0 === w || n >= t || n < 0 || (S && e - k >= y);
                  }
                  function f() {
                    var e = O();
                    return c(e)
                      ? d(e)
                      : void (h = setTimeout(
                          f,
                          (function(e) {
                            var i = t - (e - w);
                            return S ? j(i, y - (e - k)) : i;
                          })(e)
                        ));
                  }
                  function d(e) {
                    return (h = void 0), _ && b ? o(e) : ((b = v = void 0), g);
                  }
                  function m() {
                    var e = O(),
                      n = c(e);
                    if (((b = arguments), (v = this), (w = e), n)) {
                      if (void 0 === h) return r(w);
                      if (S) return (h = setTimeout(f, t)), o(w);
                    }
                    return void 0 === h && (h = setTimeout(f, t)), g;
                  }
                  var b,
                    v,
                    y,
                    g,
                    h,
                    w,
                    k = 0,
                    M = !1,
                    S = !1,
                    _ = !0;
                  if ('function' != typeof e) throw new TypeError(s);
                  return (
                    (t = u(t) || 0),
                    i(n) &&
                      ((M = !!n.leading),
                      (y = (S = 'maxWait' in n) ? x(u(n.maxWait) || 0, t) : y),
                      (_ = 'trailing' in n ? !!n.trailing : _)),
                    (m.cancel = function() {
                      void 0 !== h && clearTimeout(h),
                        (k = 0),
                        (b = w = v = h = void 0);
                    }),
                    (m.flush = function() {
                      return void 0 === h ? g : d(O());
                    }),
                    m
                  );
                })(e, t, { leading: r, maxWait: t, trailing: a })
              );
            };
          }.call(
            t,
            (function() {
              return this;
            })()
          ));
        },
        function(e, t) {
          (function(t) {
            'use strict';
            function o(e) {
              var t = void 0 === e ? 'undefined' : u(e);
              return !!e && ('object' == t || 'function' == t);
            }
            function a(e) {
              if ('number' == typeof e) return e;
              if (
                (function(e) {
                  return (
                    'symbol' == (void 0 === e ? 'undefined' : u(e)) ||
                    ((function(e) {
                      return (
                        !!e && 'object' == (void 0 === e ? 'undefined' : u(e))
                      );
                    })(e) &&
                      w.call(e) == f)
                  );
                })(e)
              )
                return s;
              if (o(e)) {
                var t = 'function' == typeof e.valueOf ? e.valueOf() : e;
                e = o(t) ? t + '' : t;
              }
              if ('string' != typeof e) return 0 === e ? e : +e;
              e = e.replace(d, '');
              var n = p.test(e);
              return n || m.test(e)
                ? b(e.slice(2), n ? 2 : 8)
                : l.test(e)
                ? s
                : +e;
            }
            var u =
                'function' == typeof Symbol &&
                'symbol' == typeof Symbol.iterator
                  ? function(e) {
                      return typeof e;
                    }
                  : function(e) {
                      return e &&
                        'function' == typeof Symbol &&
                        e.constructor === Symbol &&
                        e !== Symbol.prototype
                        ? 'symbol'
                        : typeof e;
                    },
              s = NaN,
              f = '[object Symbol]',
              d = /^\s+|\s+$/g,
              l = /^[-+]0x[0-9a-f]+$/i,
              p = /^0b[01]+$/i,
              m = /^0o[0-7]+$/i,
              b = parseInt,
              v =
                'object' == (void 0 === t ? 'undefined' : u(t)) &&
                t &&
                t.Object === Object &&
                t,
              y =
                'object' ==
                  ('undefined' == typeof self ? 'undefined' : u(self)) &&
                self &&
                self.Object === Object &&
                self,
              g = v || y || Function('return this')(),
              w = Object.prototype.toString,
              k = Math.max,
              x = Math.min,
              j = function() {
                return g.Date.now();
              };
            e.exports = function(e, t, n) {
              function i(t) {
                var n = b,
                  o = v;
                return (b = v = void 0), (O = t), (g = e.apply(o, n));
              }
              function r(e) {
                return (O = e), (h = setTimeout(f, t)), M ? i(e) : g;
              }
              function s(e) {
                var n = e - w;
                return void 0 === w || n >= t || n < 0 || (S && e - O >= y);
              }
              function f() {
                var e = j();
                return s(e)
                  ? d(e)
                  : void (h = setTimeout(
                      f,
                      (function(e) {
                        var i = t - (e - w);
                        return S ? x(i, y - (e - O)) : i;
                      })(e)
                    ));
              }
              function d(e) {
                return (h = void 0), _ && b ? i(e) : ((b = v = void 0), g);
              }
              function m() {
                var e = j(),
                  n = s(e);
                if (((b = arguments), (v = this), (w = e), n)) {
                  if (void 0 === h) return r(w);
                  if (S) return (h = setTimeout(f, t)), i(w);
                }
                return void 0 === h && (h = setTimeout(f, t)), g;
              }
              var b,
                v,
                y,
                g,
                h,
                w,
                O = 0,
                M = !1,
                S = !1,
                _ = !0;
              if ('function' != typeof e)
                throw new TypeError('Expected a function');
              return (
                (t = a(t) || 0),
                o(n) &&
                  ((M = !!n.leading),
                  (y = (S = 'maxWait' in n) ? k(a(n.maxWait) || 0, t) : y),
                  (_ = 'trailing' in n ? !!n.trailing : _)),
                (m.cancel = function() {
                  void 0 !== h && clearTimeout(h),
                    (O = 0),
                    (b = w = v = h = void 0);
                }),
                (m.flush = function() {
                  return void 0 === h ? g : d(j());
                }),
                m
              );
            };
          }.call(
            t,
            (function() {
              return this;
            })()
          ));
        },
        function(e, t) {
          'use strict';
          function o() {
            return (
              window.MutationObserver ||
              window.WebKitMutationObserver ||
              window.MozMutationObserver
            );
          }
          function a(e) {
            e &&
              e.forEach(function(e) {
                var t = Array.prototype.slice.call(e.addedNodes),
                  o = Array.prototype.slice.call(e.removedNodes);
                if (
                  (function n(e) {
                    var t = void 0,
                      o = void 0;
                    for (t = 0; t < e.length; t += 1) {
                      if ((o = e[t]).dataset && o.dataset.aos) return !0;
                      if (o.children && n(o.children)) return !0;
                    }
                    return !1;
                  })(t.concat(o))
                )
                  return u();
              });
          }
          Object.defineProperty(t, '__esModule', { value: !0 });
          var u = function() {};
          t.default = {
            isSupported: function() {
              return !!o();
            },
            ready: function(e, t) {
              var n = window.document,
                r = new (o())(a);
              (u = t),
                r.observe(n.documentElement, {
                  childList: !0,
                  subtree: !0,
                  removedNodes: !0
                });
            }
          };
        },
        function(e, t) {
          'use strict';
          function o() {
            return (
              navigator.userAgent || navigator.vendor || window.opera || ''
            );
          }
          Object.defineProperty(t, '__esModule', { value: !0 });
          var i = (function() {
              function e(e, t) {
                for (var n = 0; n < t.length; n++) {
                  var o = t[n];
                  (o.enumerable = o.enumerable || !1),
                    (o.configurable = !0),
                    'value' in o && (o.writable = !0),
                    Object.defineProperty(e, o.key, o);
                }
              }
              return function(t, n, o) {
                return n && e(t.prototype, n), o && e(t, o), t;
              };
            })(),
            r = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
            a = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
            u = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i,
            c = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
            s = (function() {
              function e() {
                !(function(e, t) {
                  if (!(e instanceof t))
                    throw new TypeError('Cannot call a class as a function');
                })(this, e);
              }
              return (
                i(e, [
                  {
                    key: 'phone',
                    value: function() {
                      var e = o();
                      return !(!r.test(e) && !a.test(e.substr(0, 4)));
                    }
                  },
                  {
                    key: 'mobile',
                    value: function() {
                      var e = o();
                      return !(!u.test(e) && !c.test(e.substr(0, 4)));
                    }
                  },
                  {
                    key: 'tablet',
                    value: function() {
                      return this.mobile() && !this.phone();
                    }
                  }
                ]),
                e
              );
            })();
          t.default = new s();
        },
        function(e, t) {
          'use strict';
          Object.defineProperty(t, '__esModule', { value: !0 }),
            (t.default = function(e, t) {
              var o = window.pageYOffset,
                i = window.innerHeight;
              e.forEach(function(e, r) {
                !(function(e, t, n) {
                  var o = e.node.getAttribute('data-aos-once');
                  t > e.position
                    ? e.node.classList.add('aos-animate')
                    : void 0 !== o &&
                      ('false' === o || (!n && 'true' !== o)) &&
                      e.node.classList.remove('aos-animate');
                })(e, i + o, t);
              });
            });
        },
        function(e, t, n) {
          'use strict';
          Object.defineProperty(t, '__esModule', { value: !0 });
          var r = (function(e) {
            return e && e.__esModule ? e : { default: e };
          })(n(12));
          t.default = function(e, t) {
            return (
              e.forEach(function(e, n) {
                e.node.classList.add('aos-init'),
                  (e.position = (0, r.default)(e.node, t.offset));
              }),
              e
            );
          };
        },
        function(e, t, n) {
          'use strict';
          Object.defineProperty(t, '__esModule', { value: !0 });
          var r = (function(e) {
            return e && e.__esModule ? e : { default: e };
          })(n(13));
          t.default = function(e, t) {
            var n = 0,
              o = 0,
              i = window.innerHeight,
              a = {
                offset: e.getAttribute('data-aos-offset'),
                anchor: e.getAttribute('data-aos-anchor'),
                anchorPlacement: e.getAttribute('data-aos-anchor-placement')
              };
            switch (
              (a.offset && !isNaN(a.offset) && (o = parseInt(a.offset)),
              a.anchor &&
                document.querySelectorAll(a.anchor) &&
                (e = document.querySelectorAll(a.anchor)[0]),
              (n = (0, r.default)(e).top),
              a.anchorPlacement)
            ) {
              case 'top-bottom':
                break;
              case 'center-bottom':
                n += e.offsetHeight / 2;
                break;
              case 'bottom-bottom':
                n += e.offsetHeight;
                break;
              case 'top-center':
                n += i / 2;
                break;
              case 'bottom-center':
                n += i / 2 + e.offsetHeight;
                break;
              case 'center-center':
                n += i / 2 + e.offsetHeight / 2;
                break;
              case 'top-top':
                n += i;
                break;
              case 'bottom-top':
                n += e.offsetHeight + i;
                break;
              case 'center-top':
                n += e.offsetHeight / 2 + i;
            }
            return a.anchorPlacement || a.offset || isNaN(t) || (o = t), n + o;
          };
        },
        function(e, t) {
          'use strict';
          Object.defineProperty(t, '__esModule', { value: !0 }),
            (t.default = function(e) {
              for (
                var t = 0, n = 0;
                e && !isNaN(e.offsetLeft) && !isNaN(e.offsetTop);

              )
                (t += e.offsetLeft - ('BODY' != e.tagName ? e.scrollLeft : 0)),
                  (n += e.offsetTop - ('BODY' != e.tagName ? e.scrollTop : 0)),
                  (e = e.offsetParent);
              return { top: n, left: t };
            });
        },
        function(e, t) {
          'use strict';
          Object.defineProperty(t, '__esModule', { value: !0 }),
            (t.default = function(e) {
              return (
                (e = e || document.querySelectorAll('[data-aos]')),
                Array.prototype.map.call(e, function(e) {
                  return { node: e };
                })
              );
            });
        }
      ]);
    },
    '9d/t': function(module, exports, __webpack_require__) {
      var classofRaw = __webpack_require__('xrYK'),
        TO_STRING_TAG = __webpack_require__('tiKp')('toStringTag'),
        CORRECT_ARGUMENTS =
          'Arguments' ==
          classofRaw(
            (function() {
              return arguments;
            })()
          );
      module.exports = function(it) {
        var O, tag, result;
        return void 0 === it
          ? 'Undefined'
          : null === it
          ? 'Null'
          : 'string' ==
            typeof (tag = (function(it, key) {
              try {
                return it[key];
              } catch (error) {}
            })((O = Object(it)), TO_STRING_TAG))
          ? tag
          : CORRECT_ARGUMENTS
          ? classofRaw(O)
          : 'Object' == (result = classofRaw(O)) &&
            'function' == typeof O.callee
          ? 'Arguments'
          : result;
      };
    },
    '9ppp': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return ObjectUnsubscribedError;
      });
      const ObjectUnsubscribedError = (() => {
        function ObjectUnsubscribedErrorImpl() {
          return (
            Error.call(this),
            (this.message = 'object unsubscribed'),
            (this.name = 'ObjectUnsubscribedError'),
            this
          );
        }
        return (
          (ObjectUnsubscribedErrorImpl.prototype = Object.create(
            Error.prototype
          )),
          ObjectUnsubscribedErrorImpl
        );
      })();
    },
    'A/Ql': function(module) {
      module.exports = JSON.parse(
        '{"APP_NAME":"DefAgent","About":"About us","Hello world !":"Hello world!","Home":"Home","Logged in as":"Logged in as","Login":"Login","Logout":"Logout","Password":"Password","Password is required":"Password is required","Username":"Username","Username is required":"Username is required","Username or password incorrect.":"Username or password incorrect.","Remember me":"Remember me","Version":"Version","ACTIONS":{"FORM_REGISTER_SIMPLE_INLINE":{"CHECK_YOUR_EMAIL":"Check your email","WE_SENT_YOU_AN_EMAIL":"We sent you an email with a link to get started. You’ll be in your account in no time."},"FORM_REGISTER_COMPANY":{"NAME":"Name","EMAIL":"Email","COMPANY":"Company","SEND_MY_APPLICATION":"Send my application"}},"NAVBAR":{"DEFAULT":{"HOME":"Home","ABOUT":"About us","CONTACT":"Contact","DEMOS":"Solutions","COMPANY":"Segments","HUMAN_RESOURCE":"AI Agents","SALES":"Processes","CUSTOMER_SERVICE":"Customer Service","MODULES":"Modules","CALENDAR":"Drones","PRODUCT":"Verticals","HEALTH":"Health","DEVELOPERS":"Developers","RPA_CREATORS":"RPA Creators","SERVICES":"Marketplace","DATAFLOWS_CREATORS":"Dataflows Creators","SAAS":"Real Estate","START_UP":"Startup","FOR_STORY_TELLERS":"For StoryTellers","AWESOME_DESIGN_BLOCKS":"Awesome blocks","FOR_DEVELOPERS":"For Developers","THE_DEVELOPERS_PLACE":"The developers\' place","YOUR_BUSINESS":"your business","OUT_BEST_BET":"Our best bet is you, we can ensure you that DefAgent fit your needs.","VIEW_PLAN":"View plans","LANGUAGE":"Languaje","EN":"English","ES":"Español","LOGIN":"Login","SIGNUP":"Signup"}},"SLIDERS":{"SLIDER_CARD_PROJECTS":{"NEW_SUBSCRIBERS":"New subscribers","NEXT":"Next"},"SLIDER_START_RIGHT_WAY":{"FOR_EVERYONE":"DefAgent IAs for Professionals","EVERYTHINK_DOES_ALL":"DefAgent’s low-code platform does ALL OF THE HEAVY LIFTING by automating repetitive processes so you can focus on more complex tasks and achieve unprecedented levels of efficiency.","START_THE_RIGHT_WAY":"Start the right way","START_WITH_EVERy_THINK":"Start with DefAgent","THINKING_ABOUT_YOUR_AI_JOURNEY":"Thinking about your AI journey?","CHOOSE_THE_RIGHT_PLAN":"CHOOSE THE RIGHT PLAN"},"SLIDER_BRING_TO_LIFE":{"ADMIN_TEMPLATE_INCLUDED":"Admin dashboards included","WE_INCLUDED_A_FULLY_FUNcTIONAL":"We\'ve included a fully functional starter admin dashboards","POWER_WITH_MULIPLE_STARTER_APPS":" Powered by DefAgent","ITS_AWESOME_YOU_TO":"We have new features that you are going to love!","SIMPLE_AND_TRANSPARENT":"Simple and transparent","BRING_YOU_APPLICAION_TO_LIFE":"Bring your IAs to life","DASHCORE_INCLUDED":"DefAgent includes an outstanding starter Admin Dashboard UI Interface. With this feature you can start developing right away your applications.","CLEAN_INBOX_UI":"User friendly"},"SLIDER_ALL_IN_ONE":{"EVERYTHINK_YOU_NEED":"Everything you need - all in your hand!","REAL_TIME_SOLUTION":"Solution","STREAMLINES_PROCESSES":"Real-time","AFFORDABILLITY":"Become ultra-responsive in real-time. Create your own white-label apps. Gain valuable insights into clients, markets, and processes and achieve much more with our powerful AI-enabled tool.","SINCE_THE_NEED_FORHUMAN":"Global reach","EVERYTHINK_DOES_ALL":"Close more deals with less friction. Win more listings with greater ease. Streamline your efforts through automation and predictors. Gain a competitive edge with greater functionality and efficiency.","ALWAYS_ON_TIME":"Always on Time","UNIQUE_USER)EXPERIENCE":"Experience","A_NEW_AND_INTUITIVE_EXPERIENCE":"Unique","ESPECIALLY_WHEN_YOUR_CLIENTS_NEEDS":"Leverage DefAgent AI-driven low-code platform to streamline processes to deliver effortless, instantaneous, and much more enriching experiences for buyers, sellers, real estate agents, and everyone involved!","OUTSTANDING":"","ANALYTICS":"Outstanding","SIT_BACK_AS_YOUR":"DefAgent’s software as a service platform offers much more than just a flawless absorption and spewing of data. These ‘teachable’ IAs gather and review user interactions for analysis and iteration.","CONTINUOUSLY_CHECK_IN":"Continuously check in with your IAs for new suggestions on automating processes or ways to give better solutions to your clients and employees."}},"SCREENSHOTS":{"APP":{"APP_SCREENSHOTS":"Build your ai agents in one place and automate all the processes","A_PICTURE_IS_WORTH_A_THOUSAND_WORDS":""}},"HOME":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - AI AGENTIC PLATFORM FOR DEFENSE","KEYWORDS":"Network Search, Networks directory App Landing1"},"APP_LANDING_HEADING":{"HEADING":{"AWARDED":"Selected onto the Global Entrepreneur Programme of the British Government","HR_CONSULTIN":"DefAgent","CONSULTANT":"AI AGENTIC PLATFORM FOR DEFENSE","IAS":"With a proprietary system of AI agents, DefAgent enables you to go from idea to production-ready product, eliminating the need to find a technical cofounder or hire developers. Simply explain your business idea as you would to a human developer, and we handles the rest - product, payments, security, infrastructure, scalability, and more.","GERSTARTED":"Get Started","WHAT_YOU_GET":"What You Get"},"FEATURE_CARDS":{"WHAT_YOU_GET":"What You Get","WITH_A_SINGLE_TOOL":"Easily and quickly implements real-time solutions without need for a dedicated technology professional on staff. No other solution on the market matches our: "},"TWIN_PHONE_LEFT_LIST":{"WE_ARE_YOUR_PATH_TO_SUCCESS":"Types of ai agents in defense"},"TWIN_PHONE_LEFT_RIGHT":{"WE_HAVE_A_TON_OF_BENEFITSS":"We have tons of benefits","EVERYTHINK_DOES_ALL_OF":"DefAgent does ALL OF THE HEAVY LIFTING so you can focus on more valuable and complex tasks."},"DOWNLOAD":{"START_TODAY":"Start Today","DOWNLOAD_THE_APP":"Download The App","DOWNLOAD_EVERYTHING":"Position your business for HR success. Download DefAgent App now and get started on your AI journey! Available on Windows, Mac, iOS, and Android devices.","GET_IT_ON_THE":"Get it on","APP_STORE":"App Store","DOWNLOAD_ON":"Download on","GOOGLE_PLAY":"Google Play"}}},"DEMOS":{"HUMANRE_SOURCES":{},"SALES":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - Sales","KEYWORDS":"Network Search, Networks directory Sales"},"APP_LANDING_HEADING2":{"ALLISONE":"All is one,","INFINTY":"where infinity starts","EVERYTHINKFORSALES":"DefAgent","BETTERMARKETING":"AI-powered agents are emerging as invaluable","BETTERRESULT":"assets in the Department of Defense (DoD)","OURIAS":"Revolutionizing how we fight by streamlining work and enhancing decision-making speed. These agents excel in automating low-level, low-risk tasks, freeing warfighters to concentrate on vital, mission-critical decisions.","SUBSCRIBENOW":"Get Started"},"APP_LANDING2_TRENDING_DESIGN":{"SIMPLE_IMPLEMENTATION":"Simple implementation with exponentially positive impacts","SINCE_THE_NEED":" Human interactions are vastly reduced to give way for better workflow efficiency and better management of resources. Better cost-effectiveness!","THE_POSSIBILITIES":"The possibilities for using DefAgent for defense are everywhere and are limited only by the ingenuity of users who want to use AI agents to improve and simplify their processes."},"APP_LANDING2_FOCUS_ON_SUCCESS":{"FORGET_OBSOLETE":"Forget obsolete systems & costly investments","EVERYTHINK_DELIVERS":"DefAgent’s AI-driven software as a service will completely transform your business. Our IAs interacts directly with employees, customers, and suppliers to understand their needs, connect them with people, processes, and in real-time.","DOT_NOT_WASTE_TIME":"Help your team become more productive and profitable! Stop wasting valuable time and start getting meaningful results now!"},"APP_LANDING2_SAFETY":{"SAFETY_FIRST":"You First!","YOUR_SUCCESS_IS_OUR_SUCCESS":"Your success is our success!","EVERYTHINK_DOESALL":"DefAgent helps your team to automate routine processes, blaze through mountains of data, and can even handle more complex tasks."},"APP_LANDING2_POPPING_HIGHLIGHT":{"DISCOVER_CREATE_LOVE":"Discover. Empower. Win.","SEE_WHY_PEOPLE_LOVE_EVERTTHINK":"See why businesses and brands love DefAgent"},"APP_LANDING2_DOWNLOAD":{"START_TODAY":"Start Today","DOWNLOAD_THE_APP":"Download The App","DOWNLOAD_EVERTTHINK":"Download DefAgent App Now And Get Started On Your AI For Sales Journey! Available On Windows, Mac, iOS, And Android Devices.","GET_IT_ON_THE":"Get It On","APP_STORE":"App Store","DOWNLOAD_ON":"Download On","GOOGLE_PLAY":"Google Play"}},"CUSTOMER_SERVICE":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - Network search  ","KEYWORDS":"Network Search, Networks directory network search"},"AUTOMATE_SOCIAL_HEADING":{"EVERYTHINK_FOR_CUSTOMER_SERVICE":"DefAgent Customer Service","DONT_THINK_IT":"Don’t think it; don’t even answer, because we have it!","DRIVE_YOUR_BUSINESS_FORWARD":"Drive your business forward with managed customer care IAs in the palm of your hands!"},"AUTOMATE_SOCIAL_GET_STARTED":{"ALL_IN_ONE":"All-in-one Customer Service Solution","EVERTTHINK_YOU_NEED_IN_ONE_SOLUTION":"Get everything you need in one solution.","EVERTTHINK_YOU_NEED_IN_ONE_SOLUTION1":"","INTRODUCING":"Create effortless and consistent experiences and reduce costs with a powerful customer service automation tool.","COMMUNICATE_BETTER":"Capture communication; analyze and aggregate conversations to deliver real-time solutions, insights, and statistics with our low-code platform!","NO_CREDIT_CARD_NEEDED":"Get your AI journey started!","START_NOW":"Start Now","BY_REGISTERING":" By registering you will get 14 days of DefAgent."},"AUTOMATE_SOCIAL_WHY":{"WHY_EVERYTHINK":"Why DefAgent","OUR_MISSION_IS_TO_PROVIDE_YOU":"Our goal with the powerful DefAgent software as a service platform is the accurate automation of your entire customer service by connecting actors, processes, and devices in real-time. More so, it also provides strategy-based metrics that make it easy to measure business performance against intended goals."},"AUTOMATE_SOCIAL_AUTOMATION_SOLUTION":{"ADVANCED_CUSTOMER":"Advanced Customer Service Automation Solution","DESCRIPTION":"DefAgent IAs are poised to help brands deliver superior customer self-service experiences and overhaul engagements across digital channels. This is advanced customer service automation right in your palms!","OUR_INTELLIGENT_ASSISTANTS":""}},"DEVELOPERS":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - developer","KEYWORDS":"Network Search, Networks directory developer"},"HEADING":{"WELCOME_DREAMERS":"Welcome Dreamers!","CREATE_EMOTIONS":"Create Emotions for Smart Assistants","SHOW_VIDEO":"Show video"},"INTEGRATioNS":{"KNOW_WHAT_YOU_CAN_DO_WITH_US":"Know what you can do with Us","LEARN_MORE":"Learn more"},"TOOL":{"INTEGRATION_TOOLS":"","EASY_INTEGRATIONS":"","LOREM_IPSUM":"","LOREM_IPSUM_DOLOR":"","INTEGRATE":""}},"HEALTH":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - corporate","KEYWORDS":"Network Search, Networks directory corporate"},"CORPORATE":{"EVERYTHINK_MAKE_TREATMENT_MORE":"DefAgent makes treatment more effective, and patients safer, allowing hospitals and insurance companies to save money.","LEARN_MORE":"Learn More","80_OF_THE_CASE_ARISE":"80% of these cases arise from miscommunications during care transitions, resulting in more than 7000 deaths and 500,000 preventable injuries caused by medical errors. Not to mention the 3 out of every 10 lab tests that are reordered because the results get lost in the process. As much as 18% of hospital medical patients are readmitted within a month. All or most of these could be avoided!","DID_YOU_KNOW":"Did you know that medical errors are the third leading cause of death in the US?","HEADING":{"EVERYTHINK_FOR_HEALTH":"DefAgent Health","WELCOME_TO_THE_FUTURE":"Driving the next wave of meaningful innovation in healthcare, don’t be left behind!","WITH_THE_RIGHT_DATA":"Gain insights and leverage radically interoperable data to accelerate healthcare research, usher in a new era of treatment optimization, drug development, outcome prediction, disease diagnosis and prognosis, patient engagement, and better public health.","START_NOW":"Start now","PLANS_AND_PRICEING":"Plans & pricing"},"BUSINESS":{"LETS_DO_BUSINESS":"Let\'s get started","WHAT_EVERYTHINK_OFFERS":"What DefAgent offers"},"EVERYTHINK_IS_THE_SOLUTION":"DefAgent augments the clinician-patient experience. With this software as AIaaS tool at the fundamental of your healthcare delivery interactions, most medical errors can be prevented. The technology integrates the patients’ records in a single, highly secure place that allows for easy sharing within and outside the network, for the benefits of both patients as well as the medical staff."}},"RPACREAORS":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - online payment","KEYWORDS":"Network Search, Networks directory online payment"},"ONLINE_PAYMENT":{"HEADING":{"GO_BIG":"Go big, or back home!","CREATE_BUY":"Create, buy and sell automated processes.","WITHOUT_CODING":"- Without coding.","KNOW_MORE":"Know more","START_NOW":"Start now"},"FEATURES":{"REASONS_TO_USE_EVERYTHINK":"Reasons to use DefAgent","KNOW_WHAT_YOU_CAN_DO_WITH_US":"Know what you can do with Us"},"CUSTOMERS_MANAGEMENT":{"CREATE_SMART":"Create Smart","EXERIENCES_WITH":"Experiences with","EVERYTHINK":"DefAgent Studio","SIMPLE_IMPLEMENTATION":" Simple implementation with exponentially positive impact.","CUSTOMERSADMINISTRATION":"Customers administration."}}},"DATAFLOWS_CREATOORS":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - integration","KEYWORDS":"Network Search, Networks directory integration"},"INTEGRATION":{"HEADING":{"CREATE_EMOTIONS_FOR_SMART_ASSISTANTS":"Create Emotions for Smart Assistants","CREATE_BUY_AND_SELL":" Create, Buy and Sell data flows to train Smart Assistants for the different geolocated conversations necessary for each of the actors that participate in each network, community and channel.","JOIN_EVERY_TTHINK":"Join DefAgent"},"HOW_IT_WORK":{"KNOW_WHAT_YOU_CAN_DO_WITH_US":"Know what you can do with Us","EVERYTHINK_DOES_ALL":"DefAgent does ALL OF THE HEAVY LIFTING so you can focus on more valuable and complex tasks."},"BUILT_TECH":{"INDUSTRY_LEADING":"Industry leading","TECHNOLOGY":"technology","EVERYTHINK_STUDIO":"DefAgent Studio gives you everything you and your business  needs to build robust data flows. All without coding!","ONE_STEP_AHEAD_OF_AIS":"One step ahead of AIs","EMPOWER_THE_INTELLIGENT":"Empower the Intelligent Assistants by providing new interactions created by you, this elevating your problem solving skills in real time."},"EXTEND_CORE":{"LIMITLESS_POSSIBILITIES":"Limitless possibilities","BUILD_FAST_BUILD_MORE":"Build Fast. Build More.","USING_EVERYTHINK":"Using DefAgent Studio’s unique software for fast and fluid data flows development, you can build and deploy all data flows you need  in minutes. No scripting, programming, or technical skills required.","KNOW_MORE":"Know more","REGISTER_ACCOUNT":"Register Account"},"LATEST_PROJECTS":{"EVERYTHINK_MARKETPLACE":"DefAgent Marketplace","TAKE_A_LOOK_AT_OUR_LATEST_PROJECTS":"Take a look at our latest projects, those customer have trust in our services to bring their business to the next level!","SOMOS_PILEROS":"Somos Pileros","WE_BUILT_DATA":"We built data flows to connect entrepreneurs with volunteers and mentors more quickly and efficiently by automating the search and connection process between users, in real time."},"REGISTER":{"FILL_IN_THE_FORM":"Fill in the form","YOUR_SUCCESS_IS_OUR_SUCCESS":"Your success is our success","IF_YOU_ARE_LOOKING":"If you\'re looking to be part of DefAgent network, just fill in the form, we\'re sure we can build great things together!"},"WHY_CHOOSE_US":{"SIMPLE_IMPLEMENTATION_WITH":" Simple implementation with exponentially positive impact","SINCE_THE_NEED_FOR_HUMAN":"Since the need for human intervention is reduced and workflow efficiency is increased, the process is highly affordable.","KNOW_MORE":"Know More"}}},"SAAS":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - saas","KEYWORDS":"Network Search, Networks directory saas"},"HEADING":{"EVERYTHINK_FOR_REAL_ESTATE":"DefAgent Real Estate","YOU_AGENT_IN_YOUR_HANDS_WITHGLOBAL_REACH":"Your agent in your hands with global reach!","OUT_IAS_ARE_POISED":"Our IAs will revolutionize your real estate service delivery with process automation and AI-based innovations. Better still, it is always right there in your palms","PLANS_AND_PRICING":"Plans & pricing","START_NOW":"Start now"},"LIGHTWEIGHT_TEMPLATE":{"YOUR_SMART_PUPPETS":"Your Very Own Smart Puppets","WILL_PROVIDE_YOUR_PROSPECTS_AND_CLIENTS":"With DefAgent software as a service platform, our IAs can help become ultra-responsive in real-time; gain valuable insights into prospects, clients, markets, and processes; leverage valuable data to address clients’ needs and close more sales, achieve greater system transparency; and improve overall efficiency.","SIMLIFYING_THE_CURRENT":"","LEARN_MORE":"Learn More"},"BUILD_TO_LAST":"Built to Last","WHAT_YOU_WILL_GET_WITH_EVERTTHINK":"What You Get","GEOLOCATED_INTELLIGENT_ASSISTANTS":"Automate Your Booking Process With DefAgent Calendar And Focus Only On What Matters","DASHBORD_INCLUDED":"Dashboards included","SIMPLE_IMPLEMENTATION":"Simple implementation with exponentially positive impact","SINCE_THE_NEED_FOR_HUMAN":"Since the need for human intervention is reduced and workflow efficiency is increased, the process is highly affordable.","THE_POSSIBILITIES":"The possibilities for using DefAgent for Sales are everywhere, and only  limited to the ingenuity of users who want to utilize AI to improve their quality of life.","Learn_More":"Learn more"},"START_UP":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - Drone detection system","KEYWORDS":"Drone detection system, ai, blockchain"},"HEADING":{"DELIVERING_THE_TOOLS":"Secure Your Skies: Advanced Drone ","YOU_NEED_TO_SUCCEED":"Detection and Defense Solutions","IT_ALL_BEGINS_BY_CHOSSING":"Protecting Your Airspace with Cutting-Edge Detection, Tracking, and Mitigation Technology","TRY_IT_FREE":"Get Started!"},"WHAT_YOU_GET":{"WHAT_YOU_WILL_GET_WITH_EVERTTHINK":"What You Get","GEOLOCATED_INTELLIGENT_ASSISTANTS":"Automate Your Booking Process With DefAgent Calendar And Focus Only On What Matters","BUSINESS_TITLE":"Real-Time Detection","PAYMENTS_TITLE":"Accurate Tracking","SCHEDULES_TITLE":"Comprehensive Threat Analysis","SITE_TITLE":"24/7 Airspace Monitoring","BUSINESS_DESC":"Instantly identify unauthorized drones in your airspace with advanced radar, RF scanning, and AI-powered sensors.","PAYMENTS_DESC":"Pinpoint the exact location, speed, and flight path of intruding drones for proactive response.","SCHEDULES_DESC":"Differentiate between drones, birds, and other objects to reduce false alarms and ensure reliable alerts.","SAVING_DESC":"Continuous surveillance to protect your property, events, or critical infrastructure around the clock."},"PRICING":{"TITLE":"DefAgent Calendar","SUBTITLE":"Works With Any Type Of Business And Any Type Of Appointment Scheduling","BUY":"Buy now","PLAN_PERSONAL":"One on One","PLAN_PERSONAL1":"Therapists","PLAN_PERSONAL2":"Personal trainers","PLAN_PERSONAL3":"Human Resources & Head Hunting","PLAN_PERSONAL4":"Pet care services","PLAN_PERSONAL5":"Sales teams & consultants","PLAN_PERSONAL_DESC":"","PLAN_BUSINESS":"Group","PLAN_BUSINESS1":"Gym & Fitness studio","PLAN_BUSINESS2":"Tour operators","PLAN_BUSINESS3":"Language schools","PLAN_BUSINESS4":"Schools & Universities","PLAN_BUSINESS5":"Events, Workshops & Seminars","PLAN_BUSINESS_DESC":"","PLAN_ENTERPRISE":"Reservations","PLAN_ENTERPRISE1":"Venue/Equipment Rentals","PLAN_ENTERPRISE2":"Photography studio","PLAN_ENTERPRISE3":"Resource scheduling","PLAN_ENTERPRISE4":"Conference & meeting rooms","PLAN_ENTERPRISE5":"Sport court reservations","PLAN_ENTERPRISE_DESC":"","PLAN_BUSINESSD":"Service","PLAN_BUSINESSD1":"Beauty salons","PLAN_BUSINESSD2":"Medical professionals","PLAN_BUSINESSD3":"Driving instructors","PLAN_BUSINESSD4":"Repair professionals","PLAN_BUSINESSD5":"Household & cleaning services","PLAN_BUSINESSD_DESC":""},"PRICING_TWO":{"TITLE":"Affordable pricing plans.","TITLE0":"Go Ahead And","TITLE01":"Get Your Discounted","TITLE1":"DefAgent Calendar","TITLE11":"License","TITLE2":"Today!","TITLE22":"Choose Your Plan:","SUBTITLE":"","BUY":"Buy Now","MONTHLY":"Monthly Basis","ANNUAL":"Annual Basis","DISCOUNT":"(Save Up To 30% Off On Annual Plans)","GETNOW":"Get It Now","CUSTOM":"For Teams","CUSTOM1":"(Best Value)","CUSTOM2":"For Teams And Businesses With Additional Scheduling Needs, Customization And Advanced Features","CUSTOM3":"Contact Us","PLAN_BASIC":"For Individuals","PLAN_BASIC_DESC":"Everything You Can Get From A Professional Solution To Keep Your Business On Its Way To Success","FEATURES1":"200 Maximum Number Of Upcoming Appointments","FEATURES2":"1 Integration To Collect Payments","FEATURES3":"50 Free SMS Invitations","FEATURES4":"DefAgent Calendar In Your Website","FEATURES5":"Custom Branding","FEATURES6":"Webhooks","FEATURES7":"Real-time Support","FEATURES8":"Workflows","FEATURES9":"Real-time Reports","FEATURES10":"Marketing Packages","FEATURES11":"Over 700 App Integrations With Zapier","FEATURES12":"Connect To Zoom, Microsoft Teams, Google Meet, And GoToMeeting"},"FEATURES":{"BUSINESS_TITLE":"Enhanced Security","PAYMENTS_TITLE":"Real-Time Threat Detection","SCHEDULES_TITLE":"Prevent Espionage and Surveillance","SAVING_TITLE":"Mitigate Smuggling and Contraband Drops","INTERFACE_TITLE":"Ensure Public Safety","SITE_TITLE":"Reduce False Alarms","BUSINESS_DESC":"Protect your property, events, or critical infrastructure from unauthorized drone intrusions.","PAYMENTS_DESC":"Identify and track drones instantly, ensuring timely response to potential threats.","SCHEDULES_DESC":"Safeguard sensitive information and privacy from drone-based spying.","SAVING_DESC":"Prevent drones from delivering illegal items to restricted areas like prisons or secure facilities.","INTERFACE_DESC":"Protect large gatherings, such as concerts, sports events, or public spaces, from rogue drones.","SITE_DESC":"Advanced AI and machine learning differentiate drones from birds, planes, or other objects.","DASHCORE_FEATURE":"DefAgent Features","WHAT_DASHCORE_CAN_DO":"Benefits Of Using Drone Detection System","LOREM_IPSUM":"With DefAgent, In Less Than 24 Hours An Organization Can Build Geolocated Intelligent Assistants That will Manage Data, And Match Needs With Solutions By Interconnecting People, Automated Processes And Devices In Real-time, Constantly Measuring The Performance Of Each Business Actor – All Without Coding."},"WHY_DASHCORE":{"WHY_DASHCORE_TEMPLATE":"Implementing a drone detection system","WHEN_LOOKING":"requires careful planning, the right technology, and integration with existing security infrastructure. Here’s a step-by-step guide to help you understand the implementation process","DEVELOPERS":"Assess Your Needs","ENGAGING_DEVELOPERS0":"","ENGAGING_DEVELOPERS01":"Identify the area to be protected (e.g., small property, large facility, or wide-area coverage).","ENGAGING_DEVELOPERS1":"Determine the level of threat (e.g., surveillance, smuggling, or malicious drones).","ENGAGING_DEVELOPERS11":"","ENGAGING_DEVELOPERS2":"Define your budget and goals (e.g., detection only, or detection + mitigation).","ENGAGING_DEVELOPERS22":"","LOREM_IPSUM":"","DESIGNER":"Choose the Right Technology","ENGAGING_DESIGNER0":"","ENGAGING_DESIGNER01":"Radar for long-range detection.","ENGAGING_DESIGNER1":"RF Scanners to detect drone communication signals.","ENGAGING_DESIGNER11":"","ENGAGING_DESIGNER2":"Optical/Infrared Cameras for visual confirmation.","ENGAGING_DESIGNER22":"","REMINDERS":"Site Survey and Installation Planning","ENGAGING_REMINDERS0":"","ENGAGING_REMINDERS01":"Conduct a site survey to identify optimal locations for sensors and cameras.","ENGAGING_REMINDERS1":"Ensure coverage of all entry points and vulnerable areas.","ENGAGING_REMINDERS11":"","ENGAGING_REMINDERS2":"Account for environmental factors like weather, terrain, and interference.","ENGAGING_REMINDERS22":"","PAYMENTS":"Install Hardware and Sensors","ENGAGING_PAYMENTS0":"","ENGAGING_PAYMENTS01":"Mount sensors, cameras, and other hardware in strategic locations.","ENGAGING_PAYMENTS1":"Ensure proper calibration and alignment for maximum accuracy.","ENGAGING_PAYMENTS11":"","ENGAGING_PAYMENTS2":"Set up communication links between sensors and the central control system.","ENGAGING_PAYMENTS22":"","PAGE":"Configure Software and AI","ENGAGING_PAGE0":"","ENGAGING_PAGE01":"Set up the central control software for real-time monitoring and alerts.","ENGAGING_PAGE1":"Train AI algorithms to differentiate drones from birds, planes, or other objects.","ENGAGING_PAGE11":"","ENGAGING_PAGE2":"Customize alert settings (e.g., email, SMS, or visual/audio alarms).","ENGAGING_PAGE22":""},"VIDEOs":{"HOW_TO_VIDEO":"Why Us?","TAKE_A_LOOKING_AT":"Leading the Way in Drone Detection and Airspace Security","1_TITLE":"Cutting-Edge Technology","1_DESC":"We use the latest advancements in radar, RF scanning, AI, and machine learning to deliver the most accurate and reliable drone detection systems.","2_TITLE":"Comprehensive Solutions","2_DESC":"From detection and tracking to mitigation, we provide end-to-end solutions tailored to your specific needs.","3_TITLE":"Proven Expertise","3_DESC":"With years of experience in security and drone technology, we understand the challenges and deliver proven results."}}},"PROJECT":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - Networks directory","KEYWORDS":"Network Search, Networks directory"},"FOR_DEVELOPERS":{},"FORSTORYTELLERS":{},"VIEW_PLANAND_PRICE":{}},"FAQS":{"FAQS1":{"DO_YOU_HAVE":"Do you have","QUESTIONS":"questions?","NOT_SURE_HOW":"Not sure how DefAgent can help you? Wondering why you need to start your AI journey?","HERE_ARE_THE_ANSWERS":"You can ask us any questions. However, here are the answers to the most common questions we get asked by our esteemed customers."}},"COUNTER":{"COUNTER1":{"MILLIONS_BUSSINESS":"Millions rely on DefAgent to find and retain top talents!","THESE_AMAZING_STATS":"Numerous brands and businesses around the world use DefAgent AIaaS and cognitive computing capabilities to optimize their HR workflows. Numbers don’t lie and these amazing stats can’t be wrong!"},"COUNTER1_L2":{"MILLIONS_BUSSINESS":"Many businesses rely on DefAgent to boost their sales performance!","THESE_AMAZING_STATS":"Businesses and brands are across the world are leveraging our powerful talent technology to boost their lead volume, close rate, and entire sales performance. Check out our numbers!"},"COUNTER2":{"WHY_CUSTOMER_TRUST_US":"Why customer trust us","HAPPY":"Happy","CUSTOMER":"Customers","THESE_AMAZING_STATS":"These amazing stats can be wrong, many happy customers around the world trust our service to boost their business.","TONS_OF_SUCCESSFULL_IMPLEMENATION":"Tons of successful implementations","USERS_IMPROVE_THEIR_ABILITY":"DefAgent raises the bar for efficiency and productivity, thus increasing job satisfaction. This low-code platform also guarantees exceptional ease of implementation and so is trusted by hundreds of thousands of brands across the world.","ALL_POWERED_BY":"Powered by a cognitive engine which can develop characters for various roles, to complete different functions within the company.","LEARN_MORE":"Learn more"},"COUNTER3":{"AMAZING_STATS":"Amazing stats","EVERYTHINK_CREaTES_A_POWERFUL_AND_EFFECTIVE":"Leverage DefAgent’s AIaaS platform to implement a circular economy business model!","EACH_USER_IS_EMPOWERED":"Users are empowered by the ability to improve networking and boost job performance."},"COUNTER6":{"SUCCESSFULL_IMPLEMENTATIONS":"1M+ Successfully Implementations","GET_THEVERY_BEST":"Get the very best of us by doing the best of you"}},"CATE":{"CATE1":{"READY_TO_GET_STARTED":"Ready to get started?","BECOME_ONE_OF_THE_MILLIONS":"Join millions of people and brands around the world who love and use EveryThink!","CREATE_EVERTTHINKACCOUNT":"Create account"}},"TESTIMONIALS":{"TESTIMONIAL_SIMPLE_SLIDER":{"TESTIMONIALS":"Testimonials"},"TESTIMONIAL_SLIDER":{"LOREM_IPS":"This is an incredible tool that can help anyone to create their own algorithms and generate a more sustainable business. Thank you very much for helping us help other people!","JANE_DOR":"Estefany Güechá,","AWESOME_COMPANY":"Somos Pileros"},"TESTIMONIAL_SIMPLE_TEXT_RIGHT":{"IF_YOU_ARE_STRUGGLING":"If you are struggling to stay in business, there may be several options you can explore.","EVERYTHINK":"DefAgent,","IS_THE_PERFECT_TOOL":" is the perfect tool. It is very easy to use, and it has all the functionality you are looking for.","CARO_FOGLIATO":"Caro Fogliato,","CEOANDFOUNDER":" CEO & Founder of DefAgent inc."},"TESTIMONIAL_SIMPLE_TEXT_LEFT":{"EVERYTHIN_IS_GREAT_FOR":"DefAgent is great for","ANYONE_WHO_IS_LOOKING_FOR_SIMPLE":" Anyone who is looking for simple implementation with exponentially positive impact","EVERYTHINK_LTD_TEAM":"DefAgent inc. Team,","DoING_GREATE_SINCE":" Doing great since 2024"},"TESTIMONIAL_SKEWED_SLIDER":{"OUR_CUSTOMERS_HAVE_SOMETHING_TO_SAY":"Our customers have something to say","THEY_ARE_THE_BEST":"They are the best, our customer want to let you know how DefAgent is helping them to achieve their goals and how simple is to use it!"},"TESTIMONIAL_WORLD_MAP":{"WE_HEARD_OUR_CUSTOMERS_SAY":"We\'ve heard our customers say","SED_OUT_PERSPICIATIS":"This is an incredible tool that can help anyone to create their own algorithms and generate a more sustainable business. Thank you very much for helping us help other people!","JANE_DOE":"Estefany Güechá,","MARKEYING_DIRECTOR":"Somos Pileros"}},"USUAL":{"FEATURES_ICONS_COL":{"UP_TO_THE_TASK":"Start your AI for health journey with DefAgent","WHAT_YOU_GET":"What You Get","GEOLOCATED_INTELLIGENT_ASSISTANTS":"With DefAgent AIaaS low-code platform, you can leverage geolocated IAs to manage data from disparate sources like electronic health records and social determinants of health; interconnect people and devices and, automate costly, repetitive, and error-prone administrative labor into a far more efficient and inexpensive digital workforce."},"DEVELOPER_DESIGNER":{"JOIN_AS_DESIGNER":"Join us!","JOIN_AS_DEVELOPER":"","LOREM_IPSUM":""},"START_NOW_BOX":{"TRY_EVERYTHINK_NOW":"Try DefAgent now.... love it forever","WHY_WAIT":"Why wait? Start now!","START_NOW":"Start now"}},"FOOTER":{"FOOTER1":{"EVERYTHINK_IS_POISED":"All is one, where infinity starts.","COMPANY":"DefAgent","ABOUT":"About Us","BLOG":"Blog","PRODUCt":"Product","SERVICES":"Services","FEATURES":"Features","API":"API","CUSTOMERS":"Customers","CHANNELS":"Channels","CAREERS":"Careers","CONTACT":"Contact","SEARCH":"Search","COPYRIGHT":"Copyright © 2024-2025 DefAgent inc. All Rights Reserved."}},"CONTACT":{"NETWORK_SEARCH_META":{"TITLE":"EveryThink - contact","KEYWORDS":"Network Search, Networks directory contact"},"FORM":{"LETS_DO_BUSINESS":"Let\'s do business","STEP_INTO_OUR_PLACE":"Step into our place","123_STREET_ST":"Texas","YC_COUNTRY":" United States"},"OTHER_CHANNELS":{"CONTACT_SALE":"Contact Sale","LOOKING_FOR_CUSTOM_QUOTE":"Looking for a custom quote? need to tell us more about your project? or want a demonstration? drop us a line to","TECHNICAL_SUPPORT":"Technical Support","ANY_QUESTION":"Any question about how to integrate your product?. Don\'t fret, our team is ready for help you"}},"ABOUT":{"NETWORK_SEARCH_META":{"TITLE":"EveryThink - about","KEYWORDS":"Network Search, Networks directory about"},"OVERVIEW":{"SUCCEED_WITH_DASHCORE":"Succeed with EveryThink","THE_NEW_WAY_TO_SHOWCASE":"The new way to boost your Business","DASHCORE_IS_A_BOOTSTRAP":"","IT_INCLUDES_MULTIPLE":"It includes multiple components and pre-made demos ready for you to personalize according to your own needs. EveryThink includes a ready-to-go Admin Dashboard with many out-of-the-box features."},"VIDEO":{"DISCOVER_HOW_DASHCORE_WORKS":"Discover how EveryThink works","PLAY_THE_VIDEO":"Play the video"},"SOLUTIONS":{"A_SOLUTION_FOR_EVERY_NEED":"A solution for every need","LOREM_IPSUM":"","DASHCORE_INCLUDED":"Dashboards Included","OUR_TEMPLATE_IS_PACKED_WITH_A":"EveryThink","START_ADMIN_DASHBOARD":"also has control panels that are customizable according to your needs","START_RIGHT_AWAY":"started right away with your project.","TRY_THE_DASHBOARD":"Try EveryThink"},"FEATURES":{"OUR_FEATURES_STACK":"Our features stack","TAKE_THE_CONTROL":"Take the control of your business with EveryThink. You can customize  according to your needs or just use the ready-to-use the solution we made for you"},"CUSTOMERS":{"THIRD_PARTY":"Third party integration","WE_USE_THE_LATEST_TRENDS":" We use the latest trends because you deserve better","ARE_YOU_A_DEVELOPER":"Are you a developer?","REVIEW_THE_SPECS":"Review the specs"},"TEAM":{"GET_TO_KNOW_OUR_TEAM":"Get to know our team","THESE_AMAZING_PEOPLE":"These amazing people have made possible to stay where we are"},"REGISTER":{"DASHCORE_OFFICIAL":"EveryThink Ltd","NEWSLETTER":"Newsletter"}},"TERMS":{"trm_terms_of_use":"Terms Of Use","trm_last_update":"Last Update: March 30, 2025","trm_general_information":"General Information","trm_introduction":"Welcome to DefAgent inc. (the “Company”). DefAgent builds technologies and services that enable people to connect with each other, proceses and devices; builds networks, communities, and channels; and grows businesses. These Terms govern your use of DefAgent, and the other products, modules, features, apps, services, technologies, and software we offer. These Products are provided to you by DefAgent, inc. By creating a DefAgent account, whether through a mobile device, mobile application or computer (collectively, the “Service”) you agree to be bound by these Terms of Use and our Privacy Policy, which is incorporated by reference into this Agreement and available in the Service (this “Agreement”). If you do not accept and agree to be bound by all of the terms of this Agreement, please do not use the Service.","trm_1_acceptance_terms":"1. Acceptance of Terms of Use Agreement.","trm_1_acceptance_terms_1":"This Agreement is an electronic contract that establishes the legally binding terms you must accept to use the Service. This Agreement includes the Company’s (i) Privacy Policy, (ii) Our Safety Tips and (iii) Terms Disclosed And Agreed To By You if you purchase or accept additional features, modules, products or services we offer on the Service.","trm_1_acceptance_terms_2":"We may, at any time and for any reason make changes to this Agreement. We may do this for a variety of reasons including to reflect changes in or requirements of the law, new features, or changes in business practices. The most recent version of this Agreement will be posted on the Services under Settings and also on https://defagent.ai/ Web-page, and you should regularly check for the most recent version. The most recent version is the version that applies. If the changes include material changes that affect your rights or obligations, we will notify you of the changes by reasonable means, which could include notification through the Services or via email. If you continue to use the Services after the changes become effective, then you shall be deemed to have accepted those changes. If you don’t agree to these changes, you must end your relationship with us by ceasing to use the Services and leaving DefAgent.","trm_2_eligibility":"2. Eligibility.","trm_2_eligibility_1":"You must be at least 18 years of age to create an account on DefAgent and use the Service. By creating and account and using the Service, you represent and warrant that you can form a binding contract with DefAgent, you are not a person who is barred from using the Service under the laws of texas,usa or any other applicable jurisdiction meaning that you do not appear on texas,usa. Treasury Department’s list of Specially Designated Nationals or face any other similar prohibition, and you will comply with this Agreement and all applicable local, state, national and international laws, rules and regulations. If you create an account, you represent and warrant that you have never been convicted of a felony and that you are not required to register as a sex offender with any state, federal or local sex offender registry.","trm_3_user_accounts":"3. User Accounts.","trm_3_user_accounts_1":"In order to use most aspects of the Services, you must register for and maintain an active personal user Services account (\'Account\'). You must be at least 18 years of age, or the age of legal majority in your jurisdiction (if different than 18), to obtain an Account, unless a specific Service permits otherwise. Account registration requires you to submit to DefAgent certain personal information, such as your name, address, mobile phone number and age, as well as at least one valid payment method supported by DefAgent. You agree to maintain accurate, complete, and up-to-date information in your Account. Your failure to maintain accurate, complete, and up-to-date Account information, including having an invalid or expired payment method on file, may result in your inability to access or use the Services. You are responsible for all activity that occurs under your Account, and you agree to maintain the security and secrecy of your Account username and password at all times. Unless otherwise permitted by DefAgent in writing, you may only possess one Account.","trm_4_terms_termination":"4. Terms And Termination.","trm_4_terms_termination_1":"This Agreement will remain in full force and effect while you use the Service and/or have a DefAgent account. You may terminate your account at any time, for any reason, by following the instructions in “Settings” in the Service. The Company may terminate or suspend your account at any time without notice if the Company believes that you have breached this Agreement in its sole discretion. Upon such termination or suspension, you will not be entitled to any refund of unused fees for in app purchases. After your account is terminated, this Agreement will terminate, except that the following provisions will still apply: Section 4, Section 8, Section 9 and Sections 16-18.","trm_5_non_commercial_use":"5. Non-commercial Use by Users.","trm_5_non_commercial_use_1":"The Service is for personal use only. Users may not use the Service or any content contained in the Service (including, but not limited to, content of other users, designs, text, graphics, images, video, logos, software, and computer code) in connection with any commercial endeavors, such as advertising or soliciting any user to buy or sell any products or services not offered by the Company. Users of the Service may not use any information obtained from the Service to contact, advertise to, solicit, or sell to any other user without his or her prior explicit consent. Organizations, companies, and/or businesses may not use the Service for any purpose except with DefAgent’ express consent (such as for promoted profiles or other advertisements), which DefAgent may provide or deny in its sole discretion. The Company may investigate and take any available legal action in response to illegal and/or unauthorized uses of the Service.","trm_6_the_services":"6. The Services.","trm_6_the_services_1":"DefAgent is a Mobile (Android and iOS) and Web interactive network hosted by a virtual assistant with artificial intelligence capable of connecting people according to their personal, work, social and educational interests, needs and abilities through specific questions. The virtual assistant is capable of learning about the user needs, abilities, interests and aspirations in every environment through contextualized and geospatial questions, in order to achieve assertive connections with others.","trm_7_interactions":"7. Your Interactions With Other Users.","trm_7_interactions_1":"YOU ARE SOLELY RESPONSIBLE FOR YOUR INTERACTIONS WITH OTHER USERS. YOU UNDERSTAND THAT THE COMPANY CURRENTLY DOES NOT CONDUCT CRIMINAL BACKGROUND CHECKS ON ITS USERS. THE COMPANY ALSO DOES NOT VERIFY THE STATEMENTS OF ITS USERS. THE COMPANY MAKES NO REPRESENTATIONS OR WARRANTIES AS TO THE CONDUCT OF USERS OR THEIR COMPATIBILITY WITH ANY CURRENT OR FUTURE USERS. THE COMPANY RESERVES THE RIGHT TO CONDUCT ANY CRIMINAL BACKGROUND CHECK OR OTHER SCREENINGS (SUCH AS SEX OFFENDER REGISTER SEARCHES), AT ANY TIME AND USING AVAILABLE PUBLIC RECORDS.","trm_7_interactions_2":"The Company is not responsible for the conduct of any user. As noted in and without limiting Section 15 below, in no event shall the Company, its affiliates or its partners be liable (directly or indirectly) for any losses or damages whatsoever, whether direct, indirect, general, special, compensatory, consequential, and/or incidental, arising out of or relating to the conduct of you or anyone else in connection with the use of the Service including, without limitation, death, bodily injury, emotional distress, and/or any other damages resulting from communications or meetings with other users or persons you meet through the Service. You agree to take all necessary precautions in all interactions with other users, particularly if you decide to communicate off the Service or meet in person, or if you decide to send money to another user. In addition, you agree to review and follow the Company’s Safety Tips, located in the Service, prior to using the Service. You should not provide your financial information (for example, your credit card or bank account information), or wire or otherwise send money, to other users.","trm_8_content_posted":"8. Content Posted By You In The Service.","trm_8_content_posted_1":"You are solely responsible for the content and information that you post, upload, publish, link to, transmit, record, display or otherwise make available (collectively, “post”) on the Service or transmit to other users, including text messages, chat, videos, photographs, or profile text, whether publicly posted or privately transmitted (collectively, “Content”). You may not post as part of the Service, or transmit to the Company or any other user (either on or off the Service), any offensive, inaccurate, incomplete, abusive, obscene, profane, threatening, intimidating, harassing, racially offensive, or illegal material, or any material that infringes or violates another person’s rights (including intellectual property rights, and rights of privacy and publicity). You represent and warrant that (i) all information that you submit upon creation of your account, is accurate and truthful and that you will promptly update any information provided by you that subsequently becomes inaccurate, incomplete, misleading or false and (ii) you have the right to post the Content on the Service and grant the licenses set forth below.","trm_8_content_posted_2":"You understand and agree that the Company may, but is not obligated to, monitor or review any Content you post as part of a Service. The Company may delete any Content, in whole or in part, that in the sole judgment of the Company violates this Agreement or may harm the reputation of the Service or the Company.","trm_8_content_posted_3":"By posting Content as part of the Service, you grant to DefAgent a worldwide, transferable, sub-licensable, royalty-free, right and license to host, store, use, copy, display, reproduce, adapt, edit, publish, modify and distribute the Content. This license is for the limited purpose of operating, developing, providing, promoting, and improving the Service and researching and developing new ones.","trm_8_content_posted_4":"In addition to the types of Content described in Section 8 (a) above, the following is a partial list of the kind of Content that is prohibited in the Service. You may not post, upload, display or otherwise make available Content that:","trm_8_content_posted_4_1":"(I) Promotes racism, bigotry, hatred or physical harm of any kind against any group or individual;","trm_8_content_posted_4_2":"(II) Advocates harassment or intimidation of another person;","trm_8_content_posted_4_3":"(III) Spams or solicits DefAgent’ users;","trm_8_content_posted_4_4":"(IV) Promotes information that is false or misleading, or promotes illegal activities or conduct that is defamatory, libelous or otherwise objectionable;","trm_8_content_posted_4_5":"(V) Promotes an illegal or unauthorized copy of another person’s copyrighted work, such as providing pirated computer programs, images, audio or video files or links to them;","trm_8_content_posted_4_6":"(VI) Contains video, audio photographs, or images of another person without his or her permission (or in the case of a minor, the minor’s legal guardian);","trm_8_content_posted_4_7":"(VII) Contains restricted or password only access pages, or hidden pages or images (those not linked to or from another accessible page);","trm_8_content_posted_4_8":"(VIII) Provides material that exploits people in a sexual, violent or other illegal manner, or solicits personal information from anyone under the age of 18;","trm_8_content_posted_4_9":"(IX) Provides instructional information about illegal activities such as making or buying illegal weapons or drugs, violating someone’s privacy, or providing, disseminating or creating computer viruses;","trm_8_content_posted_4_10":"(X) Contains viruses, time bombs, trojan horses, cancelbots, worms or other harmful, or disruptive codes, components or devices;","trm_8_content_posted_4_11":"(XI) Impersonates, or otherwise misrepresents affiliation, connection or association with, any person or entity;","trm_8_content_posted_4_12":"(XII) Provides information or data you do not have a right to make available under law or under contractual or fiduciary relationships (such as inside information, proprietary and confidential information);","trm_8_content_posted_4_13":"(XIII) Disrupts the normal flow of dialogue, causes a screen to “scroll” faster than other users are able to type, or otherwise negatively affects other users’ ability to engage in real time exchanges; and","trm_8_content_posted_4_14":"(XIV) Solicits passwords or personal identifying information for commercial or unlawful purposes from other users or disseminates another person’s personal information without his or her permission.","trm_8_content_posted_text":"The Company reserves the right, in its sole discretion, to investigate and take any legal action against anyone who violates this provision, including removing the offending communication from the Service and terminating or suspending the account of such violators.","trm_9_use_service_0":"9. Use Of The Service","trm_9_use_service":"Your use of the Service, including all Content you post through the Service, must comply with all applicable laws and regulations. You agree that the Company may access, preserve and disclose your account information and Content if required to do so by law or in a good faith belief that such access, preservation or disclosure is reasonably necessary, such as to: (i) comply with legal process; (ii) enforce this Agreement; (iii) respond to claims that any Content violates the rights of third parties; (iv) respond to your requests for customer service or allow you to use the Service in the future; or (v) protect the rights, property or personal safety of the Company or any other person.","trm_10_agree_content":"You agree that any Content you place on the Service may be viewed by other users and may be viewed by any person visiting or participating in the Service (such as individuals who may receive shared Content from other DefAgent users).","trm_11_prohibited_activities":"10. Prohibited Activities","trm_11_prohibited_activities_1":"The Company reserves the right to investigate, suspend and/or terminate your account if you have misused the Service or behaved in a way the Company regards as inappropriate or unlawful, including actions or communications the occur off the Service but involve users you meet through the Service. The following is a partial list of the type of actions that you may not engage in with respect to the Service. You will not:","trm_11_prohibited_activities_1_1":"(I) Impersonate any person or entity.","trm_11_prohibited_activities_1_2":"(II) Solicit money from any users.","trm_11_prohibited_activities_1_3":"(III) Post any Content that is prohibited by Section 7.","trm_11_prohibited_activities_1_4":"(IV) “Stalk” or otherwise harass any person.","trm_11_prohibited_activities_1_5":"(V) Express or imply that any statements you make are endorsed by the Company without our specific prior written consent.","trm_11_prohibited_activities_1_6":"(VI) Use the Service in an illegal manner or to commit an illegal act.","trm_11_prohibited_activities_1_7":"(VII) Access the Service in a jurisdiction in which it is illegal or unauthorized.","trm_11_prohibited_activities_1_8":"(VIII) Use any robot, spider, site search/retrieval application, or other manual or automatic device or process to retrieve, index, “data mine”, or in any way reproduce or circumvent the navigational structure or presentation of the Service or its contents.","trm_11_prohibited_activities_1_9":"(IX) Collect usernames and/or email addresses of users by electronic or other means for the purpose of sending unsolicited email or unauthorized framing of or linking to the Service.","trm_11_prohibited_activities_1_10":"(X) Interfere with or disrupt the Service or the servers or networks connected to the Service.","trm_11_prohibited_activities_1_11":"(XII) Transmit any material that contains software viruses or any other computer code, files or programs designed to interrupt, destroy or limit the functionality of any computer software or hardware or telecommunications equipment.","trm_11_prohibited_activities_1_12":"(XIII) Forge headers or otherwise manipulate identifiers in order to disguise the origin of any information transmitted to or through the Service (either directly or indirectly through use of third party software).","trm_11_prohibited_activities_1_13":"(XIV) “Frame” or “Mirror” any part of the Service, without the Company’s prior written authorization.","trm_11_prohibited_activities_1_14":"(XV) Use meta tags or code or other devices containing any reference to the Company or the Service (or any trademark, trade name, service mark, logo or slogan of the Company) to direct any person to any other website for any purpose.","trm_11_prohibited_activities_1_15":"(XVI) Modify, adapt, sublicense, translate, sell, reverse engineer, decipher, decompile or otherwise disassemble any portion of the Service any software used on or for the Service, or cause others to do so.","trm_11_prohibited_activities_1_16":"(XVII) Post, use, transmit or distribute, directly or indirectly, (e.g. screen scrape) in any manner or media any content or information obtained from the Service other than solely in connection with your use of the Service in accordance with this Agreement.","trm_12_propietary_rights":"11. Proprietary Rights.","trm_12_propietary_rights_1":"The Company owns and retains all proprietary rights in the Service, and in all content, trademarks, trade names, service marks and other intellectual property rights related thereto. The Service contains the copyrighted material, trademarks, and other proprietary information of the Company and its licensors. You agree to not copy, modify, transmit, create any derivative works from, make use of, or reproduce in any way any copyrighted material, trademarks, trade names, service marks, or other intellectual property or proprietary information accessible through the Service, without first obtaining the prior written consent of the Company or, if such property is not owned by the Company, the owner of such intellectual property or proprietary rights. You agree to not remove, obscure or otherwise alter any proprietary notices appearing on any content, including copyright, trademark and other intellectual property notices.","trm_13_ownership":"12. Ownership.","trm_13_ownership_1":"The Services and all rights therein are and shall remain DefAgent\' property or the property of DefAgent \' licensors. Neither these Terms nor your use of the Services convey or grant to you any rights: (i) in or related to the Services except for the limited license granted above; or (ii) to use or reference in any manner DefAgent company names, logos, product and service names, trademarks or services marks or those of DefAgent licensors.","trm_14_user_provided_content":"13. User Provided Content","trm_14_user_provided_content_1":"DefAgent may, in DefAgent sole discretion, permit you from time to time to submit, upload, publish or otherwise make available to DefAgent through the Services textual, audio, and/or visual content and information, including commentary and feedback related to the Services, initiation of support requests, and submission of entries for competitions and promotions (\'User Content\'). Any User Content provided by you remains your property. However, by providing User Content to DefAgent, you grant DefAgent a worldwide, perpetual, irrevocable, transferable, royalty-free license, with the right to sublicense, to use, copy, modify, create derivative works of, distribute, publicly display, publicly perform, and otherwise exploit in any manner such User Content in all formats and distribution channels now known or hereafter devised (including in connection with the Services and DefAgent business and on third-party sites and services), without further notice to or consent from you, and without the requirement of payment to you or any other person or entity.You represent and warrant that: (i) you either are the sole and exclusive owner of all User Content or you have all rights, licenses, consents and releases necessary to grant DefAgent the license to the User Content as set forth above; and (ii) neither the User Content, nor your submission, uploading, publishing or otherwise making available of such User Content, nor DefAgent use of the User Content as permitted herein will infringe, misappropriate or violate a third party\'s intellectual property or proprietary rights, or rights of publicity or privacy, or result in the violation of any applicable law or regulation.You agree to not provide User Content that is defamatory, libelous, hateful, violent, obscene, pornographic, unlawful, or otherwise offensive, as determined by DefAgent in its sole discretion, whether or not such material may be protected by law. DefAgent may, but shall not be obligated to, review, monitor, or remove User Content, at DefAgent sole discretion and at any time and for any reason, without notice to you.","trm_15_network_access_devices":"14. Networks, Communities, And Channels Access And Devices.","trm_15_network_access_devices_1":"You are responsible for obtaining the data network access necessary to use the Services. Your mobile network\'s data and messaging rates and fees may apply if you access or use the Services from your device. You are responsible for acquiring and updating compatible hardware or devices necessary to access and use the Services and Applications and any updates thereto. DefAgent does not guarantee that the Services, or any portion thereof, will function on any particular hardware or devices. In addition, the Services may be subject to malfunctions and delays inherent in the use of the Internet and electronic communications.","trm_16_modifications_service":"15. Modifications To Service.","trm_16_modifications_service_1":"The Company reserves the right at any time to modify or discontinue, temporarily or permanently, the Service (or any part thereof) with or without notice. You agree that the Company shall not be liable to you or to any third party for any modification, suspension or discontinuance of the Service. To protect the integrity of the Service, the Company reserves the right at any time in its sole discretion to block users from certain IP addresses from accessing the Service.","trm_17_copyright_policy":"16. Copyright Policy.","trm_17_copyright_policy_1":"Notice and Procedure for Making Claims of Copyright Infringement. You may not post, distribute, or reproduce in any way any copyrighted material, trademarks, or other proprietary information without obtaining the prior written consent of the owner of such proprietary rights. If you believe that your work has been copied and posted on the Service in a way that constitutes copyright infringement, please provide our Copyright Agent with the following information:","trm_17_copyright_policy_1_1":"(I) An electronic or physical signature of the person authorized to act on behalf of the owner of the copyright interest;","trm_17_copyright_policy_1_2":"(II) A description of the copyrighted work that you claim has been infringed;","trm_17_copyright_policy_1_3":"(III) A description of where the material that you claim is infringing is located on the Service (and such description must be reasonably sufficient to enable the Company to find the alleged infringing material, such as a url);","trm_17_copyright_policy_1_4":"(IV) Your address, telephone number and email address;","trm_17_copyright_policy_1_5":"(V) A written statement by you that you have a good faith belief that the disputed use is not authorized by the copyright owner, its agent, or the law; and","trm_17_copyright_policy_1_6":"(VI) A statement by you, made under penalty of perjury, that the above information in your notice is accurate and that you are the copyright owner or authorized to act on the copyright owner’s behalf.","trm_17_copyright_policy_1_text":"Notice of claims of copyright infringement should be provided to the Company’s Copyright Agent at caro@DefAgent.ai","trm_17_copyright_policy_1_text1":"The Company will terminate the accounts of repeat infringers.","trm_17_disclaimers":"17.  Disclaimers, Limitation Of Liability.","trm_17_disclaimers_0":"DISCLAIMERS.","trm_17_disclaimers_1":"THE SERVICES ARE PROVIDED \'AS IS\' AND \'AS AVAILABLE.\' DEFAGENT DISCLAIMS ALL REPRESENTATIONS AND WARRANTIES, EXPRESS, IMPLIED, OR STATUTORY, NOT EXPRESSLY SET OUT IN THESE TERMS, INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN ADDITION, DEFAGENT MAKES NO REPRESENTATION, WARRANTY, OR GUARANTEE REGARDING THE RELIABILITY, TIMELINESS, QUALITY, SUITABILITY, OR AVAILABILITY OF THE SERVICES OR ANY SERVICES OR GOODS REQUESTED THROUGH THE USE OF THE SERVICES, OR THAT THE SERVICES WILL BE UNINTERRUPTED OR ERROR-FREE. DEFAGENT DOES NOT GUARANTEE THE QUALITY, SUITABILITY, SAFETY OR ABILITY OF THIRD PARTY PROVIDERS. YOU AGREE THAT THE ENTIRE RISK ARISING OUT OF YOUR USE OF THE SERVICES, AND ANY SERVICE OR GOOD REQUESTED IN CONNECTION THEREWITH, REMAINS SOLELY WITH YOU, TO THE MAXIMUM EXTENT PERMITTED UNDER APPLICABLE LAW.","trm_17_limitation":"LIMITATION OF LIABILITY.","trm_17_limitation_1":"DEFAGENT SHALL NOT BE LIABLE FOR INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, PUNITIVE, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, LOST DATA, PERSONAL INJURY, OR PROPERTY DAMAGE RELATED TO, IN CONNECTION WITH, OR OTHERWISE RESULTING FROM ANY USE OF THE SERVICES, REGARDLESS OF THE NEGLIGENCE (EITHER ACTIVE, AFFIRMATIVE, SOLE, OR CONCURRENT) OF DEFAGENT, EVEN IF DEFAGENT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. DEFAGENT SHALL NOT BE LIABLE FOR ANY DAMAGES, LIABILITY OR LOSSES ARISING OUT OF: (i) YOUR USE OF OR RELIANCE ON THE SERVICES OR YOUR INABILITY TO ACCESS OR USE THE SERVICES; OR (ii) ANY TRANSACTION OR RELATIONSHIP BETWEEN YOU AND ANY THIRD PARTY PROVIDER, EVEN IF DEFAGENT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. DEFAGENT SHALL NOT BE LIABLE FOR DELAY OR FAILURE IN PERFORMANCE RESULTING FROM CAUSES BEYOND DEFAGENT REASONABLE CONTROL. YOU ACKNOWLEDGE THAT THIRD PARTY PROVIDERS PROVIDING TRANSPORTATION SERVICES REQUESTED THROUGH SOME REQUEST PRODUCTS MAY OFFER RIDESHARING OR PEER-TO-PEER TRANSPORTATION SERVICES AND MAY NOT BE PROFESSIONALLY LICENSED OR PERMITTED. THE SERVICES MAY BE USED BY YOU TO REQUEST AND SCHEDULE TRANSPORTATION, GOODS, OR LOGISTICS SERVICES WITH THIRD PARTY PROVIDERS, BUT YOU AGREE THAT DEFAGENT HAS NO RESPONSIBILITY OR LIABILITY TO YOU RELATED TO ANY TRANSPORTATION, GOODS OR LOGISTICS SERVICES PROVIDED TO YOU BY THIRD PARTY PROVIDERS OTHER THAN AS EXPRESSLY SET FORTH IN THESE TERMS. THE LIMITATIONS AND DISCLAIMER IN THIS SECTION DO NOT PURPORT TO LIMIT LIABILITY OR ALTER YOUR RIGHTS AS A CONSUMER THAT CANNOT BE EXCLUDED UNDER APPLICABLE LAW. BECAUSE SOME STATES OR JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF OR THE LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES, IN SUCH STATES OR JURISDICTIONS, DEFAGENT LIABILITY SHALL BE LIMITED TO THE EXTENT PERMITTED BY LAW. THIS PROVISION SHALL HAVE NO EFFECT ON DEFAGENT CHOICE OF LAW PROVISION SET FORTH BELOW.","trm_18_arbitration":"18. Arbitration And Governing Law.","trm_18_arbitration_p":"Except for users residing within the European Union, Norway and elsewhere where prohibited by applicable law:","trm_18_arbitration_i_01":"The exclusive means of resolving any dispute or claim arising out of or relating to this Agreement (including any alleged breach thereof) or the Service shall be BINDING ARBITRATION administered by the texas,usa Arbitration Association. The one exception to the exclusivity of arbitration is that you have the right to bring an individual claim against the Company in a small-claims court of competent jurisdiction. But whether you choose arbitration or small-claims court, you may not under any circumstances commence or maintain against the Company any class action, class arbitration, or other representative action or proceeding.","trm_18_arbitration_i_02":"By using the Service in any manner, you agree to the above arbitration agreement. In doing so, YOU GIVE UP YOUR RIGHT TO GO TO COURT to assert or defend any claims between you and the Company (except for matters that may be taken to small-claims court). YOU ALSO GIVE UP YOUR RIGHT TO PARTICIPATE IN A CLASS ACTION OR OTHER CLASS PROCEEDING. Your rights will be determined by a NEUTRAL ARBITRATOR, NOT A JUDGE OR JURY. You are entitled to a fair hearing before the arbitrator. The arbitrator can grant any relief that a court can, but you should note that arbitration proceedings are usually simpler and more streamlined than trials and other judicial proceedings. Decisions by the arbitrator are enforceable in court and may be overturned by a court only for very limited reasons. For details on the arbitration process, see our Arbitration Procedures.","trm_18_arbitration_i_03":"Any proceeding to enforce this arbitration agreement, including any proceeding to confirm, modify, or vacate an arbitration award, may be commenced in any court of competent jurisdiction. In the event that this arbitration agreement is for any reason held to be unenforceable, any litigation against the Company (except for small-claims court actions) may be commenced only in the federal or state courts located in texas,usa. You hereby irrevocably consent to the jurisdiction of those courts for such purposes.","trm_18_arbitration_i_04":"This Agreement, and any dispute between you and the Company, shall be governed by the laws of texas,usa without regard to principles of conflicts of law, provided that this arbitration agreement shall be governed by the Federal Arbitration Act.","trm_18_arbitration_p_1":"For users residing in the European Union, Norway or elsewhere where this arbitration agreement is prohibited by law, the laws of texas,usa, excluding texas,usa’s conflict of laws rules, will apply to any disputes arising out of or relating to this Agreement or the Services. All claims arising out of or relating to this Agreement or the Services will be litigated exclusively in the federal or state courts of texas,usa, and you and DefAgent consent to personal jurisdiction in those courts.","trm_19_":"19. Indemnity By You.","trm_19_p":"You agree to indemnify and hold the Company, its subsidiaries, and affiliates, and its and their officers, agents, partners and employees, harmless from any loss, liability, claim, or demand, including reasonable attorney’s fees, made by any third party due to or arising out of your breach of or failure to comply with this Agreement (including any breach of your representations and warranties contained herein), any postings or Content you post in the Service, and the violation of any law or regulation by you. The Company reserves the right to assume the exclusive defense and control of any matter otherwise subject to indemnification by you, in which event you will fully cooperate with the Company in connection therewith.","trm_20_":"20. Notice.","trm_20_p":"The Company may provide you with notices, including those regarding changes to this Agreement, using any reasonable means, which may include email, SMS, MMS, text message or postings in the Service. Such notices may not be received if you violate this Agreement by accessing the Service in an unauthorized manner. You agree that you are deemed to have received any and all notices that would have been delivered had you accessed the Service in an authorized manner.","trm_21_":"21. Entire Agreement","trm_21_p":"This Agreement, with the Privacy Policy and any specific guidelines or rules that are separately posted for particular services or offers in the Service, contains the entire agreement between you and the Company regarding the use of the Service. If any provision of this Agreement is held invalid, the remainder of this Agreement shall continue in full force and effect. The failure of the Company to exercise or enforce any right or provision of this Agreement shall not constitute a waiver of such right or provision. You agree that your DefAgent account is non-transferable and all of your rights to your profile or contents within your DefAgent account terminate upon your death. No agency, partnership, joint venture or employment is created as a result of this Agreement and you may not make any representations or bind the Company in any manner.","trm_question":"Questions?","trm_privacy_policy":"Any questions about this Privacy Policy should be addressed to caro@defagent.ai"}}'
      );
    },
    AxL3: function(module, exports) {
      var canUseDOM = !(
        'undefined' == typeof window ||
        !window.document ||
        !window.document.createElement
      );
      module.exports = canUseDOM;
    },
    AytR: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return environment;
      });
      const environment = {
        production: !0,
        hmr: !1,
        version: '1.0.0',
        serverUrl: 'https://api.chucknorris.io',
        defaultLanguage: 'en-US',
        supportedLanguages: ['en-US', 'fr-FR', 'es'],
        rtl: !1
      };
    },
    BFxc: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return takeLast;
      });
      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          '7o/Q'
        ),
        _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          '4I5i'
        ),
        _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'EY2u'
        );
      function takeLast(count) {
        return function(source) {
          return 0 === count
            ? Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__.b)()
            : source.lift(new TakeLastOperator(count));
        };
      }
      class TakeLastOperator {
        constructor(total) {
          if (((this.total = total), this.total < 0))
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__.a();
        }
        call(subscriber, source) {
          return source.subscribe(
            new TakeLastSubscriber(subscriber, this.total)
          );
        }
      }
      class TakeLastSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(destination, total) {
          super(destination),
            (this.total = total),
            (this.ring = new Array()),
            (this.count = 0);
        }
        _next(value) {
          const ring = this.ring,
            total = this.total,
            count = this.count++;
          ring.length < total
            ? ring.push(value)
            : (ring[count % total] = value);
        }
        _complete() {
          const destination = this.destination;
          let count = this.count;
          if (count > 0) {
            const total = this.count >= this.total ? this.total : this.count,
              ring = this.ring;
            for (let i = 0; i < total; i++) {
              const idx = count++ % total;
              destination.next(ring[idx]);
            }
          }
          destination.complete();
        }
      }
    },
    Bs8V: function(module, exports, __webpack_require__) {
      var DESCRIPTORS = __webpack_require__('g6v/'),
        propertyIsEnumerableModule = __webpack_require__('0eef'),
        createPropertyDescriptor = __webpack_require__('XGwC'),
        toIndexedObject = __webpack_require__('/GqU'),
        toPrimitive = __webpack_require__('wE6v'),
        has = __webpack_require__('UTVS'),
        IE8_DOM_DEFINE = __webpack_require__('DPsx'),
        nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      exports.f = DESCRIPTORS
        ? nativeGetOwnPropertyDescriptor
        : function(O, P) {
            if (
              ((O = toIndexedObject(O)),
              (P = toPrimitive(P, !0)),
              IE8_DOM_DEFINE)
            )
              try {
                return nativeGetOwnPropertyDescriptor(O, P);
              } catch (error) {}
            if (has(O, P))
              return createPropertyDescriptor(
                !propertyIsEnumerableModule.f.call(O, P),
                O[P]
              );
          };
    },
    CBKz: function(module) {
      module.exports = JSON.parse(
        '{"APP_NAME":"DefAgent","About":"Sobre Nosotros","Hello world !":"¡Hola Mundo!","Home":"Inicio","Logged in as":"Registrarse","Login":"Iniciar Sesión","Logout":"Cerrar Sesión","Password":"Contraseña","Password is required":"Se Requiere Contraseña","Username":"Nombre De Usuario","Username is required":"Se Requiere Nombre De Usuario","Username or password incorrect.":"Usuario O Contraseña Incorrectos.","Remember me":"Recordar","Version":"Versión","ACTIONS":{"FORM_REGISTER_SIMPLE_INLINE":{"CHECK_YOUR_EMAIL":"Revisa Su Correo Electrónico","WE_SENT_YOU_AN_EMAIL":"Le Enviamos Un Correo Electrónico Con Un Enlace Para Comenzar. Estarás En Tu Cuenta En Poco Tiempo."},"FORM_REGISTER_COMPANY":{"NAME":"Nombre","EMAIL":"E-mail","COMPANY":"Empresa","SEND_MY_APPLICATION":"Enviar Mi Solicitud"}},"NAVBAR":{"DEFAULT":{"HOME":"Inicio","ABOUT":"Sobre nosotros","CONTACT":"Contacto","DEMOS":"Soluciones","COMPANY":"Segmentos","HUMAN_RESOURCE":"Agentes AI ","SALES":"Procesos","CUSTOMER_SERVICE":"Servicio Al Cliente","MODULES":"Módulos","CALENDAR":"Drones","PRODUCT":"Verticales","HEALTH":"Salud","DEVELOPERS":"Desarrolladores","RPA_CREATORS":"Creadores De RPA","SERVICES":"Marketplace","DATAFLOWS_CREATORS":"Creadores De Dataflows","SAAS":"Bienes Raíces","START_UP":"Startup","FOR_STORY_TELLERS":"Para StoryTellers","AWESOME_DESIGN_BLOCKS":"Bloques Impresionantes","FOR_DEVELOPERS":"Para Desarrolladores","THE_DEVELOPERS_PLACE":"El lugar de los desarrolladores","YOUR_BUSINESS":"Tu Negocio","OUT_BEST_BET":"Nuestra Mejor Apuesta Es Usted, Podemos Asegurarle Que EveryThink Se Ajusta A Sus Necesidades.","VIEW_PLAN":"Ver Planes","LANGUAGE":"Idioma","EN":"Inglés","ES":"Español","LOGIN":"Iniciar","SIGNUP":"Registrarme"}},"SLIDERS":{"SLIDER_CARD_PROJECTS":{"NEW_SUBSCRIBERS":"Nuevos Suscriptores","NEXT":"Siguiente"},"SLIDER_START_RIGHT_WAY":{"FOR_EVERYONE":"DefAgent AIs Para Profesionales","EVERYTHINK_DOES_ALL":"DefAgent Hace TODO EL TRABAJO PESADO Al Automatizar Los Procesos Repetitivos Para Que Pueda Concentrarse En Tareas Más Complejas Y Lograr Niveles De Eficiencia Sin Precedentes.","START_THE_RIGHT_WAY":"Empiece De La Manera Correcta","START_WITH_EVERy_THINK":"Empiece Con DefAgent","THINKING_ABOUT_YOUR_AI_JOURNEY":"¿Estás Pensando En Tu Viaje Con AIs?","CHOOSE_THE_RIGHT_PLAN":"Elige el plan adecuado para ti"},"SLIDER_BRING_TO_LIFE":{"ADMIN_TEMPLATE_INCLUDED":"Paneles de administración incluidos","WE_INCLUDED_A_FULLY_FUNcTIONAL":"Hemos incluido paneles de administración de inicio completamente funcionales","POWER_WITH_MULIPLE_STARTER_APPS":"Desarrollado por DefAgent","ITS_AWESOME_YOU_TO":" Tenemos nuevas features que te van a encantar!","SIMPLE_AND_TRANSPARENT":"Sencillo y transparente","BRING_YOU_APPLICAION_TO_LIFE":"Da vida a tu AIs","DASHCORE_INCLUDED":"DefAgent incluye una excelente interfaz de usuario del panel de administración de inicio. Con esta función, puede comenzar a desarrollar sus aplicaciones de inmediato.","CLEAN_INBOX_UI":"Fácil de usar"},"SLIDER_ALL_IN_ONE":{"EVERYTHINK_YOU_NEED":"Todo lo que necesita - ¡todo en su mano!","REAL_TIME_SOLUTION":"Solución","STREAMLINES_PROCESSES":"En Tiempo real","AFFORDABILLITY":"Conviértete en ultrarrápido en tiempo real. Cree sus propias aplicaciones de marca blanca. Obtenga información valiosa sobre clientes, mercados y procesos y logre mucho más con nuestra poderosa herramienta habilitada para IA.","SINCE_THE_NEED_FORHUMAN":"Alcance global","EVERYTHINK_DOES_ALL":"Cierre más acuerdos con menos fricción. Gana más listados con mayor facilidad. Optimice sus esfuerzos mediante la automatización y los predictores. Obtenga una ventaja competitiva con mayor funcionalidad y eficiencia.","ALWAYS_ON_TIME":"Siempre a tiempo","UNIQUE_USER)EXPERIENCE":"Experiencia","A_NEW_AND_INTUITIVE_EXPERIENCE":"Única","ESPECIALLY_WHEN_YOUR_CLIENTS_NEEDS":"Aproveche la plataforma de código bajo impulsada por AIs de DefAgent para optimizar los procesos y brindar experiencias sin esfuerzo, instantáneas y mucho más enriquecedoras para compradores, vendedores, agentes inmobiliarios y todos los involucrados.","OUTSTANDING":"","ANALYTICS":"Excepcional","SIT_BACK_AS_YOUR":"DefAgent AIaaS ofrece mucho más que una perfecta absorción y emisión de datos. Estos AIs ,enseñables, recopilan y revisan las interacciones de los usuarios para su análisis e iteración.","CONTINUOUSLY_CHECK_IN":"Consulte continuamente con sus AIs para obtener nuevas sugerencias sobre la automatización de procesos o formas de brindar mejores soluciones a sus clientes y empleados."}},"SCREENSHOTS":{"APP":{"APP_SCREENSHOTS":"Crea tus agentes de IA en un solo lugar y automatiza todos los procesos","A_PICTURE_IS_WORTH_A_THOUSAND_WORDS":""}},"HOME":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - PLATAFORMA DE AGENTES DE IA PARA LA DEFENSA","KEYWORDS":"Network Search, Networks directory App Landing1"},"APP_LANDING_HEADING":{"HEADING":{"AWARDED":"Seleccionado Por El Programa De Emprendedores Globales Del Gobierno Británico","HR_CONSULTIN":"DefAgent","CONSULTANT":"PLATAFORMA DE AGENTES DE IA PARA LA DEFENSA","IAS":"Con un sistema propietario de agentes de IA, DefAgent te permite pasar de la idea al producto listo para producción, eliminando la necesidad de encontrar un cofundador técnico o contratar desarrolladores. Simplemente explica tu idea de negocio como lo harías con un desarrollador humano, y nosotros nos encargamos del resto: producto, pagos, seguridad, infraestructura, escalabilidad y más.","GERSTARTED":"Comenzar","WHAT_YOU_GET":"Lo Que Obtienes"},"FEATURE_CARDS":{"WHAT_YOU_GET":"Lo Que Obtienes","WITH_A_SINGLE_TOOL":"Implementa soluciones en tiempo real de forma fácil y rápida sin necesidad de un profesional de tecnología dedicado. Ninguna otra solución en el mercado iguala nuestras:"},"TWIN_PHONE_LEFT_LIST":{"WE_ARE_YOUR_PATH_TO_SUCCESS":"Tipos de agentes de IA en defensa"},"TWIN_PHONE_LEFT_RIGHT":{"WE_HAVE_A_TON_OF_BENEFITSS":"Nosotros tenemos toneladas de beneficios","EVERYTHINK_DOES_ALL_OF":"DefAgent hace TODO EL TRABAJO PESADO para que usted pueda concentrarse en tareas más valiosas y complejas."},"DOWNLOAD":{"START_TODAY":"Comienza Hoy","DOWNLOAD_THE_APP":"Descargar La Aplicación","DOWNLOAD_EVERYTHING":"Posicione Su Negocio Hacia El Éxito. ¡Descarga La Aplicación DefAgent Ahora Y Comienza Tu Viaje Con AIs! Disponible En Dispositivos Windows, Mac, iOS y Android.","GET_IT_ON_THE":"Consígalo En","APP_STORE":"App Store","DOWNLOAD_ON":"Descargar En","GOOGLE_PLAY":"Google Play"}}},"DEMOS":{"HUMANRE_SOURCES":{},"SALES":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - Sales","KEYWORDS":"Network Search, Networks directory Sales"},"APP_LANDING_HEADING2":{"ALLISONE":"Todo es uno,","INFINTY":"donde comienza el infinito","EVERYTHINKFORSALES":"DefAgent","BETTERMARKETING":"Los agentes impulsados ​​por IA se están convirtiendo en recursos invaluables","BETTERRESULT":" en el Departamento de Defensa (DoD)","OURIAS":"Revolucionando la forma en que combatimos al optimizar el trabajo y agilizar la toma de decisiones. Estos agentes destacan en la automatización de tareas de bajo nivel y bajo riesgo, permitiendo a los combatientes concentrarse en decisiones vitales y cruciales para la misión.","SUBSCRIBENOW":"Registrarse ahora"},"APP_LANDING2_TRENDING_DESIGN":{"SIMPLE_IMPLEMENTATION":"Implementación simple con impacto exponencialmente positivo","SINCE_THE_NEED":"Dado que se reduce la necesidad de intervención humana y aumenta la eficiencia del flujo de trabajo, el proceso es muy asequible.","THE_POSSIBILITIES":"Las posibilidades de usar DefAgent para defensa están en todas partes y solo se limitan al ingenio de los usuarios que desean utilizar los agentes ia para mejorar y simplificar sus procesos"},"APP_LANDING2_FOCUS_ON_SUCCESS":{"FORGET_OBSOLETE":"¡Olvídese de los sistemas obsoletos y las costosas inversiones!","EVERYTHINK_DELIVERS":"DefAgent ofrece una experiencia única y revolucionaria en la que los AI hablan e interactúan directamente con empleados, clientes y proveedores para comprender sus necesidades y conectarlos con personas, procesos y dispositivos en tiempo real.","DOT_NOT_WASTE_TIME":"¡Ayuda a tu equipo a ser más productivo y rentable! ¡Deja de perder tiempo valioso y empieza a obtener resultados significativos ahora!"},"APP_LANDING2_SAFETY":{"SAFETY_FIRST":"Tú primero","YOUR_SUCCESS_IS_OUR_SUCCESS":"¡El éxito de tu negocio es nuestra prioridad!","EVERYTHINK_DOESALL":"DefAgent ayuda a su equipo a automatizar procesos rutinarios, procesar grandes cantidades de datos e incluso manejar tareas más complejas."},"APP_LANDING2_POPPING_HIGHLIGHT":{"DISCOVER_CREATE_LOVE":"Descubrir. Empoderar. Ganar.","SEE_WHY_PEOPLE_LOVE_EVERTTHINK":"Vea por qué la gente ama DefAgent"},"APP_LANDING2_DOWNLOAD":{"START_TODAY":"Comienza Hoy","DOWNLOAD_THE_APP":"Descargar La Aplicación","DOWNLOAD_EVERTTHINK":"Descargue La Aplicación DefAgent Ahora Y Conéctese En Dispositivos Windows, Mac, iOS Y Android. ¡Comience Con Su A.I. Viaje!","GET_IT_ON_THE":"Consígalo En","APP_STORE":"App Store","DOWNLOAD_ON":"Descargar En","GOOGLE_PLAY":"Google Play"}},"CUSTOMER_SERVICE":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - Network search  ","KEYWORDS":"Network Search, Networks directory network search"},"AUTOMATE_SOCIAL_HEADING":{"EVERYTHINK_FOR_CUSTOMER_SERVICE":"DefAgent Customer Service","DONT_THINK_IT":"No lo pienses; ni siquiera respondas, porque lo tenemos!","DRIVE_YOUR_BUSINESS_FORWARD":"¡Impulse su negocio con AIs de atención al cliente administrados en la palma de sus manos!"},"AUTOMATE_SOCIAL_GET_STARTED":{"ALL_IN_ONE":"Solución de servicio al cliente todo en uno","EVERTTHINK_YOU_NEED_IN_ONE_SOLUTION":"Obtenga todo lo que necesita en una solución.","EVERTTHINK_YOU_NEED_IN_ONE_SOLUTION1":"Cree experiencias consistentes y sin esfuerzo; y reduzca costos con una poderosa herramienta de automatización del servicio al cliente.","INTRODUCING":"","COMMUNICATE_BETTER":"¡Capte la comunicación adecuada para cada uno de sus clientes y obtenga conocimiento y estadísticas para brindar soluciones asertadas en tiempo real!","NO_CREDIT_CARD_NEEDED":"¡Emprende tu AI viaje!","START_NOW":"Empieza ahora","BY_REGISTERING":" Al registrarse, obtendrá 14 días de acceso gratuito a DefAgent."},"AUTOMATE_SOCIAL_WHY":{"WHY_EVERYTHINK":"¿Por qué DefAgent?","OUR_MISSION_IS_TO_PROVIDE_YOU":"Nuestro objetivo es brindar automatización precisa de todo su servicio al cliente conectando actores, procesos y dispositivos en tiempo real. Más aún, también proporciona métricas basadas en estrategias que facilitan la medición del rendimiento empresarial frente a los objetivos previstos."},"AUTOMATE_SOCIAL_AUTOMATION_SOLUTION":{"ADVANCED_CUSTOMER":"Solución avanzada de automatización del servicio al cliente","DESCRIPTION":"Los AIs de DefAgent están preparados para ayudar a las marcas a brindar experiencias superiores de atención al cliente y compromisos de revisión a través de los canales digitales. ¡Esta es la mas avanzada  automatización del servicio al cliente en sus manos!","OUR_INTELLIGENT_ASSISTANTS":" Our Intelligent Assistants are poised to cause significant changes and  disruption on how your Customer Service functions make service delivery, and best of all, it is always right there in your palms."}},"DEVELOPERS":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - developer","KEYWORDS":"Network Search, Networks directory developer"},"HEADING":{"WELCOME_DREAMERS":"Bienvenidos soñadores!","CREATE_EMOTIONS":"Crea emociones para los Asistentes Inteligentes","SHOW_VIDEO":"Ver video"},"INTEGRATioNS":{"KNOW_WHAT_YOU_CAN_DO_WITH_US":"Sepa lo que puede hacer con nosotros","LEARN_MORE":"Saber más"},"TOOL":{"INTEGRATION_TOOLS":"","EASY_INTEGRATIONS":"","LOREM_IPSUM":"","LOREM_IPSUM_DOLOR":"","INTEGRATE":""}},"HEALTH":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - corporate","KEYWORDS":"Network Search, Networks directory corporate"},"CORPORATE":{"EVERYTHINK_MAKE_TREATMENT_MORE":"DefAgent hace que los tratamientos sean más efectivos y los pacientes más seguros, ahorrando dinero a los hospitales y seguros médicos.","LEARN_MORE":"Aprender mas","80_OF_THE_CASE_ARISE":"El 80% de los casos surgen por falta de comunicación durante las transiciones asistenciales, más de 7000 muertes y 500.000 lesiones prevenibles son costos por errores de medicación. Sin mencionar que 3 de cada 10 laboratorios se reordenan porque los resultados se pierden en el proceso. El 18% de los pacientes médicos hospitalarios son readmitidos en un mes.","DID_YOU_KNOW":"¿Sabías que los errores médicos son la tercera causa principal de muerte en los EE. UU.?","HEADING":{"EVERYTHINK_FOR_HEALTH":"DefAgent Health","WELCOME_TO_THE_FUTURE":"Impulsando la próxima ola de innovación significativa en el cuidado de la salud, ¡no se quede atrás!","WITH_THE_RIGHT_DATA":"Obtenga información y aproveche datos radicalmente interoperables para acelerar la investigación de la salud, marcar el comienzo de una nueva era de optimización de tratamientos, desarrollo de fármacos, predicción de resultados, diagnóstico y pronóstico de enfermedades, participación del paciente y mejor salud pública.","START_NOW":"¡Comienza ahora!","PLANS_AND_PRICEING":"Planes y precios"},"BUSINESS":{"LETS_DO_BUSINESS":"Empecemos","WHAT_EVERYTHINK_OFFERS":"Que Ofrecemos"},"EVERYTHINK_IS_THE_SOLUTION":"DefAgent aumenta la experiencia médico-paciente. Con este software como herramienta de AIaaS en la base de sus interacciones de prestación de atención médica, se pueden prevenir la mayoría de los errores médicos. La tecnología integra los registros de los pacientes en un único lugar altamente seguro que permite compartirlos fácilmente dentro y fuera de la red, para beneficio tanto de los pacientes como del personal médico."}},"RPACREAORS":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - online payment","KEYWORDS":"Network Search, Networks directory online payment"},"ONLINE_PAYMENT":{"HEADING":{"GO_BIG":"¡Ve a lo grande o vuelve a casa!","CREATE_BUY":"Crea, compra y vende procesos automatizados.","WITHOUT_CODING":"- Sin codificación.","KNOW_MORE":"Saber más","START_NOW":"Comenzar ahora"},"FEATURES":{"REASONS_TO_USE_EVERYTHINK":"Razones para usar DefAgent","KNOW_WHAT_YOU_CAN_DO_WITH_US":"Sepa lo que puede hacer con nosotros"},"CUSTOMERS_MANAGEMENT":{"CREATE_SMART":"Crea experiencias","EXERIENCES_WITH":"Inteligentes con","EVERYTHINK":"DefAgent Studio","SIMPLE_IMPLEMENTATION":"Implementación simple con impacto exponencialmente positivo.","CUSTOMERSADMINISTRATION":"Administración de clientes."}}},"DATAFLOWS_CREATOORS":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - integration","KEYWORDS":"Network Search, Networks directory integration"},"INTEGRATION":{"HEADING":{"CREATE_EMOTIONS_FOR_SMART_ASSISTANTS":"Crea emociones para los Asistentes Inteligentes","CREATE_BUY_AND_SELL":"Crear, Comprar y Vender flujos de datos para capacitar a Smart Assistants para las diferentes conversaciones geolocalizadas necesarias para cada uno de los actores que participan en cada red, comunidad y canal.","JOIN_EVERY_TTHINK":"Unirse DefAgent"},"HOW_IT_WORK":{"KNOW_WHAT_YOU_CAN_DO_WITH_US":"Sepa lo que puede hacer con nosotros","EVERYTHINK_DOES_ALL":"DefAgent hace TODO EL TRABAJO PESADO para que pueda concentrarse en tareas más valiosas y complejas."},"BUILT_TECH":{"INDUSTRY_LEADING":"Líder en la industria","TECHNOLOGY":"tecnología","EVERYTHINK_STUDIO":"DefAgent Studio le ofrece todo lo que usted y su empresa necesitan para crear flujos de datos sólidos. ¡Todo sin codificación!","ONE_STEP_AHEAD_OF_AIS":"Un paso por delante de los AIs","EMPOWER_THE_INTELLIGENT":"Empodere a los Asistentes inteligentes proporcionando nuevas interacciones creadas por usted, lo que eleva sus habilidades para resolver problemas en tiempo real."},"EXTEND_CORE":{"LIMITLESS_POSSIBILITIES":"Posibilidades ilimitadas","BUILD_FAST_BUILD_MORE":"Construye rápido. Construir más.","USING_EVERYTHINK":"Con el software exclusivo de DefAgent Studio para el desarrollo de flujos de datos rápidos y fluidos, puede crear e implementar todos los flujos de datos que necesita en minutos. No se requieren habilidades técnicas, de programación o de scripting.","KNOW_MORE":"Saber más","REGISTER_ACCOUNT":"Registrar Cuenta"},"LATEST_PROJECTS":{"EVERYTHINK_MARKETPLACE":"DefAgent Marketplace","TAKE_A_LOOK_AT_OUR_LATEST_PROJECTS":"¡Eche un vistazo a nuestros últimos proyectos, aquellos clientes que confían en nuestros servicios para llevar su negocio al siguiente nivel!","SOMOS_PILEROS":"Somos Pileros","WE_BUILT_DATA":"Creamos flujos de datos para conectar a emprendedores con voluntarios y mentores de manera más rápida y eficiente al automatizar el proceso de búsqueda y conexión entre usuarios, en tiempo real."},"REGISTER":{"FILL_IN_THE_FORM":"Complete el formulario","YOUR_SUCCESS_IS_OUR_SUCCESS":"Su éxito es nuestro éxito","IF_YOU_ARE_LOOKING":"Si está buscando ser parte de la red DefAgent, solo complete el formulario, ¡estamos seguros de que podemos construir grandes cosas juntos!"},"WHY_CHOOSE_US":{"SIMPLE_IMPLEMENTATION_WITH":"Implementación simple con impacto exponencialmente positivo","SINCE_THE_NEED_FOR_HUMAN":"Dado que se reduce la necesidad de intervención humana y aumenta la eficiencia del flujo de trabajo, el proceso es muy asequible.","KNOW_MORE":"Saber más"}}},"SAAS":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - saas","KEYWORDS":"Network Search, Networks directory saas"},"HEADING":{"EVERYTHINK_FOR_REAL_ESTATE":"DefAgent Real Estate","YOU_AGENT_IN_YOUR_HANDS_WITHGLOBAL_REACH":"¡Tu agente en tus manos con alcance global!","OUT_IAS_ARE_POISED":"Nuestros AIs revolucionarán la prestación de servicios inmobiliarios con la automatización de procesos y las innovaciones basadas en inteligencia artificial. Mejor aún, siempre está ahí en tus palmas.","PLANS_AND_PRICING":"Planes","START_NOW":"Comienza ahora"},"LIGHTWEIGHT_TEMPLATE":{"YOUR_SMART_PUPPETS":"Tus propias marionetas inteligentes","WILL_PROVIDE_YOUR_PROSPECTS_AND_CLIENTS":"Con DefAgent como plataforma de servicio, nuestros AIs pueden ayudar a ser extremadamente receptivos en tiempo real; obtener información valiosa sobre prospectos, clientes, mercados y procesos; aprovechar datos valiosos para abordar las necesidades de los clientes y cerrar más ventas, lograr una mayor transparencia del sistema; y mejorar la eficiencia general.","SIMLIFYING_THE_CURRENT":"","LEARN_MORE":"Saber mas"},"BUILD_TO_LAST":"Built to Last","WHAT_YOU_WILL_GET_WITH_EVERTTHINK":"Lo Que Obtienes","GEOLOCATED_INTELLIGENT_ASSISTANTS":"Automatice Su Proceso De Reserva Con DefAgent Calendar Y Céntrese Solo En Lo Que Importa","DASHBORD_INCLUDED":"Tableros incluidos","SIMPLE_IMPLEMENTATION":"Implementación simple con impacto exponencialmente positivo","SINCE_THE_NEED_FOR_HUMAN":"Dado que se reduce la necesidad de intervención humana y aumenta la eficiencia del flujo de trabajo, el proceso es muy asequible.","THE_POSSIBILITIES":"Las posibilidades de usar DefAgent for Sales están en todas partes y solo se limitan al ingenio de los usuarios que desean utilizar la inteligencia artificial para mejorar su calidad de vida.","Learn_More":"Saber mas"},"START_UP":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - Drone detection system","KEYWORDS":"Drone detection system, ai, blockchain"},"HEADING":{"DELIVERING_THE_TOOLS":"Asegure sus cielos: Drones avanzados","YOU_NEED_TO_SUCCEED":"Soluciones de detección y defensa","IT_ALL_BEGINS_BY_CHOSSING":"Protegiendo su espacio aéreo con tecnología de vanguardia de detección, seguimiento y mitigación","TRY_IT_FREE":"COMIENZA AHORA!"},"WHAT_YOU_GET":{"WHAT_YOU_WILL_GET_WITH_EVERTTHINK":"What You Get","GEOLOCATED_INTELLIGENT_ASSISTANTS":"Automate Your Booking Process With DefAgent Calendar And Focus Only On What Matters","BUSINESS_TITLE":"Detección en tiempo real","PAYMENTS_TITLE":"Rastreo preciso","SCHEDULES_TITLE":"Análisis integral de amenazas","SITE_TITLE":"Monitoreo del espacio aéreo 24/7","BUSINESS_DESC":"Identifique al instante drones no autorizados en su espacio aéreo con radar avanzado, escaneo de radiofrecuencia y sensores con inteligencia artificial.","PAYMENTS_DESC":"Identifique la ubicación exacta, la velocidad y la trayectoria de vuelo de drones intrusos para una respuesta proactiva.","SCHEDULES_DESC":"Diferenciar entre drones, aves y otros objetos para reducir las falsas alarmas y garantizar alertas fiables.","SAVING_DESC":"Vigilancia continua para proteger su propiedad, eventos o infraestructura crítica las 24 horas."},"PRICING":{"TITLE":"DefAgent Calendar","SUBTITLE":"Funciona Con Cualquier Tipo De Negocio Y Cualquier Tipo De Programación De Citas","BUY":"Comprar Ahora","PLAN_PERSONAL":"Uno A Uno","PLAN_PERSONAL1":"Terapeutas","PLAN_PERSONAL2":"Entrenadores personales","PLAN_PERSONAL3":"Recursos Humanos y contratación","PLAN_PERSONAL4":"Veterinarias","PLAN_PERSONAL5":"Equipos de ventas y consultores","PLAN_PERSONAL_DESC":"","PLAN_BUSINESS":"Grupal","PLAN_BUSINESS1":"Gimnasio y Estudio de fitness","PLAN_BUSINESS2":"Operadores turísticos","PLAN_BUSINESS3":"Escuelas de idiomas","PLAN_BUSINESS4":"Escuelas y Universidades","PLAN_BUSINESS5":"Eventos, Talleres y Seminarios","PLAN_BUSINESS_DESC":"","PLAN_ENTERPRISE":"Reservas","PLAN_ENTERPRISE1":"Alquiler lugares/equipos","PLAN_ENTERPRISE2":"Estudio fotografico","PLAN_ENTERPRISE3":"Programación de recursos","PLAN_ENTERPRISE4":"Salas de conferencias y reuniones","PLAN_ENTERPRISE5":"Reservas de canchas deportivas","PLAN_ENTERPRISE_DESC":"","PLAN_BUSINESSD":"Servicios","PLAN_BUSINESSD1":"Salones de belleza","PLAN_BUSINESSD2":"Profesionales médicos","PLAN_BUSINESSD3":"Instructores de manejo","PLAN_BUSINESSD4":"Profesionales de la reparación","PLAN_BUSINESSD5":"Servicios de limpieza y hogar","PLAN_BUSINESSD_DESC":""},"PRICING_TWO":{"TITLE":"Affordable pricing plans.","TITLE0":"Avance Y","TITLE01":"Obtenga Su Descuento","TITLE1":"DefAgent Calendar","TITLE11":"Licencia","TITLE2":"Hoy!","TITLE22":"Elija Su Plan:","SUBTITLE":"","BUY":"Comprar Ahora","MONTHLY":"Mensualmente","ANNUAL":"Anualmente","DISCOUNT":"(Ahorre hasta un 30% de descuento en planes anuales)","GETNOW":"Obtenerlo Ahora","CUSTOM":"Para Equipos","CUSTOM1":"(Mejor Valor)","CUSTOM2":"Para Equipos Y Empresas Con Necesidades De Programación Adicionales, Personalización Y Funciones Avanzadas","CUSTOM3":"Contactenos","PLAN_BASIC":"Para Individuales","PLAN_BASIC_DESC":"Todo Lo Que Puede Obtener De Una Solución Profesional Para Mantener Su Negocio En Camino Hacia El Éxito","FEATURES1":"200 Número Máximo De Próximas Citas","FEATURES2":"1 Integración Para Cobrar Pagos","FEATURES3":"50 Invitaciones Por SMS Gratis","FEATURES4":"DefAgent Calendar En Tu Sitio Web","FEATURES5":"Marca Personalizada","FEATURES6":"Webhooks","FEATURES7":"Soporte En Tiempo Real","FEATURES8":"Flujos De Trabajo","FEATURES9":"Informes En Tiempo Real","FEATURES10":"Paquetes De Marketing","FEATURES11":"Más De 700 Integraciones De Aplicaciones Con Zapier","FEATURES12":"Conécte A Zoom, Microsoft Teams, Google Meet Y GoToMeeting"},"FEATURES":{"BUSINESS_TITLE":"Seguridad mejorada","PAYMENTS_TITLE":"Detección de amenazas en tiempo real","SCHEDULES_TITLE":"Prevención del espionaje y la vigilancia","SAVING_TITLE":"Mitigación del contrabando y las entregas de contrabando","INTERFACE_TITLE":"Garantizar la seguridad pública","SITE_TITLE":"Reducir las falsas alarmas","BUSINESS_DESC":"Proteja su propiedad, eventos o infraestructura crítica de intrusiones no autorizadas con drones.","PAYMENTS_DESC":"Identifique y rastree drones al instante, garantizando una respuesta oportuna ante posibles amenazas.","SCHEDULES_DESC":"Proteja la información confidencial y la privacidad del espionaje con drones.","SAVING_DESC":"Evite que los drones entreguen artículos ilegales a zonas restringidas como prisiones o instalaciones de seguridad.","INTERFACE_DESC":"Proteja Grandes reuniones, como conciertos, eventos deportivos o espacios públicos, de drones no autorizados.","SITE_DESC":"La IA avanzada y el aprendizaje automático diferencian los drones de aves, aviones u otros objetos.","DASHCORE_FEATURE":"Características de DefAgent","WHAT_DASHCORE_CAN_DO":"Beneficios de usar un sistema de detección de drones","LOREM_IPSUM":"Con DefAgent, en menos de 24 horas, una organización puede crear asistentes inteligentes geolocalizados que gestionarán datos y adaptarán las necesidades a las soluciones mediante la interconexión de personas, procesos automatizados y dispositivos en tiempo real, midiendo constantemente el rendimiento de cada actor del negocio, todo sin necesidad de programar."},"WHY_DASHCORE":{"WHY_DASHCORE_TEMPLATE":"Implementar un sistema de detección de drones","WHEN_LOOKING":"requiere una planificación cuidadosa, la tecnología adecuada y la integración con la infraestructura de seguridad existente. Aquí tiene una guía paso a paso para ayudarle a comprender el proceso de implementación","DEVELOPERS":"Evalúe sus necesidades","ENGAGING_DEVELOPERS0":"","ENGAGING_DEVELOPERS01":"Identifique el área a proteger (p. ej., propiedad pequeña, instalación grande o cobertura de área extensa).","ENGAGING_DEVELOPERS1":"Determine el nivel de amenaza (p. ej., vigilancia, contrabando o drones maliciosos).","ENGAGING_DEVELOPERS11":"","ENGAGING_DEVELOPERS2":"Defina su presupuesto y objetivos (p. ej., solo detección o detección y mitigación).","ENGAGING_DEVELOPERS22":"","LOREM_IPSUM":"","DESIGNER":"Elija la tecnología adecuada","ENGAGING_DESIGNER0":"","ENGAGING_DESIGNER01":"Radar para detección de largo alcance.","ENGAGING_DESIGNER1":"Escáneres de radiofrecuencia para detectar señales de comunicación de drones.","ENGAGING_DESIGNER11":"","ENGAGING_DESIGNER2":"Cámaras ópticas/infrarrojas para confirmación visual.","ENGAGING_DESIGNER22":"","REMINDERS":"Inspección del sitio y planificación de la instalación","ENGAGING_REMINDERS0":"","ENGAGING_REMINDERS01":"Realice una inspección del sitio para identificar las ubicaciones óptimas para los sensores y las cámaras.","ENGAGING_REMINDERS1":"Asegure la cobertura de todos los puntos de entrada y áreas vulnerables.","ENGAGING_REMINDERS11":"","ENGAGING_REMINDERS2":"Considere Factores ambientales como el clima, el terreno y las interferencias.","ENGAGING_REMINDERS22":"","PAYMENTS":"Instalar hardware y sensores","ENGAGING_PAYMENTS0":"","ENGAGING_PAYMENTS01":"Montar sensores, cámaras y otro hardware en ubicaciones estratégicas.","ENGAGING_PAYMENTS1":"Asegurar una calibración y alineación adecuadas para obtener la máxima precisión.","ENGAGING_PAYMENTS11":"","ENGAGING_PAYMENTS2":"Configurar enlaces de comunicación entre los sensores y el sistema de control central.","ENGAGING_PAYMENTS22":"","PAGE":"Configurar software e IA","ENGAGING_PAGE0":"","ENGAGING_PAGE01":"Configurar el software de control central para la monitorización y las alertas en tiempo real.","ENGAGING_PAGE1":"Entrenar algoritmos de IA para diferenciar drones de aves, aviones u otros objetos.","ENGAGING_PAGE11":"","ENGAGING_PAGE2":"Personalizar la configuración de alertas (p. ej., correo electrónico, SMS o alarmas visuales/auditivas).","ENGAGING_PAGE22":""},"VIDEOs":{"HOW_TO_VIDEO":"¿Porque Nosotros?","TAKE_A_LOOKING_AT":"Liderando el camino en detección de drones y seguridad aérea","1_TITLE":"Tecnología de vanguardia","1_DESC":"Utilizamos los últimos avances en radar, escaneo de radiofrecuencia, IA y aprendizaje automático para ofrecer los sistemas de detección de drones más precisos y fiables.","2_TITLE":"Soluciones integrales","2_DESC":"Desde la detección y el seguimiento hasta la mitigación, ofrecemos soluciones integrales adaptadas a sus necesidades específicas.","3_TITLE":"Experiencia comprobada","3_DESC":"Con años de experiencia en seguridad y tecnología de drones, comprendemos los desafíos y ofrecemos resultados comprobados."}}},"PROJECT":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - Networks directory","KEYWORDS":"Network Search, Networks directory"},"FOR_DEVELOPERS":{},"FORSTORYTELLERS":{},"VIEW_PLANAND_PRICE":{}},"FAQS":{"FAQS1":{"DO_YOU_HAVE":"¿Tienes ","QUESTIONS":"preguntas?","NOT_SURE_HOW":"¿No estás seguro de cómo DefAgent puede ayudarte? ¿Se pregunta por qué necesita comenzar su viaje de IA?","HERE_ARE_THE_ANSWERS":"Puedes consultarnos cualquier duda. Sin embargo, aquí están las respuestas a las preguntas más comunes que nos hacen nuestros estimados clientes."}},"COUNTER":{"COUNTER1":{"MILLIONS_BUSSINESS":"¡Millones confían en DefAgent para encontrar y retener a los mejores talentos!","THESE_AMAZING_STATS":"Numerosas marcas y empresas de todo el mundo utilizan DefAgent AIaaS y las capacidades de computación cognitiva para optimizar sus flujos de trabajo de recursos humanos. ¡Los números no mienten y estas increíbles estadísticas no pueden estar equivocadas!"},"COUNTER1_L2":{"MILLIONS_BUSSINESS":"¡Muchas empresas confían en DefAgent para mejorar el rendimiento de sus ventas!","THESE_AMAZING_STATS":"Las empresas y las marcas de todo el mundo están aprovechando nuestra poderosa tecnología de talento para aumentar su volumen de clientes potenciales, su tasa de cierre y el rendimiento total de las ventas. ¡Mira nuestros números!"},"COUNTER2":{"WHY_CUSTOMER_TRUST_US":"Por qué el cliente confía en nosotros","HAPPY":"Clientes","CUSTOMER":"Felices","THESE_AMAZING_STATS":"Estas increíbles estadísticas pueden estar equivocadas, muchos clientes felices de todo el mundo confían en nuestro servicio para impulsar su negocio.","TONS_OF_SUCCESSFULL_IMPLEMENATION":"Toneladas de implementaciones exitosas","USERS_IMPROVE_THEIR_ABILITY":"DefAgent eleva la eficiencia y la productividad, aumentando también la satisfacción laboral. Esta plataforma de código bajo también garantiza una facilidad de implementación excepcional, por lo que cientos de miles de marcas en todo el mundo confían en ella.","ALL_POWERED_BY":" Impulsado por un motor cognitivo que puede desarrollar personajes para varios roles, para completar diferentes funciones dentro de la empresa.","LEARN_MORE":"Saber más"},"COUNTER3":{"AMAZING_STATS":"Estadísticas asombrosas","EVERYTHINK_CREaTES_A_POWERFUL_AND_EFFECTIVE":"¡Aproveche el poderoso software AIaaS de EveryThink para implementar un modelo comercial de economía circular!","EACH_USER_IS_EMPOWERED":"Los usuarios tienen la capacidad de mejorar su networking e impulsar el desempeño laboral."},"COUNTER6":{"SUCCESSFULL_IMPLEMENTATIONS":"Más de 1 millón de implementaciones exitosas","GET_THEVERY_BEST":"Saca lo mejor de nosotros haciendo lo mejor de ti"}},"CATE":{"CATE1":{"READY_TO_GET_STARTED":"¿Listo para empezar?","BECOME_ONE_OF_THE_MILLIONS":"¡Únase a millones de personas y marcas de todo el mundo que aman y utilizan EveryThink!","CREATE_EVERTTHINKACCOUNT":"Crear cuenta"}},"TESTIMONIALS":{"TESTIMONIAL_SIMPLE_SLIDER":{"TESTIMONIALS":"Testimonios"},"TESTIMONIAL_SLIDER":{"LOREM_IPS":"Esta es una herramienta increíble que puede ayudar a cualquiera a crear sus propios algoritmos y generar un negocio más sostenible. ¡Muchas gracias por ayudarnos a ayudar a otras personas!","JANE_DOR":"Estefany Güechá,","AWESOME_COMPANY":"Somos Pileros"},"TESTIMONIAL_SIMPLE_TEXT_RIGHT":{"IF_YOU_ARE_STRUGGLING":"Si tiene dificultades para mantenerse en el negocio, puede haber varias opciones que puede explorar.","EVERYTHINK":"DefAgent,","IS_THE_PERFECT_TOOL":"es la herramienta perfecta. Es muy fácil de usar y tiene toda la funcionalidad que buscas.","CARO_FOGLIATO":"Caro Fogliato,","CEOANDFOUNDER":" CEO & Founder of DefAgent Ltd."},"TESTIMONIAL_SIMPLE_TEXT_LEFT":{"EVERYTHIN_IS_GREAT_FOR":"DefAgent es genial para","ANYONE_WHO_IS_LOOKING_FOR_SIMPLE":"Cualquiera que busque una implementación simple con un impacto exponencialmente positivo","EVERYTHINK_LTD_TEAM":"DefAgent Ltd. Team,","DoING_GREATE_SINCE":"Haciendolo bien desde 2024"},"TESTIMONIAL_SKEWED_SLIDER":{"OUR_CUSTOMERS_HAVE_SOMETHING_TO_SAY":"Nuestros clientes tienen algo que decir","THEY_ARE_THE_BEST":"¡Son los mejores, nuestro cliente quiere hacerle saber cómo DefAgent los está ayudando a lograr sus objetivos y lo simple que es usarlo!"},"TESTIMONIAL_WORLD_MAP":{"WE_HEARD_OUR_CUSTOMERS_SAY":"Nuestros clientes tienen algo que decir","SED_OUT_PERSPICIATIS":"Esta es una herramienta increíble que puede ayudar a cualquiera a crear sus propios algoritmos y generar un negocio más sostenible. Muchas gracias por ayudarnos a ayudar a otras personas!","JANE_DOE":"Estefany Güechá,","MARKEYING_DIRECTOR":"Somos Pileros"}},"USUAL":{"FEATURES_ICONS_COL":{"UP_TO_THE_TASK":"Inicie su viaje de IA para salud","WHAT_YOU_GET":"Que Obtienes","GEOLOCATED_INTELLIGENT_ASSISTANTS":"Con DefAgent AIaaS, puede aprovechar a los AIs geolocalizados para administrar datos de fuentes dispares, como registros médicos electrónicos y determinantes sociales de la salud; interconectar personas y dispositivos y automatizar el trabajo administrativo costoso, repetitivo y propenso a errores en una fuerza de trabajo digital mucho más eficiente y económica."},"DEVELOPER_DESIGNER":{"JOIN_AS_DESIGNER":"Únete a nosotros!","JOIN_AS_DEVELOPER":"","LOREM_IPSUM":""},"START_NOW_BOX":{"TRY_EVERYTHINK_NOW":"Prueba DefAgent ahora ... ámalo para siempre","WHY_WAIT":"¿Por qué esperar? ¡Empieza ahora!","START_NOW":"Comenzar"}},"FOOTER":{"FOOTER1":{"EVERYTHINK_IS_POISED":"Todo es uno, donde el infinito comienza.","COMPANY":"DefAgent","ABOUT":"Sobre nosotros","BLOG":"Blog","PRODUCt":"Productos","SERVICES":"Servicios","FEATURES":"Actualizaciones","API":"API","CUSTOMERS":"Clientes","CHANNELS":"Canales","CAREERS":"Carreras","CONTACT":"Contacto","SEARCH":"Buscar","COPYRIGHT":"Copyright © 2024-2025 DefAgent inc. All Rights Reserved."}},"CONTACT":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - contact","KEYWORDS":"Network Search, Networks directory contact"},"FORM":{"LETS_DO_BUSINESS":"Comience ahora!","STEP_INTO_OUR_PLACE":"Entra en nuestro lugar","123_STREET_ST":"Texas","YC_COUNTRY":"United States"},"OTHER_CHANNELS":{"CONTACT_SALE":"Contacto a Ventas","LOOKING_FOR_CUSTOM_QUOTE":"¿Busca un presupuesto personalizado? ¿Necesitas contarnos más sobre tu proyecto? o quieres una demostración? escríbenos a","TECHNICAL_SUPPORT":"Soporte técnico","ANY_QUESTION":"¿Alguna duda sobre cómo integrar su producto ?. No se preocupe, nuestro equipo está listo para ayudarle"}},"ABOUT":{"NETWORK_SEARCH_META":{"TITLE":"DefAgent - about","KEYWORDS":"Network Search, Networks directory about"},"OVERVIEW":{"SUCCEED_WITH_DASHCORE":"Triunfa con DefAgent","THE_NEW_WAY_TO_SHOWCASE":"La nueva forma de impulsar su negocio","DASHCORE_IS_A_BOOTSTRAP":"","IT_INCLUDES_MULTIPLE":"Incluye múltiples componentes y demostraciones prefabricadas listas para que las personalice según sus propias necesidades. DefAgent incluye un panel de administración listo para usar con muchas funciones listas para usar."},"VIDEO":{"DISCOVER_HOW_DASHCORE_WORKS":"Descubra cómo funciona DefAgent","PLAY_THE_VIDEO":"Video"},"SOLUTIONS":{"A_SOLUTION_FOR_EVERY_NEED":"Una solución para cada necesidad","LOREM_IPSUM":"","DASHCORE_INCLUDED":"Tableros incluidos","OUR_TEMPLATE_IS_PACKED_WITH_A":"DefAgent","START_ADMIN_DASHBOARD":"también cuenta con paneles de control que son personalizables según tus necesidades","START_RIGHT_AWAY":"comience de inmediato con su proyecto.","TRY_THE_DASHBOARD":"Pruebe DefAgent"},"FEATURES":{"OUR_FEATURES_STACK":"Nuestras características se apilan","TAKE_THE_CONTROL":"Toma el control de tu negocio con DefAgent. Puede personalizar según sus necesidades o simplemente usar la solución lista para usar que creamos para usted"},"CUSTOMERS":{"THIRD_PARTY":"Integración de terceros","WE_USE_THE_LATEST_TRENDS":"Usamos las últimas tendencias porque te mereces algo mejor","ARE_YOU_A_DEVELOPER":"¿Eres desarrollador?","REVIEW_THE_SPECS":"Revise las especificaciones"},"TEAM":{"GET_TO_KNOW_OUR_TEAM":"Conozca nuestro equipo","THESE_AMAZING_PEOPLE":"Estas personas increíbles han hecho posible que nos quedemos donde estamos"},"REGISTER":{"DASHCORE_OFFICIAL":"DefAgent Ltd","NEWSLETTER":"Boletin informativo"}},"TERMS":{"trm_terms_of_use":"Términos De Uso","trm_last_update":"Última actualización: 30 de Marzo de 2025","trm_general_information":"Información General","trm_introduction":"Bienvenido a DefAgent, inc. (la ¨Compañía¨). DefAgent desarrolla tecnologías y servicios que permiten a las personas conectarse entre sí, con procesos y con dispositivos; permite construir redes, comunidades y canales; y hacer crecer negocios. Estos Términos rigen el uso de DefAgent y los demás productos, características, módulos, aplicaciones, servicios, tecnologías y software que ofrecemos. DefAgent, Ltd. le proporciona estos Productos. Al crear una cuenta en DefAgent, ya sea a través de un dispositivo móvil, una aplicación móvil o una computadora (colectivamente, el \'Servicio\'), usted acepta estar sujeto a estos Términos de uso y nuestra Política de privacidad que se incorpora por referencia en este Acuerdo y está disponible en el Servicio (este \'Acuerdo\'). Si no acepta y acepta estar obligado por todos los términos de este Acuerdo, no utilice el Servicio.","trm_1_acceptance_terms":"1. Aceptación Del Acuerdo De Términos De Uso.","trm_1_acceptance_terms_1":"Este Acuerdo es un contrato electrónico que establece los términos legalmente vinculantes que debe aceptar para usar el Servicio. Este Acuerdo incluye la (i) Política de privacidad de la Compañía, (ii) nuestros Consejos de seguridad y (iii) los términos divulgados y aceptados por usted si compra o acepta características, productos o servicios adicionales que ofrecemos en el Servicio.","trm_1_acceptance_terms_2":"Podemos, en cualquier momento y por cualquier motivo, hacer cambios a este Acuerdo. Podemos hacer esto por una variedad de razones, incluyendo para reflejar cambios o requisitos de la ley, nuevas características o cambios en las prácticas comerciales. La versión más reciente de este Acuerdo se publicará en los Servicios en Configuración y también en la página web https://DefAgent.ai/, y debe verificar regularmente la versión más reciente. La versión más reciente es la que se aplica. Si los cambios incluyen cambios materiales que afectan sus derechos u obligaciones, le notificaremos los cambios por medios razonables, que podrían incluir notificaciones a través de los Servicios o por correo electrónico. Si continúa utilizando los Servicios después de que los cambios entren en vigencia, se considerará que los ha aceptado. Si no está de acuerdo con estos cambios, debe finalizar su relación con nosotros al dejar de usar los Servicios y abandonar DefAgent.","trm_2_eligibility":"2. Elegibilidad.","trm_2_eligibility_1":"Debe tener al menos 18 años de edad para crear una cuenta en DefAgent y usar el Servicio. Al crear una cuenta y usar el Servicio, usted declara y garantiza que puede formar un contrato vinculante con DefAgent, no es una persona a quien se le prohíbe usar el Servicio bajo las leyes de Inglaterra o cualquier otra jurisdicción aplicable, lo que significa no aparece en la lista de ciudadanos especialmente designados del Departamento del Tesoro de Inglaterra ni se enfrenta a ninguna otra prohibición similar, y cumplirá con este Acuerdo y todas las leyes, normas y reglamentos locales, estatales, nacionales e internacionales aplicables. Si crea una cuenta, declara y garantiza que nunca ha sido condenado por un delito grave y que no está obligado a registrarse como delincuente sexual en ningún registro estatal, federal o local de delincuentes sexuales.","trm_3_user_accounts":"3. Cuentas De Usuario.","trm_3_user_accounts_1":"Para utilizar la mayoría de los aspectos de los Servicios, debe registrarse y mantener una cuenta de Servicios de usuario personal activa (\'Cuenta\'). Debe tener al menos 18 años de edad, o la mayoría de edad legal en su jurisdicción (si es diferente de 18), para obtener una Cuenta, a menos que un Servicio específico permita lo contrario. El registro de la cuenta requiere que envíe a DefAgent cierta información personal, como su nombre, dirección, número de teléfono móvil y edad, así como al menos un método de pago válido compatible con DefAgent. Usted acepta mantener información precisa, completa y actualizada en su Cuenta. Si no mantiene información precisa, completa y actualizada de la Cuenta, incluido el hecho de tener un método de pago no válido o vencido en el archivo, puede resultar en su incapacidad para acceder o utilizar los Servicios. Usted es responsable de toda actividad que ocurra bajo su Cuenta, y acepta mantener la seguridad y el secreto del nombre de usuario y contraseña de su Cuenta en todo momento. A menos que DefAgent lo permita por escrito, solo puede tener una Cuenta.","trm_4_terms_termination":"4. Términos Y Terminación.","trm_4_terms_termination_1":"Este Acuerdo permanecerá en pleno vigor y efecto mientras use el Servicio y/o tenga una cuenta DefAgent. Puede cancelar su cuenta en cualquier momento, por cualquier motivo, siguiendo las instrucciones en \'Configuración\' en el Servicio. La Compañía puede cancelar o suspender su cuenta en cualquier momento sin previo aviso si cree que usted ha incumplido este Acuerdo a su exclusivo criterio. Tras dicha terminación o suspensión, no tendrá derecho a ningún reembolso de las tarifas no utilizadas en las compras de aplicaciones. Después de que se cancele su cuenta, este Acuerdo terminará, excepto que las siguientes disposiciones aún se aplicarán: Sección 4, Sección 8, Sección 9 y Secciones 16-18.","trm_5_non_commercial_use":"5. Uso No Comercial Por Parte De Los Usuarios.","trm_5_non_commercial_use_1":"El Servicio es solo para uso personal. Los usuarios no pueden usar el Servicio o cualquier contenido contenido en el Servicio (incluido, entre otros, el contenido de otros usuarios, diseños, texto, gráficos, imágenes, video, logotipos, software y código de computadora) en relación con cualquier esfuerzo comercial, como anunciar o solicitar a cualquier usuario que compre o venda productos o servicios no ofrecidos por la Compañía. Los usuarios del Servicio no pueden usar ninguna información obtenida del Servicio para contactar, publicitar, solicitar o vender a ningún otro usuario sin su previo consentimiento explícito. Las organizaciones, empresas y/o negocios no pueden usar el Servicio para ningún propósito, excepto con el consentimiento expreso de DefAgent (como para perfiles promocionados u otros anuncios), que DefAgent puede proporcionar o negar a su exclusivo criterio. La Compañía puede investigar y tomar cualquier acción legal disponible en respuesta a usos ilegales y/o no autorizados del Servicio.","trm_6_the_services":"6. Los Servicios.","trm_6_the_services_1":"DefAgent es una red interactiva móvil, Android y iOS, y web alojada por un asistente virtual con inteligencia artificial capaz de conectar a las personas de acuerdo con sus intereses, necesidades y habilidades personales, laborales, sociales y educativas a través de preguntas específicas. El asistente virtual es capaz de aprender sobre las necesidades, habilidades, intereses y aspiraciones del usuario en cada entorno a través de preguntas contextualizadas y geoespaciales, con el fin de lograr conexiones asertivas con los demás.","trm_7_interactions":"7. Interacciones Con Otros Usuarios.","trm_7_interactions_1":"Usted es el único responsable de sus interacciones con otros usuarios. USTED ENTIENDE QUE LA EMPRESA ACTUALMENTE NO REALIZA VERIFICACIONES DE ANTECEDENTES PENALES EN SUS USUARIOS. LA EMPRESA TAMBIÉN NO VERIFICA LAS DECLARACIONES DE SUS USUARIOS. LA EMPRESA NO HACE REPRESENTACIONES O GARANTÍAS EN RELACIÓN CON LA CONDUCTA DE LOS USUARIOS O SU COMPATIBILIDAD CON NINGÚN USUARIO ACTUAL O FUTURO. LA EMPRESA SE RESERVA EL DERECHO DE REALIZAR CUALQUIER VERIFICACIÓN DE ANTECEDENTES PENALES U OTRAS EXÁMENES (COMO LAS BÚSQUEDAS DE REGISTRO DE OFERTAS SEXUALES), EN CUALQUIER MOMENTO Y UTILIZANDO REGISTROS PÚBLICOS DISPONIBLES.","trm_7_interactions_2":"La Compañía no es responsable por la conducta de ningún usuario. Como se señala en y sin limitar la Sección 15 a continuación, en ningún caso la Compañía, sus afiliados o sus socios serán responsables (directa o indirectamente) de cualquier pérdida o daño, ya sea directo, indirecto, general, especial, compensatorio, consecuente y/o incidental, que surja de o se relacione con su conducta o la de cualquier otra persona en relación con el uso del Servicio, incluidos, entre otros, muerte, lesiones corporales, angustia emocional y/o cualquier otro daño resultante de las comunicaciones o reuniones con otros usuarios o personas que conozca a través del Servicio. Usted acepta tomar todas las precauciones necesarias en todas las interacciones con otros usuarios, particularmente si decide comunicarse fuera del Servicio o reunirse en persona, o si decide enviar dinero a otro usuario. Además, acepta revisar y seguir los Consejos de seguridad de la Compañía, ubicados en el Servicio, antes de usar el Servicio. No debe proporcionar su información financiera (por ejemplo, la información de su tarjeta de crédito o cuenta bancaria), ni transferir ni enviar dinero a otros usuarios.","trm_8_content_posted":"8. Contenido Publicado Por Usted En El Servicio.","trm_8_content_posted_1":"Usted es el único responsable del contenido y la información que publica, carga, publica, vincula, transmite, registra, muestra o pone a disposición (colectivamente, \'publica\') en el Servicio o transmite a otros usuarios, incluidos mensajes de texto, chat, videos, fotografías o texto de perfil, ya sea publicado públicamente o transmitido en privado (colectivamente, \'Contenido\'). No puede publicar como parte del Servicio, ni transmitir a la Compañía ni a ningún otro usuario (ya sea dentro o fuera del Servicio), cualquier ofensivo, inexacto, incompleto, abusivo, obsceno, profano, amenazante, intimidante, acosador, racialmente ofensivo, o material ilegal, o cualquier material que infrinja o viole los derechos de otra persona (incluidos los derechos de propiedad intelectual y los derechos de privacidad y publicidad). Usted declara y garantiza que (i) toda la información que envíe al crear su cuenta, es precisa y veraz, y que actualizará de inmediato cualquier información proporcionada por usted que posteriormente se vuelva inexacta, incompleta, engañosa o falsa y (ii) usted tenga El derecho a publicar el Contenido en el Servicio y otorgar las licencias establecidas a continuación.","trm_8_content_posted_2":"Usted comprende y acepta que la Compañía puede, pero no está obligada a, monitorear o revisar cualquier Contenido que publique como parte de un Servicio. La Compañía puede eliminar cualquier Contenido, en su totalidad o en parte, que a juicio exclusivo de la Compañía viole este Acuerdo o pueda dañar la reputación del Servicio o la Compañía.","trm_8_content_posted_3":"Al publicar Contenido como parte del Servicio, usted le otorga a DefAgent un derecho mundial, transferible, sin licencia, libre de regalías, derecho y licencia para alojar, almacenar, usar, copiar, mostrar, reproducir, adaptar, editar, publicar, modificar y distribuir el contenido. Esta licencia tiene el propósito limitado de operar, desarrollar, proporcionar, promover y mejorar el Servicio e investigar y desarrollar otros nuevos.","trm_8_content_posted_4":"Además de los tipos de Contenido descritos en la Sección 8 (a) anterior, la siguiente es una lista parcial del tipo de Contenido que está prohibido en el Servicio. No puede publicar, cargar, mostrar o poner a disposición contenido que:","trm_8_content_posted_4_1":"(I) Promueve el racismo, la intolerancia, el odio o el daño físico de cualquier tipo contra cualquier grupo o individuo;","trm_8_content_posted_4_2":"(II) Aboga por el acoso o la intimidación de otra persona;","trm_8_content_posted_4_3":"(III) Envía spam o solicita a los usuarios de DefAgent;","trm_8_content_posted_4_4":"(IV) Promueve información falsa o engañosa, o promueve actividades ilegales o conductas difamatorias, difamatorias o de otra manera objetables;","trm_8_content_posted_4_5":"(V) Promueve una copia ilegal o no autorizada del trabajo protegido por derechos de autor de otra persona, como proporcionar programas informáticos pirateados, imágenes, archivos de audio o video o enlaces a ellos;","trm_8_content_posted_4_6":"(VI) Contiene video, fotografías de audio o imágenes de otra persona sin su permiso (o en el caso de un menor, el tutor legal del menor);","trm_8_content_posted_4_7":"(VII) Contiene páginas de acceso restringido o con contraseña, o páginas o imágenes ocultas (aquellas que no están vinculadas ao desde otra página accesible);","trm_8_content_posted_4_8":"(VIII) Proporciona material que explota a las personas de manera sexual, violenta u otra forma ilegal, o solicita información personal de cualquier persona menor de 18 años;","trm_8_content_posted_4_9":"(IX) Proporciona información educativa sobre actividades ilegales, como fabricar o comprar armas o drogas ilegales, violar la privacidad de alguien o proporcionar, diseminar o crear virus informáticos;","trm_8_content_posted_4_10":"(X) Contiene virus, bombas de tiempo, troyanos, cancelbots, gusanos u otros códigos, componentes o dispositivos dañinos o perjudiciales;","trm_8_content_posted_4_11":"(XI) Suplanta o tergiversa afiliación, conexión o asociación con cualquier persona o entidad;","trm_8_content_posted_4_12":"(XII) Proporciona información o datos que no tiene derecho a poner a disposición de acuerdo con la ley o las relaciones contractuales o fiduciarias (como información privilegiada, información confidencial y de propiedad exclusiva);","trm_8_content_posted_4_13":"(XIII) Interrumpe el flujo normal del diálogo, hace que una pantalla se \'desplace\' más rápido de lo que otros usuarios pueden escribir, o afecta negativamente la capacidad de otros usuarios para participar en intercambios en tiempo real; y","trm_8_content_posted_4_14":"(XIV) Solicita contraseñas o información de identificación personal para fines comerciales o ilegales de otros usuarios o difunde la información personal de otra persona sin su permiso.","trm_8_content_posted_text":"La Compañía se reserva el derecho, a su sola discreción, de investigar y tomar cualquier acción legal contra cualquier persona que viole esta disposición, incluida la eliminación de la comunicación ofensiva del Servicio y la cancelación o suspensión de la cuenta de dichos infractores.","trm_9_use_service_0":"9. Uso Del Servicio.","trm_9_use_service":"Su uso del Servicio, incluido todo el Contenido que publique a través del Servicio, debe cumplir con todas las leyes y regulaciones aplicables. Usted acepta que la Compañía puede acceder, preservar y divulgar la información y el Contenido de su cuenta si así lo requiere la ley o de buena fe que dicho acceso, preservación o divulgación es razonablemente necesario, como por ejemplo: (i) cumplir con la ley proceso; (ii) hacer cumplir este Acuerdo; (iii) responder a reclamos de que cualquier Contenido viola los derechos de terceros; (iv) responder a sus solicitudes de servicio al cliente o permitirle usar el Servicio en el futuro; o (v) proteger los derechos, la propiedad o la seguridad personal de la Compañía o de cualquier otra persona.","trm_10_agree_content":"Usted acepta que cualquier Contenido que coloque en el Servicio puede ser visto por otros usuarios y puede ser visto por cualquier persona que visite o participe en el Servicio (como individuos que pueden recibir Contenido compartido de otros usuarios de DefAgent).","trm_11_prohibited_activities":"10. Actividades Prohibidas.","trm_11_prohibited_activities_1":"La Compañía se reserva el derecho de investigar, suspender y/o cancelar su cuenta si ha usado mal el Servicio o se ha comportado de una manera que la Compañía considera inapropiada o ilegal, incluidas acciones o comunicaciones que ocurren fuera del Servicio pero involucran a usuarios que conoce a través del Servicio. La siguiente es una lista parcial del tipo de acciones que no puede realizar con respecto al Servicio. No Ppodrás realizar lo siguiente:","trm_11_prohibited_activities_1_1":"(I) Hacerse pasar por cualquier persona o entidad.","trm_11_prohibited_activities_1_2":"(II) Solicitar dinero de cualquier usuario.","trm_11_prohibited_activities_1_3":"(III) Publique cualquier Contenido que esté prohibido por la Sección 7.","trm_11_prohibited_activities_1_4":"\'(IV) Acechar\' o acosar a cualquier persona.","trm_11_prohibited_activities_1_5":"(V) Expresar o implicar que cualquier declaración que realice está respaldada por la Compañía sin nuestro consentimiento previo por escrito.","trm_11_prohibited_activities_1_6":"(VI) Usar el Servicio de manera ilegal o para cometer un acto ilegal.","trm_11_prohibited_activities_1_7":"(VII) Acceda al Servicio en una jurisdicción en la que sea ilegal o no autorizado.","trm_11_prohibited_activities_1_8":"(VIII) Utilice cualquier robot, araña, aplicación de búsqueda / recuperación del sitio u otro dispositivo o proceso manual o automático para recuperar, indexar, \'extraer datos\', o de cualquier manera reproducir o eludir la estructura de navegación o la presentación del Servicio o sus contenidos.","trm_11_prohibited_activities_1_9":"(IX) Recopile los nombres de usuario y / o las direcciones de correo electrónico de los usuarios por medios electrónicos u otros con el fin de enviar correos electrónicos no solicitados o marcos o enlaces no autorizados al Servicio.","trm_11_prohibited_activities_1_10":"(X) Interferir o interrumpir el Servicio o los servidores o redes conectados al Servicio.","trm_11_prohibited_activities_1_11":"(XI) Transmita cualquier material que contenga virus de software o cualquier otro código de computadora, archivos o programas diseñados para interrumpir, destruir o limitar la funcionalidad de cualquier software, hardware o equipo de telecomunicaciones.","trm_11_prohibited_activities_1_12":"(XII) Falsifique encabezados o manipule identificadores para ocultar el origen de cualquier información transmitida a través del Servicio (ya sea directa o indirectamente mediante el uso de software de terceros).","trm_11_prohibited_activities_1_13":"(XIII) \'Enmarcar\' o \'Reflejar\' cualquier parte del Servicio, sin la autorización previa por escrito de la Compañía.","trm_11_prohibited_activities_1_14":"(XIV) Use metaetiquetas o códigos u otros dispositivos que contengan alguna referencia a la Compañía o al Servicio (o cualquier marca registrada, nombre comercial, marca de servicio, logotipo o eslogan de la Compañía) para dirigir a cualquier persona a cualquier otro sitio web para cualquier propósito.","trm_11_prohibited_activities_1_15":"(XV) Modifique, adapte, sublicencia, traduzca, venda, realice ingeniería inversa, descifre, descompile o desarme cualquier parte del Servicio de cualquier software utilizado en el Servicio, o haga que otros lo hagan.","trm_11_prohibited_activities_1_16":"(XVI) Publique, use, transmita o distribuya, directa o indirectamente (por ejemplo, captura de pantalla) de cualquier manera o medio cualquier contenido o información obtenida del Servicio que no sea únicamente en relación con su uso del Servicio de acuerdo con este Acuerdo.","trm_12_propietary_rights":"11. Derechos De Propiedad.","trm_12_propietary_rights_1":"La Compañía posee y retiene todos los derechos de propiedad en el Servicio, y en todo el contenido, marcas comerciales, nombres comerciales, marcas de servicio y otros derechos de propiedad intelectual relacionados con el mismo. El Servicio contiene el material con derechos de autor, marcas registradas y otra información de propiedad de la Compañía y sus licenciantes. Usted acepta no copiar, modificar, transmitir, crear trabajos derivados, utilizar o reproducir de ninguna manera ningún material con derechos de autor, marcas comerciales, nombres comerciales, marcas de servicio u otra propiedad intelectual o información de propiedad accesible a través del Servicio, sin obtener primero el consentimiento previo por escrito de la Compañía o, si dicha propiedad no es propiedad de la Compañía, el propietario de dicha propiedad intelectual o derechos de propiedad. Usted acepta no eliminar, ocultar ni alterar de ninguna otra manera los avisos de propiedad que aparezcan en ningún contenido, incluidos los avisos de derechos de autor, marcas comerciales y otros avisos de propiedad intelectual.","trm_13_ownership":"12. Propiedad.","trm_13_ownership_1":"Los Servicios y todos los derechos en ellos son y seguirán siendo propiedad de DefAgent o propiedad de los licenciantes de DefAgent. Ni estos Términos ni su uso de los Servicios le otorgan ni le otorgan ningún derecho: (i) en o relacionado con los Servicios, excepto por la licencia limitada otorgada anteriormente; o (ii) usar o hacer referencia de cualquier manera a los nombres de compañías, logotipos, nombres de productos y servicios, marcas comerciales o marcas de servicios de DefAgent o de los licenciantes de DefAgent.","trm_14_user_provided_content":"13. Contenido Proporcionado Por El Usuario.","trm_14_user_provided_content_1":"DefAgent puede, a su entera discreción, permitirle de vez en cuando enviar, cargar, publicar o poner a disposición de DefAgent a través de los Servicios contenido textual, de audio y/o visual e información, incluidos comentarios y comentarios relacionados con los Servicios, inicio de solicitudes de soporte y envío de entradas para concursos y promociones (\'Contenido del usuario\'). Cualquier contenido de usuario proporcionado por usted sigue siendo de su propiedad. Sin embargo, al proporcionar Contenido de usuario a DefAgent, usted le otorga a DefAgent una licencia mundial, perpetua, irrevocable, transferible y libre de regalías, con el derecho de sublicenciar, usar, copiar, modificar, crear trabajos derivados de, distribuir, mostrar públicamente, públicamente realizar y explotar de cualquier otra forma el Contenido del usuario en todos los formatos y canales de distribución ahora conocidos o desarrollados en el futuro (incluso en relación con los Servicios y el negocio de DefAgent y en sitios y servicios de terceros), sin previo aviso o consentimiento de usted , y sin el requisito de pago para usted o cualquier otra persona o entidad. Usted declara y garantiza que: (i) usted es el propietario único y exclusivo de todo el Contenido del usuario o tiene todos los derechos, licencias, consentimientos y liberaciones necesarios para otorgar a DefAgent la licencia del Contenido del usuario como se establece anteriormente; y (ii) ni el Contenido del usuario, ni su envío, carga, publicación o puesta a disposición de dicho Contenido del usuario, ni el uso de DefAgent del Contenido del usuario según lo permitido en este documento infringirá, malversará o violará la propiedad intelectual o los derechos de propiedad de un tercero, o derechos de publicidad o privacidad, o resultar en la violación de cualquier ley o regulación aplicable. Usted acepta no proporcionar Contenido de usuario que sea difamatorio, calumnioso, odioso, violento, obsceno, pornográfico, ilegal u ofensivo, según lo determine DefAgent a su exclusivo criterio, si dicho material puede o no estar protegido por la ley. DefAgent puede, pero no estará obligado a, revisar, monitorear o eliminar el Contenido del usuario, a discreción exclusiva de DefAgent y en cualquier momento y por cualquier motivo, sin notificárselo.","trm_15_network_access_devices":"14. Acceso A La Red Y Dispositivos.","trm_15_network_access_devices_1":"Usted es responsable de obtener el acceso a la red de datos necesario para usar los Servicios. Las tarifas y tarifas de datos y mensajes de su red móvil pueden aplicarse si accede o utiliza los Servicios desde su dispositivo. Usted es responsable de adquirir y actualizar el hardware o dispositivos compatibles necesarios para acceder y utilizar los Servicios y Aplicaciones y cualquier actualización de los mismos. DefAgent no garantiza que los Servicios, o cualquier parte de los mismos, funcionen en ningún hardware o dispositivo en particular. Además, los Servicios pueden estar sujetos a mal funcionamiento y demoras inherentes al uso de Internet y las comunicaciones electrónicas.","trm_16_modifications_service":"15. Modificaciones Al Servicio.","trm_16_modifications_service_1":"La Compañía se reserva el derecho en cualquier momento de modificar o descontinuar, temporal o permanentemente, el Servicio (o cualquier parte del mismo) con o sin previo aviso. Usted acepta que la Compañía no será responsable ante usted ni ante ningún tercero por cualquier modificación, suspensión o interrupción del Servicio. Para proteger la integridad del Servicio, la Compañía se reserva el derecho en cualquier momento, a su exclusivo criterio, de bloquear el acceso de los usuarios de ciertas direcciones IP al Servicio.","trm_17_copyright_policy":"16. Política De Derechos De Autor.","trm_17_copyright_policy_1":"Notificación y procedimiento para realizar reclamaciones de infracción de derechos de autor. No puede publicar, distribuir ni reproducir de ninguna manera ningún material con derechos de autor, marcas comerciales u otra información de propiedad sin obtener el consentimiento previo por escrito del propietario de dichos derechos de propiedad. Si cree que su trabajo ha sido copiado y publicado en el Servicio de una manera que constituye una infracción de derechos de autor, proporcione a nuestro Agente de Derechos de Autor la siguiente información:","trm_17_copyright_policy_1_1":"(I) Una firma electrónica o física de la persona autorizada para actuar en nombre del propietario de los derechos de autor;","trm_17_copyright_policy_1_2":"(II) Una descripción del trabajo protegido por derechos de autor que usted afirma que se ha infringido;","trm_17_copyright_policy_1_3":"(III) Una descripción de dónde se encuentra el material que usted afirma que está infringiendo en el Servicio (y dicha descripción debe ser razonablemente suficiente para permitir a la Compañía encontrar el material presuntamente infractor, como una url);","trm_17_copyright_policy_1_4":"(IV) Su dirección, número de teléfono y dirección de correo electrónico;","trm_17_copyright_policy_1_5":"(V) Una declaración escrita de usted de que cree de buena fe que el uso en disputa no está autorizado por el propietario de los derechos de autor, su agente o la ley; y","trm_17_copyright_policy_1_6":"(VI) Una declaración suya, hecha bajo pena de perjurio, que la información anterior en su aviso es precisa y que usted es el propietario de los derechos de autor o está autorizado para actuar en nombre del propietario de los derechos de autor.","trm_17_copyright_policy_1_text":"El aviso de reclamos de infracción de derechos de autor debe proporcionarse al Agente de Derechos de Autor de la Compañía en caro@DefAgent.ai","trm_17_copyright_policy_1_text1":"La Compañía cancelará las cuentas de los infractores reincidentes.","trm_17_disclaimers":"17. Descargos De Responsabilidad, Limitación De Responsabilidad.","trm_17_disclaimers_0":"Descargos De Responsabilidad.","trm_17_disclaimers_1":"LOS SERVICIOS SE PROPORCIONAN \'TAL CUAL\' Y \'SEGÚN DISPONIBILIDAD\'. DefAgent RENUNCIA A TODAS LAS REPRESENTACIONES Y GARANTÍAS, EXPRESAS, IMPLÍCITAS O ESTATUTARIAS, NO EXPRESADAS EXPRESAMENTE EN ESTOS TÉRMINOS, INCLUIDAS LAS GARANTÍAS IMPLÍCITAS DE COMERCIABILIDAD, IDONEIDAD PARA UN PROPÓSITO Y NO INFRACCIÓN PARTICULARES. ADEMÁS, DefAgent NO HACE NINGUNA REPRESENTACIÓN, GARANTÍA O GARANTÍA CON RESPECTO A LA CONFIABILIDAD, OPORTUNIDAD, CALIDAD, IDONEIDAD O DISPONIBILIDAD DE LOS SERVICIOS O CUALQUIER SERVICIO O BIEN SOLICITADOS A TRAVÉS DEL USO DE LOS SERVICIOS, O QUE LOS SERVICIOS SERÁN ININTERRUMPIDOS GRATIS. DefAgent NO GARANTIZA LA CALIDAD, IDONEIDAD, SEGURIDAD O CAPACIDAD DE PROVEEDORES DE TERCEROS. USTED ACEPTA QUE TODO EL RIESGO DERIVADO DE SU USO DE LOS SERVICIOS, Y CUALQUIER SERVICIO O BIEN SOLICITADO EN CONEXIÓN CON ELLOS, SE QUEDA SOLAMENTE CON USTED, EN LA MEDIDA MÁXIMA PERMITIDA BAJO LA LEY APLICABLE.","trm_17_limitation":"Limitación De Responsabilidad.","trm_17_limitation_1":"DefAgent NO SERÁ RESPONSABLE POR DAÑOS INDIRECTOS, INCIDENTALES, ESPECIALES, EJEMPLARES, PUNITIVOS O CONSECUENTES, INCLUYENDO GANANCIAS PERDIDAS, DATOS PERDIDOS, DAÑOS PERSONALES O DAÑOS A LA PROPIEDAD RELACIONADOS CON, EN RELACIÓN CON, O DE CUALQUIER OTRO RESULTADO DE CUALQUIER USO DE LOS SERVICIOS, SIN IMPORTAR LA NEGLIGENCIA (CUALQUIERA ACTIVA, AFIRMATIVA, ÚNICA O CONCURRENTE) DE DefAgent, INCLUSO SI SE HA INFORMADO A DefAgent DE LA POSIBILIDAD DE TALES DAÑOS. DefAgent NO SERÁ RESPONSABLE DE NINGÚN DAÑO, RESPONSABILIDAD O PÉRDIDA QUE SURJA DE: (i) SU USO O CONFIANZA EN LOS SERVICIOS O SU INCAPACIDAD PARA ACCEDER O UTILIZAR LOS SERVICIOS; O (ii) CUALQUIER TRANSACCIÓN O RELACIÓN ENTRE USTED Y CUALQUIER PROVEEDOR DE TERCEROS, INCLUSO SI SE HA INFORMADO DefAgent DE LA POSIBILIDAD DE TALES DAÑOS. DefAgent NO SERÁ RESPONSABLE POR RETRASO O FALLA EN EL RENDIMIENTO RESULTANTE DE CAUSAS MÁS ALLÁ DE DefAgent CONTROL RAZONABLE. USTED RECONOCE QUE LOS PROVEEDORES DE TERCEROS QUE PROPORCIONAN SERVICIOS DE TRANSPORTE SOLICITADOS A TRAVÉS DE ALGUNOS PRODUCTOS DE SOLICITUD PUEDEN OFRECER SERVICIOS DE TRANSPORTE DE COMPARTIMIENTO O PERMISO Y NO PUEDEN SER LICENCIADOS O PERMITIDOS PROFESIONALMENTE. USTED PUEDE UTILIZAR LOS SERVICIOS PARA SOLICITAR Y PROGRAMAR SERVICIOS DE TRANSPORTE, BIENES O LOGÍSTICOS CON PROVEEDORES DE TERCEROS, PERO ACEPTA QUE DefAgent NO TIENE NINGUNA RESPONSABILIDAD O RESPONSABILIDAD RELACIONADA CON CUALQUIER SERVICIO DE TRANSPORTE, BIENES O LOGÍSTICOS PROPORCIONADOS A USTED POR TERCEROS PROVEEDORES QUE NO SEAN EXPRESAMENTE ESTABLECIDOS EN ESTOS TÉRMINOS. LAS LIMITACIONES Y LA RENUNCIA DE RESPONSABILIDAD EN ESTA SECCIÓN NO SIGNIFICAN LIMITAR LA RESPONSABILIDAD O ALTERAR SUS DERECHOS COMO CONSUMIDOR QUE NO PUEDE SER EXCLUIDO BAJO LA LEY APLICABLE. PORQUE ALGUNOS ESTADOS O JURISDICCIONES NO PERMITEN LA EXCLUSIÓN O LA LIMITACIÓN DE RESPONSABILIDAD POR DAÑOS CONSECUENTES O INCIDENTALES, EN DICHOS ESTADOS O JURISDICCIONES, TODA LA RESPONSABILIDAD SE LIMITARÁ AL EXTREMO PERMITIDO POR LA LEY. ESTA DISPOSICIÓN NO TENDRÁ EFECTO EN TODA LA DISPOSICIÓN DE ELECCIÓN DE LEY ESTABLECIDA A CONTINUACIÓN.","trm_18_arbitration":"18. Arbitraje Y Ley Aplicable.","trm_18_arbitration_p":"A excepción de los usuarios que residen en la Unión Europea, Noruega y otros lugares donde lo prohíba la ley aplicable:","trm_18_arbitration_i_01":"El medio exclusivo para resolver cualquier disputa o reclamo que surja de o esté relacionado con este Acuerdo (incluyendo cualquier presunto incumplimiento del mismo) o el Servicio será el ARBITRAJE VINCULANTE administrado por la Arbitration Association de Inglaterra. La única excepción a la exclusividad del arbitraje es que usted tiene derecho a presentar un reclamo individual contra la Compañía en un tribunal de reclamos menores de jurisdicción competente. Pero ya sea que elija arbitraje o tribunal de reclamos menores, bajo ninguna circunstancia puede iniciar o mantener contra la Compañía ninguna acción de clase, arbitraje de clase u otra acción o procedimiento representativo.","trm_18_arbitration_i_02":"Al utilizar el Servicio de cualquier manera, usted acepta el acuerdo de arbitraje anterior. Al hacerlo, USTED CESE SU DERECHO DE IR A LA CORTE para hacer valer o defender cualquier reclamo entre usted y la Compañía (excepto por asuntos que puedan ser llevados a la corte de reclamos menores). TAMBIÉN RENUNCIA A SU DERECHO A PARTICIPAR EN UNA ACCIÓN DE CLASE U OTRO PROCESO DE CLASE. Sus derechos serán determinados por un ÁRBITRO NEUTRO, NO UN JUEZ O JURADO. Tiene derecho a una audiencia imparcial ante el árbitro. El árbitro puede otorgar cualquier alivio que pueda otorgar un tribunal, pero debe tener en cuenta que los procedimientos de arbitraje suelen ser más simples y más ágiles que los juicios y otros procedimientos judiciales. Las decisiones del árbitro son ejecutables en el tribunal y pueden ser revocadas por un tribunal solo por razones muy limitadas. Para obtener detalles sobre el proceso de arbitraje, consulte nuestros Procedimientos de arbitraje.","trm_18_arbitration_i_03":"Cualquier procedimiento para hacer cumplir este acuerdo de arbitraje, incluido cualquier procedimiento para confirmar, modificar o anular un laudo arbitral, puede iniciarse en cualquier tribunal de jurisdicción competente. En caso de que este acuerdo de arbitraje sea por cualquier motivo considerado inaplicable, cualquier litigio contra la Compañía (excepto las acciones judiciales de reclamos menores) puede iniciarse solo en los tribunales federales o estatales ubicados en Inglaterra. Por la presente, consiente irrevocablemente la jurisdicción de esos tribunales para tales fines.","trm_18_arbitration_i_04":"Este Acuerdo, y cualquier disputa entre usted y la Compañía, se regirá por las leyes de Inglaterra sin tener en cuenta los principios de conflictos de leyes, siempre que este acuerdo de arbitraje se rija por la Ley Federal de Arbitraje.","trm_18_arbitration_p_1":"Para los usuarios que residen en la Unión Europea, Noruega o en cualquier otro lugar donde este acuerdo de arbitraje esté prohibido por ley, las leyes de Inglaterra, Excluyendo las reglas de conflicto de leyes de Inglaterra, se aplicarán a cualquier disputa que surja o esté relacionada con este Acuerdo o los Servicios. Todos los reclamos que surjan de este Acuerdo o de los Servicios o se relacionen con ellos se litigarán exclusivamente en los tribunales federales o estatales de Inglaterra, Y usted y DefAgent aceptan la jurisdicción personal de dichos tribunales.","trm_19_":"19.  Indemnización Por Tí.","trm_19_p":"Usted acepta indemnizar y mantener a la Compañía, sus subsidiarias y afiliadas, y sus y sus funcionarios, agentes, socios y empleados, indemnes de cualquier pérdida, responsabilidad, reclamo o demanda, incluidos los honorarios razonables de abogados, realizados por un tercero debido o que surja de su incumplimiento o incumplimiento de este Acuerdo (incluido cualquier incumplimiento de sus representaciones y garantías contenidas en este documento), cualquier publicación o Contenido que publique en el Servicio, y la violación de cualquier ley o regulación por usted. La Compañía se reserva el derecho de asumir la defensa y el control exclusivos de cualquier asunto sujeto a indemnización por su parte, en cuyo caso cooperará plenamente con la Compañía en relación con esto.","trm_20_":"20. Aviso.","trm_20_p":"La Compañía puede proporcionarle avisos, incluidos los relacionados con los cambios a este Acuerdo, utilizando cualquier medio razonable, que puede incluir correo electrónico, SMS, MMS, mensajes de texto o publicaciones en el Servicio. Es posible que dichos avisos no se reciban si viola este Acuerdo al acceder al Servicio de manera no autorizada. Usted acepta que se considera que ha recibido todos y cada uno de los avisos que se habrían entregado si hubiera accedido al Servicio de manera autorizada.","trm_21_":"21. Acuerdo Completo.","trm_21_p":"Este Acuerdo, con la Política de privacidad y las pautas o reglas específicas que se publican por separado para servicios u ofertas particulares en el Servicio, contiene el acuerdo completo entre usted y la Compañía con respecto al uso del Servicio. Si alguna disposición de este Acuerdo se considera inválida, el resto de este Acuerdo continuará en pleno vigor y efecto. El hecho de que la Compañía no ejerza o haga cumplir algún derecho o disposición de este Acuerdo no constituirá una renuncia a dicho derecho o disposición. Usted acepta que su cuenta DefAgent no es transferible y que todos sus derechos sobre su perfil o contenido dentro de su cuenta DefAgent terminan con su fallecimiento. No se crea ninguna agencia, sociedad, empresa conjunta o empleo como resultado de este Acuerdo y usted no puede hacer ninguna representación ni obligar a la Compañía de ninguna manera.","trm_question":"¿Preguntas?","trm_privacy_policy":"Cualquier duda sobre nuestra Política de privacidad debe dirigirse a caro@DefAgent.ai"}}'
      );
    },
    Cfvw: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return from;
      });
      var Observable = __webpack_require__('HDdC'),
        subscribeTo = __webpack_require__('SeVD'),
        Subscription = __webpack_require__('quSY'),
        symbol_observable = __webpack_require__('kJWO'),
        scheduleArray = __webpack_require__('jZKg'),
        symbol_iterator = __webpack_require__('Lhse'),
        isPromise = __webpack_require__('c2HN'),
        isArrayLike = __webpack_require__('I55L');
      function from(input, scheduler) {
        return scheduler
          ? (function(input, scheduler) {
              if (null != input) {
                if (
                  (function(input) {
                    return (
                      input && 'function' == typeof input[symbol_observable.a]
                    );
                  })(input)
                )
                  return (function(input, scheduler) {
                    return new Observable.a(subscriber => {
                      const sub = new Subscription.a();
                      return (
                        sub.add(
                          scheduler.schedule(() => {
                            const observable = input[symbol_observable.a]();
                            sub.add(
                              observable.subscribe({
                                next(value) {
                                  sub.add(
                                    scheduler.schedule(() =>
                                      subscriber.next(value)
                                    )
                                  );
                                },
                                error(err) {
                                  sub.add(
                                    scheduler.schedule(() =>
                                      subscriber.error(err)
                                    )
                                  );
                                },
                                complete() {
                                  sub.add(
                                    scheduler.schedule(() =>
                                      subscriber.complete()
                                    )
                                  );
                                }
                              })
                            );
                          })
                        ),
                        sub
                      );
                    });
                  })(input, scheduler);
                if (Object(isPromise.a)(input))
                  return (function(input, scheduler) {
                    return new Observable.a(subscriber => {
                      const sub = new Subscription.a();
                      return (
                        sub.add(
                          scheduler.schedule(() =>
                            input.then(
                              value => {
                                sub.add(
                                  scheduler.schedule(() => {
                                    subscriber.next(value),
                                      sub.add(
                                        scheduler.schedule(() =>
                                          subscriber.complete()
                                        )
                                      );
                                  })
                                );
                              },
                              err => {
                                sub.add(
                                  scheduler.schedule(() =>
                                    subscriber.error(err)
                                  )
                                );
                              }
                            )
                          )
                        ),
                        sub
                      );
                    });
                  })(input, scheduler);
                if (Object(isArrayLike.a)(input))
                  return Object(scheduleArray.a)(input, scheduler);
                if (
                  (function(input) {
                    return (
                      input && 'function' == typeof input[symbol_iterator.a]
                    );
                  })(input) ||
                  'string' == typeof input
                )
                  return (function(input, scheduler) {
                    if (!input) throw new Error('Iterable cannot be null');
                    return new Observable.a(subscriber => {
                      const sub = new Subscription.a();
                      let iterator;
                      return (
                        sub.add(() => {
                          iterator &&
                            'function' == typeof iterator.return &&
                            iterator.return();
                        }),
                        sub.add(
                          scheduler.schedule(() => {
                            (iterator = input[symbol_iterator.a]()),
                              sub.add(
                                scheduler.schedule(function() {
                                  if (subscriber.closed) return;
                                  let value, done;
                                  try {
                                    const result = iterator.next();
                                    (value = result.value),
                                      (done = result.done);
                                  } catch (err) {
                                    return void subscriber.error(err);
                                  }
                                  done
                                    ? subscriber.complete()
                                    : (subscriber.next(value), this.schedule());
                                })
                              );
                          })
                        ),
                        sub
                      );
                    });
                  })(input, scheduler);
              }
              throw new TypeError(
                ((null !== input && typeof input) || input) +
                  ' is not observable'
              );
            })(input, scheduler)
          : input instanceof Observable.a
          ? input
          : new Observable.a(Object(subscribeTo.a)(input));
      }
    },
    DH7j: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return isArray;
      });
      const isArray = (() =>
        Array.isArray || (x => x && 'number' == typeof x.length))();
    },
    DPsx: function(module, exports, __webpack_require__) {
      var DESCRIPTORS = __webpack_require__('g6v/'),
        fails = __webpack_require__('0Dky'),
        createElement = __webpack_require__('zBJ4');
      module.exports =
        !DESCRIPTORS &&
        !fails(function() {
          return (
            7 !=
            Object.defineProperty(createElement('div'), 'a', {
              get: function() {
                return 7;
              }
            }).a
          );
        });
    },
    E9XD: function(module, exports, __webpack_require__) {
      'use strict';
      var $ = __webpack_require__('I+eb'),
        $reduce = __webpack_require__('1Y/n').left;
      $(
        {
          target: 'Array',
          proto: !0,
          forced: __webpack_require__('swFL')('reduce')
        },
        {
          reduce: function(callbackfn) {
            return $reduce(
              this,
              callbackfn,
              arguments.length,
              arguments.length > 1 ? arguments[1] : void 0
            );
          }
        }
      );
    },
    ENF9: function(module, exports, __webpack_require__) {
      'use strict';
      var InternalWeakMap,
        global = __webpack_require__('2oRo'),
        redefineAll = __webpack_require__('4syw'),
        InternalMetadataModule = __webpack_require__('8YOa'),
        collection = __webpack_require__('bWFh'),
        collectionWeak = __webpack_require__('rKzb'),
        isObject = __webpack_require__('hh1v'),
        enforceIternalState = __webpack_require__('afO8').enforce,
        NATIVE_WEAK_MAP = __webpack_require__('f5p1'),
        IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global,
        isExtensible = Object.isExtensible,
        wrapper = function(get) {
          return function() {
            return get(this, arguments.length ? arguments[0] : void 0);
          };
        },
        $WeakMap = (module.exports = collection(
          'WeakMap',
          wrapper,
          collectionWeak,
          !0,
          !0
        ));
      if (NATIVE_WEAK_MAP && IS_IE11) {
        (InternalWeakMap = collectionWeak.getConstructor(
          wrapper,
          'WeakMap',
          !0
        )),
          (InternalMetadataModule.REQUIRED = !0);
        var WeakMapPrototype = $WeakMap.prototype,
          nativeDelete = WeakMapPrototype.delete,
          nativeHas = WeakMapPrototype.has,
          nativeGet = WeakMapPrototype.get,
          nativeSet = WeakMapPrototype.set;
        redefineAll(WeakMapPrototype, {
          delete: function(key) {
            if (isObject(key) && !isExtensible(key)) {
              var state = enforceIternalState(this);
              return (
                state.frozen || (state.frozen = new InternalWeakMap()),
                nativeDelete.call(this, key) || state.frozen.delete(key)
              );
            }
            return nativeDelete.call(this, key);
          },
          has: function(key) {
            if (isObject(key) && !isExtensible(key)) {
              var state = enforceIternalState(this);
              return (
                state.frozen || (state.frozen = new InternalWeakMap()),
                nativeHas.call(this, key) || state.frozen.has(key)
              );
            }
            return nativeHas.call(this, key);
          },
          get: function(key) {
            if (isObject(key) && !isExtensible(key)) {
              var state = enforceIternalState(this);
              return (
                state.frozen || (state.frozen = new InternalWeakMap()),
                nativeHas.call(this, key)
                  ? nativeGet.call(this, key)
                  : state.frozen.get(key)
              );
            }
            return nativeGet.call(this, key);
          },
          set: function(key, value) {
            if (isObject(key) && !isExtensible(key)) {
              var state = enforceIternalState(this);
              state.frozen || (state.frozen = new InternalWeakMap()),
                nativeHas.call(this, key)
                  ? nativeSet.call(this, key, value)
                  : state.frozen.set(key, value);
            } else nativeSet.call(this, key, value);
            return this;
          }
        });
      }
    },
    EY2u: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return EMPTY;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return empty;
        });
      var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        'HDdC'
      );
      const EMPTY = new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(subscriber =>
        subscriber.complete()
      );
      function empty(scheduler) {
        return scheduler
          ? (function(scheduler) {
              return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(
                subscriber => scheduler.schedule(() => subscriber.complete())
              );
            })(scheduler)
          : EMPTY;
      }
    },
    F8JR: function(module, exports, __webpack_require__) {
      'use strict';
      var $forEach = __webpack_require__('tycR').forEach,
        sloppyArrayMethod = __webpack_require__('swFL');
      module.exports = sloppyArrayMethod('forEach')
        ? function(callbackfn) {
            return $forEach(
              this,
              callbackfn,
              arguments.length > 1 ? arguments[1] : void 0
            );
          }
        : [].forEach;
    },
    FMNM: function(module, exports, __webpack_require__) {
      var classof = __webpack_require__('xrYK'),
        regexpExec = __webpack_require__('kmMV');
      module.exports = function(R, S) {
        var exec = R.exec;
        if ('function' == typeof exec) {
          var result = exec.call(R, S);
          if ('object' != typeof result)
            throw TypeError(
              'RegExp exec method returned something other than an Object or null'
            );
          return result;
        }
        if ('RegExp' !== classof(R))
          throw TypeError('RegExp#exec called on incompatible receiver');
        return regexpExec.call(R, S);
      };
    },
    FZtP: function(module, exports, __webpack_require__) {
      var global = __webpack_require__('2oRo'),
        DOMIterables = __webpack_require__('/byt'),
        forEach = __webpack_require__('F8JR'),
        hide = __webpack_require__('X2U+');
      for (var COLLECTION_NAME in DOMIterables) {
        var Collection = global[COLLECTION_NAME],
          CollectionPrototype = Collection && Collection.prototype;
        if (CollectionPrototype && CollectionPrototype.forEach !== forEach)
          try {
            hide(CollectionPrototype, 'forEach', forEach);
          } catch (error) {
            CollectionPrototype.forEach = forEach;
          }
      }
    },
    'G+Rx': function(module, exports, __webpack_require__) {
      var getBuiltIn = __webpack_require__('0GbY');
      module.exports = getBuiltIn('document', 'documentElement');
    },
    GarU: function(module, exports) {
      module.exports = function(it, Constructor, name) {
        if (!(it instanceof Constructor))
          throw TypeError(
            'Incorrect ' + (name ? name + ' ' : '') + 'invocation'
          );
        return it;
      };
    },
    GyhO: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return concat;
      });
      var _of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__('LRne'),
        _operators_concatAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          '0EUg'
        );
      function concat(...observables) {
        return Object(_operators_concatAll__WEBPACK_IMPORTED_MODULE_1__.a)()(
          Object(_of__WEBPACK_IMPORTED_MODULE_0__.a)(...observables)
        );
      }
    },
    HAuM: function(module, exports) {
      module.exports = function(it) {
        if ('function' != typeof it)
          throw TypeError(String(it) + ' is not a function');
        return it;
      };
    },
    HDdC: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return Observable_Observable;
      });
      var Subscriber = __webpack_require__('7o/Q'),
        rxSubscriber = __webpack_require__('2QA8'),
        Observer = __webpack_require__('gRHU'),
        observable = __webpack_require__('kJWO'),
        pipe = __webpack_require__('mCNh'),
        config = __webpack_require__('2fFW');
      let Observable_Observable = (() => {
        class Observable {
          constructor(subscribe) {
            (this._isScalar = !1), subscribe && (this._subscribe = subscribe);
          }
          lift(operator) {
            const observable = new Observable();
            return (
              (observable.source = this),
              (observable.operator = operator),
              observable
            );
          }
          subscribe(observerOrNext, error, complete) {
            const { operator: operator } = this,
              sink = (function(nextOrObserver, error, complete) {
                if (nextOrObserver) {
                  if (nextOrObserver instanceof Subscriber.a)
                    return nextOrObserver;
                  if (nextOrObserver[rxSubscriber.a])
                    return nextOrObserver[rxSubscriber.a]();
                }
                return nextOrObserver || error || complete
                  ? new Subscriber.a(nextOrObserver, error, complete)
                  : new Subscriber.a(Observer.a);
              })(observerOrNext, error, complete);
            if (
              (sink.add(
                operator
                  ? operator.call(sink, this.source)
                  : this.source ||
                    (config.a.useDeprecatedSynchronousErrorHandling &&
                      !sink.syncErrorThrowable)
                  ? this._subscribe(sink)
                  : this._trySubscribe(sink)
              ),
              config.a.useDeprecatedSynchronousErrorHandling &&
                sink.syncErrorThrowable &&
                ((sink.syncErrorThrowable = !1), sink.syncErrorThrown))
            )
              throw sink.syncErrorValue;
            return sink;
          }
          _trySubscribe(sink) {
            try {
              return this._subscribe(sink);
            } catch (err) {
              config.a.useDeprecatedSynchronousErrorHandling &&
                ((sink.syncErrorThrown = !0), (sink.syncErrorValue = err)),
                (function(observer) {
                  for (; observer; ) {
                    const {
                      closed: closed,
                      destination: destination,
                      isStopped: isStopped
                    } = observer;
                    if (closed || isStopped) return !1;
                    observer =
                      destination && destination instanceof Subscriber.a
                        ? destination
                        : null;
                  }
                  return !0;
                })(sink)
                  ? sink.error(err)
                  : console.warn(err);
            }
          }
          forEach(next, promiseCtor) {
            return new (promiseCtor = getPromiseCtor(promiseCtor))(
              (resolve, reject) => {
                let subscription;
                subscription = this.subscribe(
                  value => {
                    try {
                      next(value);
                    } catch (err) {
                      reject(err), subscription && subscription.unsubscribe();
                    }
                  },
                  reject,
                  resolve
                );
              }
            );
          }
          _subscribe(subscriber) {
            const { source: source } = this;
            return source && source.subscribe(subscriber);
          }
          [observable.a]() {
            return this;
          }
          pipe(...operations) {
            return 0 === operations.length
              ? this
              : Object(pipe.b)(operations)(this);
          }
          toPromise(promiseCtor) {
            return new (promiseCtor = getPromiseCtor(promiseCtor))(
              (resolve, reject) => {
                let value;
                this.subscribe(
                  x => (value = x),
                  err => reject(err),
                  () => resolve(value)
                );
              }
            );
          }
        }
        return (
          (Observable.create = subscribe => new Observable(subscribe)),
          Observable
        );
      })();
      function getPromiseCtor(promiseCtor) {
        if (
          (promiseCtor || (promiseCtor = config.a.Promise || Promise),
          !promiseCtor)
        )
          throw new Error('no Promise impl found');
        return promiseCtor;
      }
    },
    HH4o: function(module, exports, __webpack_require__) {
      var ITERATOR = __webpack_require__('tiKp')('iterator'),
        SAFE_CLOSING = !1;
      try {
        var called = 0,
          iteratorWithReturn = {
            next: function() {
              return { done: !!called++ };
            },
            return: function() {
              SAFE_CLOSING = !0;
            }
          };
        (iteratorWithReturn[ITERATOR] = function() {
          return this;
        }),
          Array.from(iteratorWithReturn, function() {
            throw 2;
          });
      } catch (error) {}
      module.exports = function(exec, SKIP_CLOSING) {
        if (!SKIP_CLOSING && !SAFE_CLOSING) return !1;
        var ITERATION_SUPPORT = !1;
        try {
          var object = {};
          (object[ITERATOR] = function() {
            return {
              next: function() {
                return { done: (ITERATION_SUPPORT = !0) };
              }
            };
          }),
            exec(object);
        } catch (error) {}
        return ITERATION_SUPPORT;
      };
    },
    HYAF: function(module, exports) {
      module.exports = function(it) {
        if (null == it) throw TypeError("Can't call method on " + it);
        return it;
      };
    },
    Hd5f: function(module, exports, __webpack_require__) {
      var fails = __webpack_require__('0Dky'),
        SPECIES = __webpack_require__('tiKp')('species');
      module.exports = function(METHOD_NAME) {
        return !fails(function() {
          var array = [];
          return (
            ((array.constructor = {})[SPECIES] = function() {
              return { foo: 1 };
            }),
            1 !== array[METHOD_NAME](Boolean).foo
          );
        });
      };
    },
    'I+eb': function(module, exports, __webpack_require__) {
      var global = __webpack_require__('2oRo'),
        getOwnPropertyDescriptor = __webpack_require__('Bs8V').f,
        hide = __webpack_require__('X2U+'),
        redefine = __webpack_require__('busE'),
        setGlobal = __webpack_require__('zk60'),
        copyConstructorProperties = __webpack_require__('6JNq'),
        isForced = __webpack_require__('lMq5');
      module.exports = function(options, source) {
        var target,
          key,
          targetProperty,
          sourceProperty,
          descriptor,
          TARGET = options.target,
          GLOBAL = options.global,
          STATIC = options.stat;
        if (
          (target = GLOBAL
            ? global
            : STATIC
            ? global[TARGET] || setGlobal(TARGET, {})
            : (global[TARGET] || {}).prototype)
        )
          for (key in source) {
            if (
              ((sourceProperty = source[key]),
              (targetProperty = options.noTargetGet
                ? (descriptor = getOwnPropertyDescriptor(target, key)) &&
                  descriptor.value
                : target[key]),
              !isForced(
                GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key,
                options.forced
              ) && void 0 !== targetProperty)
            ) {
              if (typeof sourceProperty == typeof targetProperty) continue;
              copyConstructorProperties(sourceProperty, targetProperty);
            }
            (options.sham || (targetProperty && targetProperty.sham)) &&
              hide(sourceProperty, 'sham', !0),
              redefine(target, key, sourceProperty, options);
          }
      };
    },
    I55L: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return isArrayLike;
      });
      const isArrayLike = x =>
        x && 'number' == typeof x.length && 'function' != typeof x;
    },
    I8vh: function(module, exports, __webpack_require__) {
      var toInteger = __webpack_require__('ppGB'),
        max = Math.max,
        min = Math.min;
      module.exports = function(index, length) {
        var integer = toInteger(index);
        return integer < 0 ? max(integer + length, 0) : min(integer, length);
      };
    },
    IjjT: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return AsyncScheduler_AsyncScheduler;
      });
      let Scheduler = (() => {
        class Scheduler {
          constructor(SchedulerAction, now = Scheduler.now) {
            (this.SchedulerAction = SchedulerAction), (this.now = now);
          }
          schedule(work, delay = 0, state) {
            return new this.SchedulerAction(this, work).schedule(state, delay);
          }
        }
        return (Scheduler.now = () => Date.now()), Scheduler;
      })();
      class AsyncScheduler_AsyncScheduler extends Scheduler {
        constructor(SchedulerAction, now = Scheduler.now) {
          super(SchedulerAction, () =>
            AsyncScheduler_AsyncScheduler.delegate &&
            AsyncScheduler_AsyncScheduler.delegate !== this
              ? AsyncScheduler_AsyncScheduler.delegate.now()
              : now()
          ),
            (this.actions = []),
            (this.active = !1),
            (this.scheduled = void 0);
        }
        schedule(work, delay = 0, state) {
          return AsyncScheduler_AsyncScheduler.delegate &&
            AsyncScheduler_AsyncScheduler.delegate !== this
            ? AsyncScheduler_AsyncScheduler.delegate.schedule(
                work,
                delay,
                state
              )
            : super.schedule(work, delay, state);
        }
        flush(action) {
          const { actions: actions } = this;
          if (this.active) return void actions.push(action);
          let error;
          this.active = !0;
          do {
            if ((error = action.execute(action.state, action.delay))) break;
          } while ((action = actions.shift()));
          if (((this.active = !1), error)) {
            for (; (action = actions.shift()); ) action.unsubscribe();
            throw error;
          }
        }
      }
    },
    ImZN: function(module, exports, __webpack_require__) {
      var anObject = __webpack_require__('glrk'),
        isArrayIteratorMethod = __webpack_require__('6VoE'),
        toLength = __webpack_require__('UMSQ'),
        bind = __webpack_require__('+MLx'),
        getIteratorMethod = __webpack_require__('NaFW'),
        callWithSafeIterationClosing = __webpack_require__('m92n'),
        Result = function(stopped, result) {
          (this.stopped = stopped), (this.result = result);
        };
      (module.exports = function(iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
        var iterator,
          iterFn,
          index,
          length,
          result,
          step,
          boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);
        if (IS_ITERATOR) iterator = iterable;
        else {
          if ('function' != typeof (iterFn = getIteratorMethod(iterable)))
            throw TypeError('Target is not iterable');
          if (isArrayIteratorMethod(iterFn)) {
            for (
              index = 0, length = toLength(iterable.length);
              length > index;
              index++
            )
              if (
                (result = AS_ENTRIES
                  ? boundFunction(
                      anObject((step = iterable[index]))[0],
                      step[1]
                    )
                  : boundFunction(iterable[index])) &&
                result instanceof Result
              )
                return result;
            return new Result(!1);
          }
          iterator = iterFn.call(iterable);
        }
        for (; !(step = iterator.next()).done; )
          if (
            (result = callWithSafeIterationClosing(
              iterator,
              boundFunction,
              step.value,
              AS_ENTRIES
            )) &&
            result instanceof Result
          )
            return result;
        return new Result(!1);
      }).stop = function(result) {
        return new Result(!0, result);
      };
    },
    IzEk: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return take;
      });
      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          '7o/Q'
        ),
        _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          '4I5i'
        ),
        _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'EY2u'
        );
      function take(count) {
        return source =>
          0 === count
            ? Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__.b)()
            : source.lift(new TakeOperator(count));
      }
      class TakeOperator {
        constructor(total) {
          if (((this.total = total), this.total < 0))
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__.a();
        }
        call(subscriber, source) {
          return source.subscribe(new TakeSubscriber(subscriber, this.total));
        }
      }
      class TakeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(destination, total) {
          super(destination), (this.total = total), (this.count = 0);
        }
        _next(value) {
          const total = this.total,
            count = ++this.count;
          count <= total &&
            (this.destination.next(value),
            count === total &&
              (this.destination.complete(), this.unsubscribe()));
        }
      }
    },
    JBy8: function(module, exports, __webpack_require__) {
      var internalObjectKeys = __webpack_require__('yoRg'),
        hiddenKeys = __webpack_require__('eDl+').concat('length', 'prototype');
      exports.f =
        Object.getOwnPropertyNames ||
        function(O) {
          return internalObjectKeys(O, hiddenKeys);
        };
    },
    JIr8: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return catchError;
      });
      var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'l7GE'
        ),
        _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          '51Dv'
        ),
        _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'ZUHj'
        );
      function catchError(selector) {
        return function(source) {
          const operator = new CatchOperator(selector),
            caught = source.lift(operator);
          return (operator.caught = caught);
        };
      }
      class CatchOperator {
        constructor(selector) {
          this.selector = selector;
        }
        call(subscriber, source) {
          return source.subscribe(
            new CatchSubscriber(subscriber, this.selector, this.caught)
          );
        }
      }
      class CatchSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(destination, selector, caught) {
          super(destination),
            (this.selector = selector),
            (this.caught = caught);
        }
        error(err) {
          if (!this.isStopped) {
            let result;
            try {
              result = this.selector(err, this.caught);
            } catch (err2) {
              return void super.error(err2);
            }
            this._unsubscribeAndRecycle();
            const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__.a(
              this,
              void 0,
              void 0
            );
            this.add(innerSubscriber),
              Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__.a)(
                this,
                result,
                void 0,
                void 0,
                innerSubscriber
              );
          }
        }
      }
    },
    JX91: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return startWith;
      });
      var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'GyhO'
        ),
        _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'z+Ro'
        );
      function startWith(...array) {
        const scheduler = array[array.length - 1];
        return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(
          scheduler
        )
          ? (array.pop(),
            source =>
              Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__.a)(
                array,
                source,
                scheduler
              ))
          : source =>
              Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__.a)(
                array,
                source
              );
      }
    },
    Kqap: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return scan;
      });
      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        '7o/Q'
      );
      function scan(accumulator, seed) {
        let hasSeed = !1;
        return (
          arguments.length >= 2 && (hasSeed = !0),
          function(source) {
            return source.lift(new ScanOperator(accumulator, seed, hasSeed));
          }
        );
      }
      class ScanOperator {
        constructor(accumulator, seed, hasSeed = !1) {
          (this.accumulator = accumulator),
            (this.seed = seed),
            (this.hasSeed = hasSeed);
        }
        call(subscriber, source) {
          return source.subscribe(
            new ScanSubscriber(
              subscriber,
              this.accumulator,
              this.seed,
              this.hasSeed
            )
          );
        }
      }
      class ScanSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(destination, accumulator, _seed, hasSeed) {
          super(destination),
            (this.accumulator = accumulator),
            (this._seed = _seed),
            (this.hasSeed = hasSeed),
            (this.index = 0);
        }
        get seed() {
          return this._seed;
        }
        set seed(value) {
          (this.hasSeed = !0), (this._seed = value);
        }
        _next(value) {
          if (this.hasSeed) return this._tryNext(value);
          (this.seed = value), this.destination.next(value);
        }
        _tryNext(value) {
          const index = this.index++;
          let result;
          try {
            result = this.accumulator(this.seed, value, index);
          } catch (err) {
            this.destination.error(err);
          }
          (this.seed = result), this.destination.next(result);
        }
      }
    },
    KqfI: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function noop() {}
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return noop;
      });
    },
    LRne: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return of;
      });
      var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'z+Ro'
        ),
        _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__('yCtX'),
        _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'jZKg'
        );
      function of(...args) {
        let scheduler = args[args.length - 1];
        return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.a)(
          scheduler
        )
          ? (args.pop(),
            Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__.a)(
              args,
              scheduler
            ))
          : Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__.a)(args);
      }
    },
    LbVS: function(module, exports, __webpack_require__) {
      'use strict';
      function identity(val) {
        return val;
      }
      function getInputValues() {
        var _inputs = document.querySelectorAll('input');
        return Array.prototype.slice.call(_inputs).map(function(input) {
          return input.value;
        });
      }
      function setInputValues(_inputs) {
        var inputs = document.querySelectorAll('input');
        _inputs &&
          inputs.length === _inputs.length &&
          (_inputs.forEach(function(value, i) {
            var el = inputs[i];
            (el.value = value),
              el.dispatchEvent(new CustomEvent('input', { detail: el.value }));
          }),
          (_inputs.length = 0));
      }
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.bootloader = function(main, before, after) {
          'object' == typeof main &&
            ((before = main.before), (after = main.after), (main = main.main)),
            (before = before || identity),
            (after = after || identity);
          var readyState = document.readyState;
          switch (readyState) {
            case 'loading':
              document.addEventListener(
                'DOMContentLoaded',
                function __domReadyHandler() {
                  document.removeEventListener(
                    'DOMContentLoaded',
                    __domReadyHandler
                  ),
                    after(main(before(readyState)));
                }
              );
              break;
            case 'interactive':
            case 'complete':
            default:
              after(main(before(readyState)));
          }
        }),
        (exports.createNewHosts = function(cmps) {
          var components = Array.prototype.map.call(cmps, function(
            componentNode
          ) {
            var newNode = document.createElement(componentNode.tagName),
              parentNode = componentNode.parentNode,
              currentDisplay = newNode.style.display;
            return (
              (newNode.style.display = 'none'),
              parentNode.insertBefore(newNode, componentNode),
              function() {
                newNode.style.display = currentDisplay;
                try {
                  parentNode.removeChild(componentNode);
                } catch (e) {}
              }
            );
          });
          return function() {
            components.forEach(function(removeOldHost) {
              return removeOldHost();
            });
          };
        }),
        (exports.removeNgStyles = function() {
          var docHead = document.head,
            _styles = docHead.querySelectorAll('style');
          Array.prototype.slice
            .call(_styles)
            .filter(function(style) {
              return -1 !== style.innerText.indexOf('_ng');
            })
            .map(function(el) {
              return docHead.removeChild(el);
            });
        }),
        (exports.getInputValues = getInputValues),
        (exports.setInputValues = setInputValues),
        (exports.createInputTransfer = function() {
          var _inputs = getInputValues();
          return function() {
            return setInputValues(_inputs);
          };
        });
    },
    Lhse: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function getSymbolIterator() {
        return 'function' == typeof Symbol && Symbol.iterator
          ? Symbol.iterator
          : '@@iterator';
      }
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return iterator;
      });
      const iterator = getSymbolIterator();
    },
    M0ag: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return shared_module.a;
      });
      var shared_module = __webpack_require__('PCNd');
      __webpack_require__('fXoL');
    },
    'N+g0': function(module, exports, __webpack_require__) {
      var DESCRIPTORS = __webpack_require__('g6v/'),
        definePropertyModule = __webpack_require__('m/L8'),
        anObject = __webpack_require__('glrk'),
        objectKeys = __webpack_require__('33Wh');
      module.exports = DESCRIPTORS
        ? Object.defineProperties
        : function(O, Properties) {
            anObject(O);
            for (
              var key,
                keys = objectKeys(Properties),
                length = keys.length,
                index = 0;
              length > index;

            )
              definePropertyModule.f(O, (key = keys[index++]), Properties[key]);
            return O;
          };
    },
    NJ4a: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function hostReportError(err) {
        setTimeout(() => {
          throw err;
        }, 0);
      }
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return hostReportError;
      });
    },
    NaFW: function(module, exports, __webpack_require__) {
      var classof = __webpack_require__('9d/t'),
        Iterators = __webpack_require__('P4y1'),
        ITERATOR = __webpack_require__('tiKp')('iterator');
      module.exports = function(it) {
        if (null != it)
          return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
      };
    },
    O741: function(module, exports, __webpack_require__) {
      var isObject = __webpack_require__('hh1v');
      module.exports = function(it) {
        if (!isObject(it) && null !== it)
          throw TypeError("Can't set " + String(it) + ' as a prototype');
        return it;
      };
    },
    P4y1: function(module, exports) {
      module.exports = {};
    },
    PCNd: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return shared_module_SharedModule;
      });
      var common = __webpack_require__('ofXK'),
        http = __webpack_require__('tk/3'),
        angular_fontawesome = __webpack_require__('6NWb'),
        angular_feather = __webpack_require__('8mtn'),
        core = __webpack_require__('fXoL');
      const icons = {
        Archive:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-archive">\n    <polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>\n</svg>',
        Command:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-command">\n    <path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>\n</svg>',
        CheckCircle:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-check-circle">\n    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>\n</svg>',
        ShoppingBag:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-shopping-bag">\n    <path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>\n</svg>',
        Codesandbox:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-codesandbox">\n    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>\n</svg>',
        Database:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-database">\n    <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>\n</svg>',
        Briefcase:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-briefcase">\n    <rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>\n</svg>',
        Phone:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-phone">\n    <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>\n</svg>',
        Star:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-star">\n    <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>\n</svg>',
        Send:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-send">\n    <line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>\n</svg>',
        Headphones:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-headphones">\n    <path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>\n</svg>',
        HardDrive:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-hard-drive">\n    <line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line>\n</svg>',
        Calendar:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-calendar">\n    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>\n</svg>',
        BarChart:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-bar-chart">\n    <line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>\n</svg>',
        DownloadCloud:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-download-cloud">\n    <polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path>\n</svg>',
        Mail:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-mail">\n    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>\n</svg>',
        Clipboard:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-clipboard">\n    <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>\n</svg>',
        Play:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-play">\n    <polygon points="5 3 19 12 5 21 5 3"></polygon>\n</svg>',
        Box:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-box">\n    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>\n</svg>',
        Settings:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-settings">\n    <circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>\n</svg>',
        Award:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-award">\n    <circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>\n</svg>',
        Code:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-code">\n    <polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline>\n</svg>',
        Camera:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-camera">\n    <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>\n</svg>',
        Sun:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-sun">\n    <circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>\n</svg>',
        Wind:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-wind">\n    <path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>\n</svg>',
        Clock:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-clock">\n    <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>\n</svg>',
        Anchor:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-anchor">\n    <circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>\n</svg>',
        Users:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-users">\n    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>\n</svg>',
        Eye:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-eye">\n    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>\n</svg>',
        Activity:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-activity">\n    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>\n</svg>',
        UploadCloud:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-upload-cloud">\n    <polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline>\n</svg>',
        PenTool:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-pen-tool">\n    <path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle>\n</svg>',
        Zap:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-zap">\n    <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>\n</svg>',
        Map:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-map">\n    <polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line>\n</svg>',
        Cloud:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-cloud">\n    <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>\n</svg>',
        DollarSign:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-dollar-sign">\n    <line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>\n</svg>',
        ThumbsUp:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-thumbs-up">\n    <path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>\n</svg>',
        PieChart:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-pie-chart">\n    <path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path>\n</svg>',
        User:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-user">\n    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>\n</svg>',
        LifeBuoy:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-life-buoy">\n    <circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>\n</svg>',
        Image:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-image">\n    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>\n</svg>',
        Sliders:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-sliders">\n    <line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line>\n</svg>',
        Target:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-target">\n    <circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>\n</svg>',
        File:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-file">\n    <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>\n</svg>',
        Smartphone:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-smartphone">\n    <rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>\n</svg>',
        MessageCircle:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-message-circle">\n    <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>\n</svg>',
        CreditCard:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-credit-card">\n    <rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line>\n</svg>',
        Book:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-book">\n    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>\n</svg>',
        Lock:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-lock">\n    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>\n</svg>',
        Airplay:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-airplay">\n    <path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon>\n</svg>',
        Monitor:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-monitor">\n    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line>\n</svg>',
        Download:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-download">\n    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>\n</svg>',
        Hexagon:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-hexagon">\n    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>\n</svg>',
        Layers:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-layers">\n    <polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>\n</svg>',
        ArrowLeft:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-arrow-left">\n    <line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>\n</svg>',
        ArrowRight:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-arrow-right">\n    <line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>\n</svg>',
        Repeat:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-repeat">\n    <polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path>\n</svg>',
        Bell:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-bell">\n    <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>\n</svg>',
        Home:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-home">\n    <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>\n</svg>',
        Tablet:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-tablet">\n    <rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>\n</svg>',
        Layout:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-layout">\n    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line>\n</svg>',
        GitBranch:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-git-branch">\n    <line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path>\n</svg>',
        Trello:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-trello">\n    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect>\n</svg>',
        Volume2:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-volume-2">\n    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>\n</svg>',
        Share2:
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="feather feather-share-2">\n    <circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>\n</svg>'
      };
      let shared_module_SharedModule = (() => {
        class SharedModule {}
        return (
          (SharedModule.ɵmod = core.Jb({ type: SharedModule })),
          (SharedModule.ɵinj = core.Ib({
            factory: function(t) {
              return new (t || SharedModule)();
            },
            imports: [
              [
                common.b,
                http.b,
                angular_feather.b.pick(icons),
                angular_fontawesome.b
              ],
              common.b,
              http.b,
              angular_fontawesome.b
            ]
          })),
          SharedModule
        );
      })();
    },
    PKPk: function(module, exports, __webpack_require__) {
      'use strict';
      var charAt = __webpack_require__('ZUd8').charAt,
        InternalStateModule = __webpack_require__('afO8'),
        defineIterator = __webpack_require__('fdAy'),
        setInternalState = InternalStateModule.set,
        getInternalState = InternalStateModule.getterFor('String Iterator');
      defineIterator(
        String,
        'String',
        function(iterated) {
          setInternalState(this, {
            type: 'String Iterator',
            string: String(iterated),
            index: 0
          });
        },
        function() {
          var point,
            state = getInternalState(this),
            string = state.string,
            index = state.index;
          return index >= string.length
            ? { value: void 0, done: !0 }
            : ((point = charAt(string, index)),
              (state.index += point.length),
              { value: point, done: !1 });
        }
      );
    },
    PsNa: function(module, exports, __webpack_require__) {
      'use strict';
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.MODULE_CONFIG = {
          OnInit: 'hmrOnInit',
          OnStatus: 'hmrOnStatus',
          OnCheck: 'hmrOnCheck',
          OnDecline: 'hmrOnDecline',
          OnDestroy: 'hmrOnDestroy',
          AfterDestroy: 'hmrAfterDestroy'
        }),
        (exports.hmrModule = function(MODULE_REF, MODULE, CONFIG) {
          return (
            void 0 === CONFIG && (CONFIG = exports.MODULE_CONFIG),
            MODULE.hot &&
              (MODULE.hot.accept(),
              MODULE_REF.instance[exports.MODULE_CONFIG.OnInit] &&
                MODULE.hot.data &&
                MODULE_REF.instance[exports.MODULE_CONFIG.OnInit](
                  MODULE.hot.data
                ),
              MODULE_REF.instance[exports.MODULE_CONFIG.OnStatus] &&
                MODULE.hot.apply(function(status) {
                  MODULE_REF.instance[exports.MODULE_CONFIG.OnStatus](status);
                }),
              MODULE_REF.instance[exports.MODULE_CONFIG.OnCheck] &&
                MODULE.hot.check(function(err, outdatedModules) {
                  MODULE_REF.instance[exports.MODULE_CONFIG.OnCheck](
                    err,
                    outdatedModules
                  );
                }),
              MODULE_REF.instance[exports.MODULE_CONFIG.OnDecline] &&
                MODULE.hot.decline(function(dependencies) {
                  MODULE_REF.instance[exports.MODULE_CONFIG.OnDecline](
                    dependencies
                  );
                }),
              MODULE.hot.dispose(function(store) {
                MODULE_REF.instance[exports.MODULE_CONFIG.OnDestroy] &&
                  MODULE_REF.instance[exports.MODULE_CONFIG.OnDestroy](store),
                  MODULE_REF.destroy(),
                  MODULE_REF.instance[exports.MODULE_CONFIG.AfterDestroy] &&
                    MODULE_REF.instance[exports.MODULE_CONFIG.AfterDestroy](
                      store
                    );
              })),
            MODULE_REF
          );
        });
    },
    QWBl: function(module, exports, __webpack_require__) {
      'use strict';
      var $ = __webpack_require__('I+eb'),
        forEach = __webpack_require__('F8JR');
      $(
        { target: 'Array', proto: !0, forced: [].forEach != forEach },
        { forEach: forEach }
      );
    },
    Qo9l: function(module, exports, __webpack_require__) {
      module.exports = __webpack_require__('2oRo');
    },
    RK3t: function(module, exports, __webpack_require__) {
      var fails = __webpack_require__('0Dky'),
        classof = __webpack_require__('xrYK'),
        split = ''.split;
      module.exports = fails(function() {
        return !Object('z').propertyIsEnumerable(0);
      })
        ? function(it) {
            return 'String' == classof(it) ? split.call(it, '') : Object(it);
          }
        : Object;
    },
    RNIs: function(module, exports, __webpack_require__) {
      var wellKnownSymbol = __webpack_require__('tiKp'),
        create = __webpack_require__('fHMY'),
        hide = __webpack_require__('X2U+'),
        UNSCOPABLES = wellKnownSymbol('unscopables'),
        ArrayPrototype = Array.prototype;
      null == ArrayPrototype[UNSCOPABLES] &&
        hide(ArrayPrototype, UNSCOPABLES, create(null)),
        (module.exports = function(key) {
          ArrayPrototype[UNSCOPABLES][key] = !0;
        });
    },
    Rm1S: function(module, exports, __webpack_require__) {
      'use strict';
      var fixRegExpWellKnownSymbolLogic = __webpack_require__('14Sl'),
        anObject = __webpack_require__('glrk'),
        toLength = __webpack_require__('UMSQ'),
        requireObjectCoercible = __webpack_require__('HYAF'),
        advanceStringIndex = __webpack_require__('iqWW'),
        regExpExec = __webpack_require__('FMNM');
      fixRegExpWellKnownSymbolLogic('match', 1, function(
        MATCH,
        nativeMatch,
        maybeCallNative
      ) {
        return [
          function(regexp) {
            var O = requireObjectCoercible(this),
              matcher = null == regexp ? void 0 : regexp[MATCH];
            return void 0 !== matcher
              ? matcher.call(regexp, O)
              : new RegExp(regexp)[MATCH](String(O));
          },
          function(regexp) {
            var res = maybeCallNative(nativeMatch, regexp, this);
            if (res.done) return res.value;
            var rx = anObject(regexp),
              S = String(this);
            if (!rx.global) return regExpExec(rx, S);
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
            for (
              var result, A = [], n = 0;
              null !== (result = regExpExec(rx, S));

            ) {
              var matchStr = String(result[0]);
              (A[n] = matchStr),
                '' === matchStr &&
                  (rx.lastIndex = advanceStringIndex(
                    S,
                    toLength(rx.lastIndex),
                    fullUnicode
                  )),
                n++;
            }
            return 0 === n ? null : A;
          }
        ];
      });
    },
    STAE: function(module, exports, __webpack_require__) {
      var fails = __webpack_require__('0Dky');
      module.exports =
        !!Object.getOwnPropertySymbols &&
        !fails(function() {
          return !String(Symbol());
        });
    },
    SeVD: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return subscribeTo;
      });
      var subscribeToArray = __webpack_require__('ngJS'),
        hostReportError = __webpack_require__('NJ4a'),
        symbol_iterator = __webpack_require__('Lhse'),
        observable = __webpack_require__('kJWO'),
        isArrayLike = __webpack_require__('I55L'),
        isPromise = __webpack_require__('c2HN'),
        isObject = __webpack_require__('XoHu');
      const subscribeTo = result => {
        if (result && 'function' == typeof result[observable.a])
          return (
            (obj = result),
            subscriber => {
              const obs = obj[observable.a]();
              if ('function' != typeof obs.subscribe)
                throw new TypeError(
                  'Provided object does not correctly implement Symbol.observable'
                );
              return obs.subscribe(subscriber);
            }
          );
        if (Object(isArrayLike.a)(result))
          return Object(subscribeToArray.a)(result);
        if (Object(isPromise.a)(result))
          return (
            (promise = result),
            subscriber => (
              promise
                .then(
                  value => {
                    subscriber.closed ||
                      (subscriber.next(value), subscriber.complete());
                  },
                  err => subscriber.error(err)
                )
                .then(null, hostReportError.a),
              subscriber
            )
          );
        if (result && 'function' == typeof result[symbol_iterator.a])
          return (
            (iterable = result),
            subscriber => {
              const iterator = iterable[symbol_iterator.a]();
              for (;;) {
                const item = iterator.next();
                if (item.done) {
                  subscriber.complete();
                  break;
                }
                if ((subscriber.next(item.value), subscriber.closed)) break;
              }
              return (
                'function' == typeof iterator.return &&
                  subscriber.add(() => {
                    iterator.return && iterator.return();
                  }),
                subscriber
              );
            }
          );
        {
          const value = Object(isObject.a)(result)
            ? 'an invalid object'
            : `'${result}'`;
          throw new TypeError(
            `You provided ${value} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`
          );
        }
        var iterable, promise, obj;
      };
    },
    SpAZ: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function identity(x) {
        return x;
      }
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return identity;
      });
    },
    TWQb: function(module, exports, __webpack_require__) {
      var toIndexedObject = __webpack_require__('/GqU'),
        toLength = __webpack_require__('UMSQ'),
        toAbsoluteIndex = __webpack_require__('I8vh'),
        createMethod = function(IS_INCLUDES) {
          return function($this, el, fromIndex) {
            var value,
              O = toIndexedObject($this),
              length = toLength(O.length),
              index = toAbsoluteIndex(fromIndex, length);
            if (IS_INCLUDES && el != el) {
              for (; length > index; )
                if ((value = O[index++]) != value) return !0;
            } else
              for (; length > index; index++)
                if ((IS_INCLUDES || index in O) && O[index] === el)
                  return IS_INCLUDES || index || 0;
            return !IS_INCLUDES && -1;
          };
        };
      module.exports = {
        includes: createMethod(!0),
        indexOf: createMethod(!1)
      };
    },
    TeQF: function(module, exports, __webpack_require__) {
      'use strict';
      var $ = __webpack_require__('I+eb'),
        $filter = __webpack_require__('tycR').filter;
      $(
        {
          target: 'Array',
          proto: !0,
          forced: !__webpack_require__('Hd5f')('filter')
        },
        {
          filter: function(callbackfn) {
            return $filter(
              this,
              callbackfn,
              arguments.length > 1 ? arguments[1] : void 0
            );
          }
        }
      );
    },
    UMSQ: function(module, exports, __webpack_require__) {
      var toInteger = __webpack_require__('ppGB'),
        min = Math.min;
      module.exports = function(argument) {
        return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
      };
    },
    UTVS: function(module, exports) {
      var hasOwnProperty = {}.hasOwnProperty;
      module.exports = function(it, key) {
        return hasOwnProperty.call(it, key);
      };
    },
    UxlC: function(module, exports, __webpack_require__) {
      'use strict';
      var fixRegExpWellKnownSymbolLogic = __webpack_require__('14Sl'),
        anObject = __webpack_require__('glrk'),
        toObject = __webpack_require__('ewvW'),
        toLength = __webpack_require__('UMSQ'),
        toInteger = __webpack_require__('ppGB'),
        requireObjectCoercible = __webpack_require__('HYAF'),
        advanceStringIndex = __webpack_require__('iqWW'),
        regExpExec = __webpack_require__('FMNM'),
        max = Math.max,
        min = Math.min,
        floor = Math.floor,
        SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g,
        SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
      fixRegExpWellKnownSymbolLogic('replace', 2, function(
        REPLACE,
        nativeReplace,
        maybeCallNative
      ) {
        return [
          function(searchValue, replaceValue) {
            var O = requireObjectCoercible(this),
              replacer = null == searchValue ? void 0 : searchValue[REPLACE];
            return void 0 !== replacer
              ? replacer.call(searchValue, O, replaceValue)
              : nativeReplace.call(String(O), searchValue, replaceValue);
          },
          function(regexp, replaceValue) {
            var res = maybeCallNative(
              nativeReplace,
              regexp,
              this,
              replaceValue
            );
            if (res.done) return res.value;
            var rx = anObject(regexp),
              S = String(this),
              functionalReplace = 'function' == typeof replaceValue;
            functionalReplace || (replaceValue = String(replaceValue));
            var global = rx.global;
            if (global) {
              var fullUnicode = rx.unicode;
              rx.lastIndex = 0;
            }
            for (var results = []; ; ) {
              var result = regExpExec(rx, S);
              if (null === result) break;
              if ((results.push(result), !global)) break;
              '' === String(result[0]) &&
                (rx.lastIndex = advanceStringIndex(
                  S,
                  toLength(rx.lastIndex),
                  fullUnicode
                ));
            }
            for (
              var it, accumulatedResult = '', nextSourcePosition = 0, i = 0;
              i < results.length;
              i++
            ) {
              result = results[i];
              for (
                var matched = String(result[0]),
                  position = max(min(toInteger(result.index), S.length), 0),
                  captures = [],
                  j = 1;
                j < result.length;
                j++
              )
                captures.push(void 0 === (it = result[j]) ? it : String(it));
              var namedCaptures = result.groups;
              if (functionalReplace) {
                var replacerArgs = [matched].concat(captures, position, S);
                void 0 !== namedCaptures && replacerArgs.push(namedCaptures);
                var replacement = String(
                  replaceValue.apply(void 0, replacerArgs)
                );
              } else
                replacement = getSubstitution(
                  matched,
                  S,
                  position,
                  captures,
                  namedCaptures,
                  replaceValue
                );
              position >= nextSourcePosition &&
                ((accumulatedResult +=
                  S.slice(nextSourcePosition, position) + replacement),
                (nextSourcePosition = position + matched.length));
            }
            return accumulatedResult + S.slice(nextSourcePosition);
          }
        ];
        function getSubstitution(
          matched,
          str,
          position,
          captures,
          namedCaptures,
          replacement
        ) {
          var tailPos = position + matched.length,
            m = captures.length,
            symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
          return (
            void 0 !== namedCaptures &&
              ((namedCaptures = toObject(namedCaptures)),
              (symbols = SUBSTITUTION_SYMBOLS)),
            nativeReplace.call(replacement, symbols, function(match, ch) {
              var capture;
              switch (ch.charAt(0)) {
                case '$':
                  return '$';
                case '&':
                  return matched;
                case '`':
                  return str.slice(0, position);
                case "'":
                  return str.slice(tailPos);
                case '<':
                  capture = namedCaptures[ch.slice(1, -1)];
                  break;
                default:
                  var n = +ch;
                  if (0 === n) return match;
                  if (n > m) {
                    var f = floor(n / 10);
                    return 0 === f
                      ? match
                      : f <= m
                      ? void 0 === captures[f - 1]
                        ? ch.charAt(1)
                        : captures[f - 1] + ch.charAt(1)
                      : match;
                  }
                  capture = captures[n - 1];
              }
              return void 0 === capture ? '' : capture;
            })
          );
        }
      });
    },
    VRyK: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return merge;
      });
      var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'HDdC'
        ),
        _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'z+Ro'
        ),
        _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'bHdf'
        ),
        _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__('yCtX');
      function merge(...observables) {
        let concurrent = Number.POSITIVE_INFINITY,
          scheduler = null,
          last = observables[observables.length - 1];
        return (
          Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(last)
            ? ((scheduler = observables.pop()),
              observables.length > 1 &&
                'number' == typeof observables[observables.length - 1] &&
                (concurrent = observables.pop()))
            : 'number' == typeof last && (concurrent = observables.pop()),
          null === scheduler &&
          1 === observables.length &&
          observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.a
            ? observables[0]
            : Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__.a)(
                concurrent
              )(
                Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__.a)(
                  observables,
                  scheduler
                )
              )
        );
      }
    },
    VpIT: function(module, exports, __webpack_require__) {
      var global = __webpack_require__('2oRo'),
        setGlobal = __webpack_require__('zk60'),
        IS_PURE = __webpack_require__('xDBR'),
        store =
          global['__core-js_shared__'] || setGlobal('__core-js_shared__', {});
      (module.exports = function(key, value) {
        return store[key] || (store[key] = void 0 !== value ? value : {});
      })('versions', []).push({
        version: '3.1.3',
        mode: IS_PURE ? 'pure' : 'global',
        copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
      });
    },
    Vu81: function(module, exports, __webpack_require__) {
      var getBuiltIn = __webpack_require__('0GbY'),
        getOwnPropertyNamesModule = __webpack_require__('JBy8'),
        getOwnPropertySymbolsModule = __webpack_require__('dBg+'),
        anObject = __webpack_require__('glrk');
      module.exports =
        getBuiltIn('Reflect', 'ownKeys') ||
        function(it) {
          var keys = getOwnPropertyNamesModule.f(anObject(it)),
            getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return getOwnPropertySymbols
            ? keys.concat(getOwnPropertySymbols(it))
            : keys;
        };
    },
    WJkJ: function(module, exports) {
      module.exports = '\t\n\v\f\r                　\u2028\u2029\ufeff';
    },
    WKiH: function(module, exports, __webpack_require__) {
      var requireObjectCoercible = __webpack_require__('HYAF'),
        whitespace = '[' + __webpack_require__('WJkJ') + ']',
        ltrim = RegExp('^' + whitespace + whitespace + '*'),
        rtrim = RegExp(whitespace + whitespace + '*$'),
        createMethod = function(TYPE) {
          return function($this) {
            var string = String(requireObjectCoercible($this));
            return (
              1 & TYPE && (string = string.replace(ltrim, '')),
              2 & TYPE && (string = string.replace(rtrim, '')),
              string
            );
          };
        };
      module.exports = {
        start: createMethod(1),
        end: createMethod(2),
        trim: createMethod(3)
      };
    },
    WMd4: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return Notification;
      });
      var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'EY2u'
        ),
        _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'LRne'
        ),
        _observable_throwError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'z6cu'
        );
      let Notification = (() => {
        class Notification {
          constructor(kind, value, error) {
            (this.kind = kind),
              (this.value = value),
              (this.error = error),
              (this.hasValue = 'N' === kind);
          }
          observe(observer) {
            switch (this.kind) {
              case 'N':
                return observer.next && observer.next(this.value);
              case 'E':
                return observer.error && observer.error(this.error);
              case 'C':
                return observer.complete && observer.complete();
            }
          }
          do(next, error, complete) {
            switch (this.kind) {
              case 'N':
                return next && next(this.value);
              case 'E':
                return error && error(this.error);
              case 'C':
                return complete && complete();
            }
          }
          accept(nextOrObserver, error, complete) {
            return nextOrObserver && 'function' == typeof nextOrObserver.next
              ? this.observe(nextOrObserver)
              : this.do(nextOrObserver, error, complete);
          }
          toObservable() {
            switch (this.kind) {
              case 'N':
                return Object(_observable_of__WEBPACK_IMPORTED_MODULE_1__.a)(
                  this.value
                );
              case 'E':
                return Object(
                  _observable_throwError__WEBPACK_IMPORTED_MODULE_2__.a
                )(this.error);
              case 'C':
                return Object(
                  _observable_empty__WEBPACK_IMPORTED_MODULE_0__.b
                )();
            }
            throw new Error('unexpected notification kind value');
          }
          static createNext(value) {
            return void 0 !== value
              ? new Notification('N', value)
              : Notification.undefinedValueNotification;
          }
          static createError(err) {
            return new Notification('E', void 0, err);
          }
          static createComplete() {
            return Notification.completeNotification;
          }
        }
        return (
          (Notification.completeNotification = new Notification('C')),
          (Notification.undefinedValueNotification = new Notification(
            'N',
            void 0
          )),
          Notification
        );
      })();
    },
    'X2U+': function(module, exports, __webpack_require__) {
      var DESCRIPTORS = __webpack_require__('g6v/'),
        definePropertyModule = __webpack_require__('m/L8'),
        createPropertyDescriptor = __webpack_require__('XGwC');
      module.exports = DESCRIPTORS
        ? function(object, key, value) {
            return definePropertyModule.f(
              object,
              key,
              createPropertyDescriptor(1, value)
            );
          }
        : function(object, key, value) {
            return (object[key] = value), object;
          };
    },
    XGwC: function(module, exports) {
      module.exports = function(bitmap, value) {
        return {
          enumerable: !(1 & bitmap),
          configurable: !(2 & bitmap),
          writable: !(4 & bitmap),
          value: value
        };
      };
    },
    XNiG: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'b', function() {
        return SubjectSubscriber;
      }),
        __webpack_require__.d(__webpack_exports__, 'a', function() {
          return Subject;
        });
      var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'HDdC'
        ),
        _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__('7o/Q'),
        _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'quSY'
        ),
        _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          '9ppp'
        ),
        _SubjectSubscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          'Ylt2'
        ),
        _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          '2QA8'
        );
      class SubjectSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_1__.a {
        constructor(destination) {
          super(destination), (this.destination = destination);
        }
      }
      let Subject = (() => {
        class Subject extends _Observable__WEBPACK_IMPORTED_MODULE_0__.a {
          constructor() {
            super(),
              (this.observers = []),
              (this.closed = !1),
              (this.isStopped = !1),
              (this.hasError = !1),
              (this.thrownError = null);
          }
          [_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_5__.a]() {
            return new SubjectSubscriber(this);
          }
          lift(operator) {
            const subject = new AnonymousSubject(this, this);
            return (subject.operator = operator), subject;
          }
          next(value) {
            if (this.closed)
              throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.a();
            if (!this.isStopped) {
              const { observers: observers } = this,
                len = observers.length,
                copy = observers.slice();
              for (let i = 0; i < len; i++) copy[i].next(value);
            }
          }
          error(err) {
            if (this.closed)
              throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.a();
            (this.hasError = !0),
              (this.thrownError = err),
              (this.isStopped = !0);
            const { observers: observers } = this,
              len = observers.length,
              copy = observers.slice();
            for (let i = 0; i < len; i++) copy[i].error(err);
            this.observers.length = 0;
          }
          complete() {
            if (this.closed)
              throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.a();
            this.isStopped = !0;
            const { observers: observers } = this,
              len = observers.length,
              copy = observers.slice();
            for (let i = 0; i < len; i++) copy[i].complete();
            this.observers.length = 0;
          }
          unsubscribe() {
            (this.isStopped = !0), (this.closed = !0), (this.observers = null);
          }
          _trySubscribe(subscriber) {
            if (this.closed)
              throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.a();
            return super._trySubscribe(subscriber);
          }
          _subscribe(subscriber) {
            if (this.closed)
              throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.a();
            return this.hasError
              ? (subscriber.error(this.thrownError),
                _Subscription__WEBPACK_IMPORTED_MODULE_2__.a.EMPTY)
              : this.isStopped
              ? (subscriber.complete(),
                _Subscription__WEBPACK_IMPORTED_MODULE_2__.a.EMPTY)
              : (this.observers.push(subscriber),
                new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_4__.a(
                  this,
                  subscriber
                ));
          }
          asObservable() {
            const observable = new _Observable__WEBPACK_IMPORTED_MODULE_0__.a();
            return (observable.source = this), observable;
          }
        }
        return (
          (Subject.create = (destination, source) =>
            new AnonymousSubject(destination, source)),
          Subject
        );
      })();
      class AnonymousSubject extends Subject {
        constructor(destination, source) {
          super(), (this.destination = destination), (this.source = source);
        }
        next(value) {
          const { destination: destination } = this;
          destination && destination.next && destination.next(value);
        }
        error(err) {
          const { destination: destination } = this;
          destination && destination.error && this.destination.error(err);
        }
        complete() {
          const { destination: destination } = this;
          destination && destination.complete && this.destination.complete();
        }
        _subscribe(subscriber) {
          const { source: source } = this;
          return source
            ? this.source.subscribe(subscriber)
            : _Subscription__WEBPACK_IMPORTED_MODULE_2__.a.EMPTY;
        }
      }
    },
    XoHu: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function isObject(x) {
        return null !== x && 'object' == typeof x;
      }
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return isObject;
      });
    },
    YNrV: function(module, exports, __webpack_require__) {
      'use strict';
      var DESCRIPTORS = __webpack_require__('g6v/'),
        fails = __webpack_require__('0Dky'),
        objectKeys = __webpack_require__('33Wh'),
        getOwnPropertySymbolsModule = __webpack_require__('dBg+'),
        propertyIsEnumerableModule = __webpack_require__('0eef'),
        toObject = __webpack_require__('ewvW'),
        IndexedObject = __webpack_require__('RK3t'),
        nativeAssign = Object.assign;
      module.exports =
        !nativeAssign ||
        fails(function() {
          var A = {},
            B = {},
            symbol = Symbol();
          return (
            (A[symbol] = 7),
            'abcdefghijklmnopqrst'.split('').forEach(function(chr) {
              B[chr] = chr;
            }),
            7 != nativeAssign({}, A)[symbol] ||
              'abcdefghijklmnopqrst' != objectKeys(nativeAssign({}, B)).join('')
          );
        })
          ? function(target, source) {
              for (
                var T = toObject(target),
                  argumentsLength = arguments.length,
                  index = 1,
                  getOwnPropertySymbols = getOwnPropertySymbolsModule.f,
                  propertyIsEnumerable = propertyIsEnumerableModule.f;
                argumentsLength > index;

              )
                for (
                  var key,
                    S = IndexedObject(arguments[index++]),
                    keys = getOwnPropertySymbols
                      ? objectKeys(S).concat(getOwnPropertySymbols(S))
                      : objectKeys(S),
                    length = keys.length,
                    j = 0;
                  length > j;

                )
                  (key = keys[j++]),
                    (DESCRIPTORS && !propertyIsEnumerable.call(S, key)) ||
                      (T[key] = S[key]);
              return T;
            }
          : nativeAssign;
    },
    Ylt2: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return SubjectSubscription;
      });
      var _Subscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        'quSY'
      );
      class SubjectSubscription extends _Subscription__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(subject, subscriber) {
          super(),
            (this.subject = subject),
            (this.subscriber = subscriber),
            (this.closed = !1);
        }
        unsubscribe() {
          if (this.closed) return;
          this.closed = !0;
          const subject = this.subject,
            observers = subject.observers;
          if (
            ((this.subject = null),
            !observers ||
              0 === observers.length ||
              subject.isStopped ||
              subject.closed)
          )
            return;
          const subscriberIndex = observers.indexOf(this.subscriber);
          -1 !== subscriberIndex && observers.splice(subscriberIndex, 1);
        }
      }
    },
    ZAI4: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return app_module_AppModule;
      });
      var platform_browser = __webpack_require__('jhN1'),
        ng_bootstrap = __webpack_require__('1kSV'),
        shell_module = __webpack_require__('ZpN7'),
        ngx_translate_core = __webpack_require__('sYmb'),
        shared = __webpack_require__('M0ag'),
        router = __webpack_require__('tyNb'),
        merge = __webpack_require__('VRyK'),
        filter = __webpack_require__('pLZG'),
        map = __webpack_require__('lJxs'),
        switchMap = __webpack_require__('eIep'),
        environment = __webpack_require__('AytR'),
        core = __webpack_require__('ey9i'),
        aos = __webpack_require__('9a8T'),
        fesm2015_core = __webpack_require__('fXoL');
      const log = new core.b('App');
      let app_component_AppComponent = (() => {
        class AppComponent {
          constructor(
            router,
            activatedRoute,
            titleService,
            translateService,
            i18nService
          ) {
            (this.router = router),
              (this.activatedRoute = activatedRoute),
              (this.titleService = titleService),
              (this.translateService = translateService),
              (this.i18nService = i18nService);
          }
          ngOnInit() {
            environment.a.production && core.b.enableProductionMode(),
              log.debug('init'),
              this.i18nService.init(
                environment.a.defaultLanguage,
                environment.a.supportedLanguages
              );
            const onNavigationEnd = this.router.events.pipe(
              Object(filter.a)(event => event instanceof router.b)
            );
            Object(merge.a)(this.translateService.onLangChange, onNavigationEnd)
              .pipe(
                Object(map.a)(() => {
                  let route = this.activatedRoute;
                  for (; route.firstChild; ) route = route.firstChild;
                  return route;
                }),
                Object(filter.a)(route => 'primary' === route.outlet),
                Object(switchMap.a)(route => route.data),
                Object(core.d)(this)
              )
              .subscribe(event => {
                const title = event.title;
                title &&
                  this.titleService.setTitle(
                    this.translateService.instant(title)
                  );
              }),
              aos.init();
          }
          ngOnDestroy() {
            this.i18nService.destroy();
          }
        }
        return (
          (AppComponent.ɵfac = function(t) {
            return new (t || AppComponent)(
              fesm2015_core.Lb(router.e),
              fesm2015_core.Lb(router.a),
              fesm2015_core.Lb(platform_browser.d),
              fesm2015_core.Lb(ngx_translate_core.c),
              fesm2015_core.Lb(core.a)
            );
          }),
          (AppComponent.ɵcmp = fesm2015_core.Fb({
            type: AppComponent,
            selectors: [['app-root']],
            decls: 2,
            vars: 0,
            template: function(rf, ctx) {
              1 & rf &&
                (fesm2015_core.Mb(0, 'router-outlet'),
                fesm2015_core.Fc(1, '\n'));
            },
            directives: [router.h],
            styles: ['']
          })),
          AppComponent
        );
      })();
      var navbar_default_component = __webpack_require__('8ynp');
      let shell_component_ShellComponent = (() => {
        class ShellComponent {
          constructor() {}
          ngOnInit() {}
        }
        return (
          (ShellComponent.ɵfac = function(t) {
            return new (t || ShellComponent)();
          }),
          (ShellComponent.ɵcmp = fesm2015_core.Fb({
            type: ShellComponent,
            selectors: [['app-shell']],
            decls: 7,
            vars: 0,
            consts: [[1, 'position-relative', 'overflow-hidden']],
            template: function(rf, ctx) {
              1 & rf &&
                (fesm2015_core.Mb(0, 'dc-navbar-default'),
                fesm2015_core.Fc(1, '\n'),
                fesm2015_core.Qb(2, 'main', 0),
                fesm2015_core.Fc(3, '\n  '),
                fesm2015_core.Mb(4, 'router-outlet'),
                fesm2015_core.Fc(5, '\n'),
                fesm2015_core.Pb(),
                fesm2015_core.Fc(6, '\n'));
            },
            directives: [navbar_default_component.a, router.h],
            styles: ['']
          })),
          ShellComponent
        );
      })();
      class shell_service_Shell {
        static childRoutes(routes) {
          return {
            path: '',
            component: shell_component_ShellComponent,
            children: routes,
            data: { reuse: !0 }
          };
        }
      }
      const app_routing_module_routes = [
        shell_service_Shell.childRoutes([
          {
            path: 'about',
            loadChildren: () =>
              Promise.all([
                __webpack_require__.e(1),
                __webpack_require__.e(2),
                __webpack_require__.e(0),
                __webpack_require__.e(18)
              ])
                .then(__webpack_require__.bind(null, 'UoYK'))
                .then(m => m.AboutModule)
          },
          {
            path: 'ai-agents',
            loadChildren: () =>
              Promise.all([
                __webpack_require__.e(1),
                __webpack_require__.e(2),
                __webpack_require__.e(0),
                __webpack_require__.e(15)
              ])
                .then(__webpack_require__.bind(null, 'KNmM'))
                .then(m => m.AppLandingModule)
          },
          {
            path: 'customer-service',
            loadChildren: () =>
              Promise.all([
                __webpack_require__.e(1),
                __webpack_require__.e(2),
                __webpack_require__.e(5),
                __webpack_require__.e(0),
                __webpack_require__.e(17)
              ])
                .then(__webpack_require__.bind(null, 'S29G'))
                .then(m => m.AutomateSocialModule)
          },
          {
            path: 'business-solutions',
            loadChildren: () =>
              Promise.all([
                __webpack_require__.e(1),
                __webpack_require__.e(2),
                __webpack_require__.e(6),
                __webpack_require__.e(0),
                __webpack_require__.e(23)
              ])
                .then(__webpack_require__.bind(null, 'rOCi'))
                .then(m => m.BusinessSolutionsModule)
          },
          {
            path: 'contact',
            loadChildren: () =>
              Promise.all([
                __webpack_require__.e(1),
                __webpack_require__.e(0),
                __webpack_require__.e(25)
              ])
                .then(__webpack_require__.bind(null, '14/Y'))
                .then(m => m.ContactModule)
          },
          {
            path: 'health',
            loadChildren: () =>
              Promise.all([
                __webpack_require__.e(1),
                __webpack_require__.e(2),
                __webpack_require__.e(4),
                __webpack_require__.e(0),
                __webpack_require__.e(26)
              ])
                .then(__webpack_require__.bind(null, 'gJiE'))
                .then(m => m.CorporateModule)
          },
          {
            path: 'developers',
            loadChildren: () =>
              Promise.all([
                __webpack_require__.e(1),
                __webpack_require__.e(2),
                __webpack_require__.e(6),
                __webpack_require__.e(0),
                __webpack_require__.e(20)
              ])
                .then(__webpack_require__.bind(null, 'ZsP5'))
                .then(m => m.DevelopersModule)
          },
          {
            path: 'rpa',
            loadChildren: () =>
              Promise.all([
                __webpack_require__.e(1),
                __webpack_require__.e(2),
                __webpack_require__.e(0),
                __webpack_require__.e(19)
              ])
                .then(__webpack_require__.bind(null, '/jaR'))
                .then(m => m.OnlinePaymentModule)
          },
          {
            path: 'pricing',
            loadChildren: () =>
              Promise.all([
                __webpack_require__.e(1),
                __webpack_require__.e(0),
                __webpack_require__.e(14)
              ])
                .then(__webpack_require__.bind(null, 'IXWp'))
                .then(m => m.PricingModule)
          },
          {
            path: 'real-estate',
            loadChildren: () =>
              Promise.all([
                __webpack_require__.e(1),
                __webpack_require__.e(2),
                __webpack_require__.e(4),
                __webpack_require__.e(0),
                __webpack_require__.e(21)
              ])
                .then(__webpack_require__.bind(null, '55KT'))
                .then(m => m.SaasModule)
          },
          {
            path: 'drones',
            loadChildren: () =>
              Promise.all([
                __webpack_require__.e(1),
                __webpack_require__.e(2),
                __webpack_require__.e(5),
                __webpack_require__.e(0),
                __webpack_require__.e(24)
              ])
                .then(__webpack_require__.bind(null, 'koon'))
                .then(m => m.StartupModule)
          }
        ]),
        {
          path: 'processes',
          loadChildren: () =>
            Promise.all([
              __webpack_require__.e(1),
              __webpack_require__.e(2),
              __webpack_require__.e(0),
              __webpack_require__.e(12)
            ])
              .then(__webpack_require__.bind(null, 'K3F6'))
              .then(m => m.AppLanding2Module)
        },
        {
          path: 'dataflows',
          loadChildren: () =>
            Promise.all([
              __webpack_require__.e(1),
              __webpack_require__.e(2),
              __webpack_require__.e(0),
              __webpack_require__.e(16)
            ])
              .then(__webpack_require__.bind(null, 'LcuH'))
              .then(m => m.IntegrationModule)
        },
        {
          path: 'smart-business',
          loadChildren: () =>
            Promise.all([
              __webpack_require__.e(1),
              __webpack_require__.e(2),
              __webpack_require__.e(0),
              __webpack_require__.e(11)
            ])
              .then(__webpack_require__.bind(null, 'dYDE'))
              .then(m => m.SmartBusinessModule)
        },
        {
          path: 'terms',
          loadChildren: () =>
            __webpack_require__
              .e(22)
              .then(__webpack_require__.bind(null, '91Gy'))
              .then(m => m.TermsModule)
        },
        {
          path: 'social',
          loadChildren: () =>
            Promise.all([
              __webpack_require__.e(1),
              __webpack_require__.e(2),
              __webpack_require__.e(0),
              __webpack_require__.e(13)
            ])
              .then(__webpack_require__.bind(null, 'X5hu'))
              .then(m => m.SocialModule)
        },
        { path: '**', redirectTo: '', pathMatch: 'full' }
      ];
      let app_routing_module_AppRoutingModule = (() => {
        class AppRoutingModule {}
        return (
          (AppRoutingModule.ɵmod = fesm2015_core.Jb({
            type: AppRoutingModule
          })),
          (AppRoutingModule.ɵinj = fesm2015_core.Ib({
            factory: function(t) {
              return new (t || AppRoutingModule)();
            },
            providers: [],
            imports: [
              [
                router.g.forRoot(app_routing_module_routes, {
                  preloadingStrategy: router.c
                })
              ],
              router.g
            ]
          })),
          AppRoutingModule
        );
      })();
      __webpack_require__('QWBl'), __webpack_require__('FZtP');
      var can_use_dom = __webpack_require__('AxL3'),
        can_use_dom_default = __webpack_require__.n(can_use_dom),
        lodash_throttle =
          (__webpack_require__('TeQF'),
          __webpack_require__('4mDm'),
          __webpack_require__('zKZe'),
          __webpack_require__('07d7'),
          __webpack_require__('4l63'),
          __webpack_require__('PKPk'),
          __webpack_require__('ENF9'),
          __webpack_require__('3bBZ'),
          __webpack_require__('hKI/')),
        lodash_throttle_default = __webpack_require__.n(lodash_throttle),
        lodash_debounce = __webpack_require__('9/5/'),
        lodash_debounce_default = __webpack_require__.n(lodash_debounce),
        lodash_memoize = __webpack_require__('uyHG'),
        lodash_memoize_default = __webpack_require__.n(lodash_memoize),
        MapShim = (function() {
          if ('undefined' != typeof Map) return Map;
          function getIndex(arr, key) {
            var result = -1;
            return (
              arr.some(function(entry, index) {
                return entry[0] === key && ((result = index), !0);
              }),
              result
            );
          }
          return (function() {
            function class_1() {
              this.__entries__ = [];
            }
            return (
              Object.defineProperty(class_1.prototype, 'size', {
                get: function() {
                  return this.__entries__.length;
                },
                enumerable: !0,
                configurable: !0
              }),
              (class_1.prototype.get = function(key) {
                var index = getIndex(this.__entries__, key),
                  entry = this.__entries__[index];
                return entry && entry[1];
              }),
              (class_1.prototype.set = function(key, value) {
                var index = getIndex(this.__entries__, key);
                ~index
                  ? (this.__entries__[index][1] = value)
                  : this.__entries__.push([key, value]);
              }),
              (class_1.prototype.delete = function(key) {
                var entries = this.__entries__,
                  index = getIndex(entries, key);
                ~index && entries.splice(index, 1);
              }),
              (class_1.prototype.has = function(key) {
                return !!~getIndex(this.__entries__, key);
              }),
              (class_1.prototype.clear = function() {
                this.__entries__.splice(0);
              }),
              (class_1.prototype.forEach = function(callback, ctx) {
                void 0 === ctx && (ctx = null);
                for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                  var entry = _a[_i];
                  callback.call(ctx, entry[1], entry[0]);
                }
              }),
              class_1
            );
          })();
        })(),
        isBrowser =
          'undefined' != typeof window &&
          'undefined' != typeof document &&
          window.document === document,
        global$1 =
          'undefined' != typeof global && global.Math === Math
            ? global
            : 'undefined' != typeof self && self.Math === Math
            ? self
            : 'undefined' != typeof window && window.Math === Math
            ? window
            : Function('return this')(),
        requestAnimationFrame$1 =
          'function' == typeof requestAnimationFrame
            ? requestAnimationFrame.bind(global$1)
            : function(callback) {
                return setTimeout(function() {
                  return callback(Date.now());
                }, 1e3 / 60);
              },
        transitionKeys = [
          'top',
          'right',
          'bottom',
          'left',
          'width',
          'height',
          'size',
          'weight'
        ],
        mutationObserverSupported = 'undefined' != typeof MutationObserver,
        ResizeObserverController = (function() {
          function ResizeObserverController() {
            (this.connected_ = !1),
              (this.mutationEventsAdded_ = !1),
              (this.mutationsObserver_ = null),
              (this.observers_ = []),
              (this.onTransitionEnd_ = this.onTransitionEnd_.bind(this)),
              (this.refresh = (function(callback, delay) {
                var leadingCall = !1,
                  trailingCall = !1,
                  lastCallTime = 0;
                function resolvePending() {
                  leadingCall && ((leadingCall = !1), callback()),
                    trailingCall && proxy();
                }
                function timeoutCallback() {
                  requestAnimationFrame$1(resolvePending);
                }
                function proxy() {
                  var timeStamp = Date.now();
                  if (leadingCall) {
                    if (timeStamp - lastCallTime < 2) return;
                    trailingCall = !0;
                  } else
                    (leadingCall = !0),
                      (trailingCall = !1),
                      setTimeout(timeoutCallback, 20);
                  lastCallTime = timeStamp;
                }
                return proxy;
              })(this.refresh.bind(this)));
          }
          return (
            (ResizeObserverController.prototype.addObserver = function(
              observer
            ) {
              ~this.observers_.indexOf(observer) ||
                this.observers_.push(observer),
                this.connected_ || this.connect_();
            }),
            (ResizeObserverController.prototype.removeObserver = function(
              observer
            ) {
              var observers = this.observers_,
                index = observers.indexOf(observer);
              ~index && observers.splice(index, 1),
                !observers.length && this.connected_ && this.disconnect_();
            }),
            (ResizeObserverController.prototype.refresh = function() {
              this.updateObservers_() && this.refresh();
            }),
            (ResizeObserverController.prototype.updateObservers_ = function() {
              var activeObservers = this.observers_.filter(function(observer) {
                return observer.gatherActive(), observer.hasActive();
              });
              return (
                activeObservers.forEach(function(observer) {
                  return observer.broadcastActive();
                }),
                activeObservers.length > 0
              );
            }),
            (ResizeObserverController.prototype.connect_ = function() {
              isBrowser &&
                !this.connected_ &&
                (document.addEventListener(
                  'transitionend',
                  this.onTransitionEnd_
                ),
                window.addEventListener('resize', this.refresh),
                mutationObserverSupported
                  ? ((this.mutationsObserver_ = new MutationObserver(
                      this.refresh
                    )),
                    this.mutationsObserver_.observe(document, {
                      attributes: !0,
                      childList: !0,
                      characterData: !0,
                      subtree: !0
                    }))
                  : (document.addEventListener(
                      'DOMSubtreeModified',
                      this.refresh
                    ),
                    (this.mutationEventsAdded_ = !0)),
                (this.connected_ = !0));
            }),
            (ResizeObserverController.prototype.disconnect_ = function() {
              isBrowser &&
                this.connected_ &&
                (document.removeEventListener(
                  'transitionend',
                  this.onTransitionEnd_
                ),
                window.removeEventListener('resize', this.refresh),
                this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
                this.mutationEventsAdded_ &&
                  document.removeEventListener(
                    'DOMSubtreeModified',
                    this.refresh
                  ),
                (this.mutationsObserver_ = null),
                (this.mutationEventsAdded_ = !1),
                (this.connected_ = !1));
            }),
            (ResizeObserverController.prototype.onTransitionEnd_ = function(
              _a
            ) {
              var _b = _a.propertyName,
                propertyName = void 0 === _b ? '' : _b;
              transitionKeys.some(function(key) {
                return !!~propertyName.indexOf(key);
              }) && this.refresh();
            }),
            (ResizeObserverController.getInstance = function() {
              return (
                this.instance_ ||
                  (this.instance_ = new ResizeObserverController()),
                this.instance_
              );
            }),
            (ResizeObserverController.instance_ = null),
            ResizeObserverController
          );
        })(),
        defineConfigurable = function(target, props) {
          for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
            var key = _a[_i];
            Object.defineProperty(target, key, {
              value: props[key],
              enumerable: !1,
              writable: !1,
              configurable: !0
            });
          }
          return target;
        },
        getWindowOf = function(target) {
          return (
            (target &&
              target.ownerDocument &&
              target.ownerDocument.defaultView) ||
            global$1
          );
        },
        emptyRect = createRectInit(0, 0, 0, 0);
      function toFloat(value) {
        return parseFloat(value) || 0;
      }
      function getBordersSize(styles) {
        for (var positions = [], _i = 1; _i < arguments.length; _i++)
          positions[_i - 1] = arguments[_i];
        return positions.reduce(function(size, position) {
          return size + toFloat(styles['border-' + position + '-width']);
        }, 0);
      }
      var isSVGGraphicsElement =
        'undefined' != typeof SVGGraphicsElement
          ? function(target) {
              return target instanceof getWindowOf(target).SVGGraphicsElement;
            }
          : function(target) {
              return (
                target instanceof getWindowOf(target).SVGElement &&
                'function' == typeof target.getBBox
              );
            };
      function createRectInit(x, y, width, height) {
        return { x: x, y: y, width: width, height: height };
      }
      var ResizeObservation = (function() {
          function ResizeObservation(target) {
            (this.broadcastWidth = 0),
              (this.broadcastHeight = 0),
              (this.contentRect_ = createRectInit(0, 0, 0, 0)),
              (this.target = target);
          }
          return (
            (ResizeObservation.prototype.isActive = function() {
              var target,
                rect =
                  ((target = this.target),
                  isBrowser
                    ? isSVGGraphicsElement(target)
                      ? (function(target) {
                          var bbox = target.getBBox();
                          return createRectInit(0, 0, bbox.width, bbox.height);
                        })(target)
                      : (function(target) {
                          var clientWidth = target.clientWidth,
                            clientHeight = target.clientHeight;
                          if (!clientWidth && !clientHeight) return emptyRect;
                          var styles = getWindowOf(target).getComputedStyle(
                              target
                            ),
                            paddings = (function(styles) {
                              for (
                                var paddings = {},
                                  _i = 0,
                                  positions_1 = [
                                    'top',
                                    'right',
                                    'bottom',
                                    'left'
                                  ];
                                _i < positions_1.length;
                                _i++
                              ) {
                                var position = positions_1[_i];
                                paddings[position] = toFloat(
                                  styles['padding-' + position]
                                );
                              }
                              return paddings;
                            })(styles),
                            horizPad = paddings.left + paddings.right,
                            vertPad = paddings.top + paddings.bottom,
                            width = toFloat(styles.width),
                            height = toFloat(styles.height);
                          if (
                            ('border-box' === styles.boxSizing &&
                              (Math.round(width + horizPad) !== clientWidth &&
                                (width -=
                                  getBordersSize(styles, 'left', 'right') +
                                  horizPad),
                              Math.round(height + vertPad) !== clientHeight &&
                                (height -=
                                  getBordersSize(styles, 'top', 'bottom') +
                                  vertPad)),
                            !(function(target) {
                              return (
                                target ===
                                getWindowOf(target).document.documentElement
                              );
                            })(target))
                          ) {
                            var vertScrollbar =
                                Math.round(width + horizPad) - clientWidth,
                              horizScrollbar =
                                Math.round(height + vertPad) - clientHeight;
                            1 !== Math.abs(vertScrollbar) &&
                              (width -= vertScrollbar),
                              1 !== Math.abs(horizScrollbar) &&
                                (height -= horizScrollbar);
                          }
                          return createRectInit(
                            paddings.left,
                            paddings.top,
                            width,
                            height
                          );
                        })(target)
                    : emptyRect);
              return (
                (this.contentRect_ = rect),
                rect.width !== this.broadcastWidth ||
                  rect.height !== this.broadcastHeight
              );
            }),
            (ResizeObservation.prototype.broadcastRect = function() {
              var rect = this.contentRect_;
              return (
                (this.broadcastWidth = rect.width),
                (this.broadcastHeight = rect.height),
                rect
              );
            }),
            ResizeObservation
          );
        })(),
        ResizeObserverEntry = function(target, rectInit) {
          var _a,
            x,
            y,
            width,
            height,
            Constr,
            rect,
            contentRect =
              ((x = (_a = rectInit).x),
              (y = _a.y),
              (width = _a.width),
              (height = _a.height),
              (Constr =
                'undefined' != typeof DOMRectReadOnly
                  ? DOMRectReadOnly
                  : Object),
              (rect = Object.create(Constr.prototype)),
              defineConfigurable(rect, {
                x: x,
                y: y,
                width: width,
                height: height,
                top: y,
                right: x + width,
                bottom: height + y,
                left: x
              }),
              rect);
          defineConfigurable(this, {
            target: target,
            contentRect: contentRect
          });
        },
        ResizeObserverSPI = (function() {
          function ResizeObserverSPI(callback, controller, callbackCtx) {
            if (
              ((this.activeObservations_ = []),
              (this.observations_ = new MapShim()),
              'function' != typeof callback)
            )
              throw new TypeError(
                'The callback provided as parameter 1 is not a function.'
              );
            (this.callback_ = callback),
              (this.controller_ = controller),
              (this.callbackCtx_ = callbackCtx);
          }
          return (
            (ResizeObserverSPI.prototype.observe = function(target) {
              if (!arguments.length)
                throw new TypeError('1 argument required, but only 0 present.');
              if ('undefined' != typeof Element && Element instanceof Object) {
                if (!(target instanceof getWindowOf(target).Element))
                  throw new TypeError('parameter 1 is not of type "Element".');
                var observations = this.observations_;
                observations.has(target) ||
                  (observations.set(target, new ResizeObservation(target)),
                  this.controller_.addObserver(this),
                  this.controller_.refresh());
              }
            }),
            (ResizeObserverSPI.prototype.unobserve = function(target) {
              if (!arguments.length)
                throw new TypeError('1 argument required, but only 0 present.');
              if ('undefined' != typeof Element && Element instanceof Object) {
                if (!(target instanceof getWindowOf(target).Element))
                  throw new TypeError('parameter 1 is not of type "Element".');
                var observations = this.observations_;
                observations.has(target) &&
                  (observations.delete(target),
                  observations.size || this.controller_.removeObserver(this));
              }
            }),
            (ResizeObserverSPI.prototype.disconnect = function() {
              this.clearActive(),
                this.observations_.clear(),
                this.controller_.removeObserver(this);
            }),
            (ResizeObserverSPI.prototype.gatherActive = function() {
              var _this = this;
              this.clearActive(),
                this.observations_.forEach(function(observation) {
                  observation.isActive() &&
                    _this.activeObservations_.push(observation);
                });
            }),
            (ResizeObserverSPI.prototype.broadcastActive = function() {
              if (this.hasActive()) {
                var ctx = this.callbackCtx_,
                  entries = this.activeObservations_.map(function(observation) {
                    return new ResizeObserverEntry(
                      observation.target,
                      observation.broadcastRect()
                    );
                  });
                this.callback_.call(ctx, entries, ctx), this.clearActive();
              }
            }),
            (ResizeObserverSPI.prototype.clearActive = function() {
              this.activeObservations_.splice(0);
            }),
            (ResizeObserverSPI.prototype.hasActive = function() {
              return this.activeObservations_.length > 0;
            }),
            ResizeObserverSPI
          );
        })(),
        observers =
          'undefined' != typeof WeakMap ? new WeakMap() : new MapShim(),
        ResizeObserver = function ResizeObserver(callback) {
          if (!(this instanceof ResizeObserver))
            throw new TypeError('Cannot call a class as a function.');
          if (!arguments.length)
            throw new TypeError('1 argument required, but only 0 present.');
          var controller = ResizeObserverController.getInstance(),
            observer = new ResizeObserverSPI(callback, controller, this);
          observers.set(this, observer);
        };
      ['observe', 'unobserve', 'disconnect'].forEach(function(method) {
        ResizeObserver.prototype[method] = function() {
          var _a;
          return (_a = observers.get(this))[method].apply(_a, arguments);
        };
      });
      var ResizeObserver_es =
          void 0 !== global$1.ResizeObserver
            ? global$1.ResizeObserver
            : ResizeObserver,
        cachedScrollbarWidth =
          (__webpack_require__('E9XD'),
          __webpack_require__('sMBO'),
          __webpack_require__('rB9j'),
          __webpack_require__('Rm1S'),
          __webpack_require__('UxlC'),
          null),
        cachedDevicePixelRatio = null;
      function scrollbarWidth() {
        if (null === cachedScrollbarWidth) {
          if ('undefined' == typeof document) return (cachedScrollbarWidth = 0);
          var body = document.body,
            box = document.createElement('div');
          box.classList.add('simplebar-hide-scrollbar'), body.appendChild(box);
          var width = box.getBoundingClientRect().right;
          body.removeChild(box), (cachedScrollbarWidth = width);
        }
        return cachedScrollbarWidth;
      }
      can_use_dom_default.a &&
        window.addEventListener('resize', function() {
          cachedDevicePixelRatio !== window.devicePixelRatio &&
            ((cachedDevicePixelRatio = window.devicePixelRatio),
            (cachedScrollbarWidth = null));
        });
      var getOptions = function(obj) {
        return Array.prototype.reduce.call(
          obj,
          function(acc, attribute) {
            var option = attribute.name.match(/data-simplebar-(.+)/);
            if (option) {
              var key = option[1].replace(/\W+(.)/g, function(x, chr) {
                return chr.toUpperCase();
              });
              switch (attribute.value) {
                case 'true':
                  acc[key] = !0;
                  break;
                case 'false':
                  acc[key] = !1;
                  break;
                case void 0:
                  acc[key] = !0;
                  break;
                default:
                  acc[key] = attribute.value;
              }
            }
            return acc;
          },
          {}
        );
      };
      function getElementWindow(element) {
        return element &&
          element.ownerDocument &&
          element.ownerDocument.defaultView
          ? element.ownerDocument.defaultView
          : window;
      }
      function getElementDocument(element) {
        return element && element.ownerDocument
          ? element.ownerDocument
          : document;
      }
      var simplebar_esm_SimpleBar = (function() {
        function SimpleBar(element, options) {
          var _this = this;
          (this.onScroll = function() {
            var elWindow = getElementWindow(_this.el);
            _this.scrollXTicking ||
              (elWindow.requestAnimationFrame(_this.scrollX),
              (_this.scrollXTicking = !0)),
              _this.scrollYTicking ||
                (elWindow.requestAnimationFrame(_this.scrollY),
                (_this.scrollYTicking = !0));
          }),
            (this.scrollX = function() {
              _this.axis.x.isOverflowing &&
                (_this.showScrollbar('x'), _this.positionScrollbar('x')),
                (_this.scrollXTicking = !1);
            }),
            (this.scrollY = function() {
              _this.axis.y.isOverflowing &&
                (_this.showScrollbar('y'), _this.positionScrollbar('y')),
                (_this.scrollYTicking = !1);
            }),
            (this.onMouseEnter = function() {
              _this.showScrollbar('x'), _this.showScrollbar('y');
            }),
            (this.onMouseMove = function(e) {
              (_this.mouseX = e.clientX),
                (_this.mouseY = e.clientY),
                (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) &&
                  _this.onMouseMoveForAxis('x'),
                (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) &&
                  _this.onMouseMoveForAxis('y');
            }),
            (this.onMouseLeave = function() {
              _this.onMouseMove.cancel(),
                (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) &&
                  _this.onMouseLeaveForAxis('x'),
                (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) &&
                  _this.onMouseLeaveForAxis('y'),
                (_this.mouseX = -1),
                (_this.mouseY = -1);
            }),
            (this.onWindowResize = function() {
              (_this.scrollbarWidth = _this.getScrollbarWidth()),
                _this.hideNativeScrollbar();
            }),
            (this.hideScrollbars = function() {
              (_this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect()),
                (_this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect()),
                _this.isWithinBounds(_this.axis.y.track.rect) ||
                  (_this.axis.y.scrollbar.el.classList.remove(
                    _this.classNames.visible
                  ),
                  (_this.axis.y.isVisible = !1)),
                _this.isWithinBounds(_this.axis.x.track.rect) ||
                  (_this.axis.x.scrollbar.el.classList.remove(
                    _this.classNames.visible
                  ),
                  (_this.axis.x.isVisible = !1));
            }),
            (this.onPointerEvent = function(e) {
              var isWithinTrackXBounds, isWithinTrackYBounds;
              (_this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect()),
                (_this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect()),
                (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) &&
                  (isWithinTrackXBounds = _this.isWithinBounds(
                    _this.axis.x.track.rect
                  )),
                (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) &&
                  (isWithinTrackYBounds = _this.isWithinBounds(
                    _this.axis.y.track.rect
                  )),
                (isWithinTrackXBounds || isWithinTrackYBounds) &&
                  (e.preventDefault(),
                  e.stopPropagation(),
                  'mousedown' === e.type &&
                    (isWithinTrackXBounds &&
                      ((_this.axis.x.scrollbar.rect = _this.axis.x.scrollbar.el.getBoundingClientRect()),
                      _this.isWithinBounds(_this.axis.x.scrollbar.rect)
                        ? _this.onDragStart(e, 'x')
                        : _this.onTrackClick(e, 'x')),
                    isWithinTrackYBounds &&
                      ((_this.axis.y.scrollbar.rect = _this.axis.y.scrollbar.el.getBoundingClientRect()),
                      _this.isWithinBounds(_this.axis.y.scrollbar.rect)
                        ? _this.onDragStart(e, 'y')
                        : _this.onTrackClick(e, 'y'))));
            }),
            (this.drag = function(e) {
              var track = _this.axis[_this.draggedAxis].track,
                trackSize = track.rect[_this.axis[_this.draggedAxis].sizeAttr],
                scrollbar = _this.axis[_this.draggedAxis].scrollbar,
                contentSize =
                  _this.contentWrapperEl[
                    _this.axis[_this.draggedAxis].scrollSizeAttr
                  ],
                hostSize = parseInt(
                  _this.elStyles[_this.axis[_this.draggedAxis].sizeAttr],
                  10
                );
              e.preventDefault(), e.stopPropagation();
              var scrollPos =
                ((('y' === _this.draggedAxis ? e.pageY : e.pageX) -
                  track.rect[_this.axis[_this.draggedAxis].offsetAttr] -
                  _this.axis[_this.draggedAxis].dragOffset) /
                  (trackSize - scrollbar.size)) *
                (contentSize - hostSize);
              'x' === _this.draggedAxis &&
                ((scrollPos =
                  _this.isRtl &&
                  SimpleBar.getRtlHelpers().isRtlScrollbarInverted
                    ? scrollPos - (trackSize + scrollbar.size)
                    : scrollPos),
                (scrollPos =
                  _this.isRtl &&
                  SimpleBar.getRtlHelpers().isRtlScrollingInverted
                    ? -scrollPos
                    : scrollPos)),
                (_this.contentWrapperEl[
                  _this.axis[_this.draggedAxis].scrollOffsetAttr
                ] = scrollPos);
            }),
            (this.onEndDrag = function(e) {
              var elDocument = getElementDocument(_this.el),
                elWindow = getElementWindow(_this.el);
              e.preventDefault(),
                e.stopPropagation(),
                _this.el.classList.remove(_this.classNames.dragging),
                elDocument.removeEventListener('mousemove', _this.drag, !0),
                elDocument.removeEventListener('mouseup', _this.onEndDrag, !0),
                (_this.removePreventClickId = elWindow.setTimeout(function() {
                  elDocument.removeEventListener(
                    'click',
                    _this.preventClick,
                    !0
                  ),
                    elDocument.removeEventListener(
                      'dblclick',
                      _this.preventClick,
                      !0
                    ),
                    (_this.removePreventClickId = null);
                }));
            }),
            (this.preventClick = function(e) {
              e.preventDefault(), e.stopPropagation();
            }),
            (this.el = element),
            (this.minScrollbarWidth = 20),
            (this.options = Object.assign(
              {},
              SimpleBar.defaultOptions,
              {},
              options
            )),
            (this.classNames = Object.assign(
              {},
              SimpleBar.defaultOptions.classNames,
              {},
              this.options.classNames
            )),
            (this.axis = {
              x: {
                scrollOffsetAttr: 'scrollLeft',
                sizeAttr: 'width',
                scrollSizeAttr: 'scrollWidth',
                offsetSizeAttr: 'offsetWidth',
                offsetAttr: 'left',
                overflowAttr: 'overflowX',
                dragOffset: 0,
                isOverflowing: !0,
                isVisible: !1,
                forceVisible: !1,
                track: {},
                scrollbar: {}
              },
              y: {
                scrollOffsetAttr: 'scrollTop',
                sizeAttr: 'height',
                scrollSizeAttr: 'scrollHeight',
                offsetSizeAttr: 'offsetHeight',
                offsetAttr: 'top',
                overflowAttr: 'overflowY',
                dragOffset: 0,
                isOverflowing: !0,
                isVisible: !1,
                forceVisible: !1,
                track: {},
                scrollbar: {}
              }
            }),
            (this.removePreventClickId = null),
            SimpleBar.instances.has(this.el) ||
              ((this.recalculate = lodash_throttle_default()(
                this.recalculate.bind(this),
                64
              )),
              (this.onMouseMove = lodash_throttle_default()(
                this.onMouseMove.bind(this),
                64
              )),
              (this.hideScrollbars = lodash_debounce_default()(
                this.hideScrollbars.bind(this),
                this.options.timeout
              )),
              (this.onWindowResize = lodash_debounce_default()(
                this.onWindowResize.bind(this),
                64,
                { leading: !0 }
              )),
              (SimpleBar.getRtlHelpers = lodash_memoize_default()(
                SimpleBar.getRtlHelpers
              )),
              this.init());
        }
        (SimpleBar.getRtlHelpers = function() {
          var dummyDiv = document.createElement('div');
          dummyDiv.innerHTML =
            '<div class="hs-dummy-scrollbar-size"><div style="height: 200%; width: 200%; margin: 10px 0;"></div></div>';
          var scrollbarDummyEl = dummyDiv.firstElementChild;
          document.body.appendChild(scrollbarDummyEl);
          var dummyContainerChild = scrollbarDummyEl.firstElementChild;
          scrollbarDummyEl.scrollLeft = 0;
          var dummyContainerOffset = SimpleBar.getOffset(scrollbarDummyEl),
            dummyContainerChildOffset = SimpleBar.getOffset(
              dummyContainerChild
            );
          scrollbarDummyEl.scrollLeft = 999;
          var dummyContainerScrollOffsetAfterScroll = SimpleBar.getOffset(
            dummyContainerChild
          );
          return {
            isRtlScrollingInverted:
              dummyContainerOffset.left !== dummyContainerChildOffset.left &&
              dummyContainerChildOffset.left -
                dummyContainerScrollOffsetAfterScroll.left !=
                0,
            isRtlScrollbarInverted:
              dummyContainerOffset.left !== dummyContainerChildOffset.left
          };
        }),
          (SimpleBar.getOffset = function(el) {
            var rect = el.getBoundingClientRect(),
              elDocument = getElementDocument(el),
              elWindow = getElementWindow(el);
            return {
              top:
                rect.top +
                (elWindow.pageYOffset || elDocument.documentElement.scrollTop),
              left:
                rect.left +
                (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)
            };
          });
        var _proto = SimpleBar.prototype;
        return (
          (_proto.init = function() {
            SimpleBar.instances.set(this.el, this),
              can_use_dom_default.a &&
                (this.initDOM(),
                (this.scrollbarWidth = this.getScrollbarWidth()),
                this.recalculate(),
                this.initListeners());
          }),
          (_proto.initDOM = function() {
            var _this2 = this;
            if (
              (getElementDocument(this.el),
              Array.prototype.filter.call(this.el.children, function(child) {
                return child.classList.contains(_this2.classNames.wrapper);
              }).length)
            )
              (this.wrapperEl = this.el.querySelector(
                '.' + this.classNames.wrapper
              )),
                (this.contentWrapperEl =
                  this.options.scrollableNode ||
                  this.el.querySelector('.' + this.classNames.contentWrapper)),
                (this.contentEl =
                  this.options.contentNode ||
                  this.el.querySelector('.' + this.classNames.contentEl)),
                (this.offsetEl = this.el.querySelector(
                  '.' + this.classNames.offset
                )),
                (this.maskEl = this.el.querySelector(
                  '.' + this.classNames.mask
                )),
                (this.placeholderEl = this.findChild(
                  this.wrapperEl,
                  '.' + this.classNames.placeholder
                )),
                (this.heightAutoObserverWrapperEl = this.el.querySelector(
                  '.' + this.classNames.heightAutoObserverWrapperEl
                )),
                (this.heightAutoObserverEl = this.el.querySelector(
                  '.' + this.classNames.heightAutoObserverEl
                )),
                (this.axis.x.track.el = this.findChild(
                  this.el,
                  '.' + this.classNames.track + '.' + this.classNames.horizontal
                )),
                (this.axis.y.track.el = this.findChild(
                  this.el,
                  '.' + this.classNames.track + '.' + this.classNames.vertical
                ));
            else {
              for (
                this.wrapperEl = document.createElement('div'),
                  this.contentWrapperEl = document.createElement('div'),
                  this.offsetEl = document.createElement('div'),
                  this.maskEl = document.createElement('div'),
                  this.contentEl = document.createElement('div'),
                  this.placeholderEl = document.createElement('div'),
                  this.heightAutoObserverWrapperEl = document.createElement(
                    'div'
                  ),
                  this.heightAutoObserverEl = document.createElement('div'),
                  this.wrapperEl.classList.add(this.classNames.wrapper),
                  this.contentWrapperEl.classList.add(
                    this.classNames.contentWrapper
                  ),
                  this.offsetEl.classList.add(this.classNames.offset),
                  this.maskEl.classList.add(this.classNames.mask),
                  this.contentEl.classList.add(this.classNames.contentEl),
                  this.placeholderEl.classList.add(this.classNames.placeholder),
                  this.heightAutoObserverWrapperEl.classList.add(
                    this.classNames.heightAutoObserverWrapperEl
                  ),
                  this.heightAutoObserverEl.classList.add(
                    this.classNames.heightAutoObserverEl
                  );
                this.el.firstChild;

              )
                this.contentEl.appendChild(this.el.firstChild);
              this.contentWrapperEl.appendChild(this.contentEl),
                this.offsetEl.appendChild(this.contentWrapperEl),
                this.maskEl.appendChild(this.offsetEl),
                this.heightAutoObserverWrapperEl.appendChild(
                  this.heightAutoObserverEl
                ),
                this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl),
                this.wrapperEl.appendChild(this.maskEl),
                this.wrapperEl.appendChild(this.placeholderEl),
                this.el.appendChild(this.wrapperEl);
            }
            if (!this.axis.x.track.el || !this.axis.y.track.el) {
              var track = document.createElement('div'),
                scrollbar = document.createElement('div');
              track.classList.add(this.classNames.track),
                scrollbar.classList.add(this.classNames.scrollbar),
                track.appendChild(scrollbar),
                (this.axis.x.track.el = track.cloneNode(!0)),
                this.axis.x.track.el.classList.add(this.classNames.horizontal),
                (this.axis.y.track.el = track.cloneNode(!0)),
                this.axis.y.track.el.classList.add(this.classNames.vertical),
                this.el.appendChild(this.axis.x.track.el),
                this.el.appendChild(this.axis.y.track.el);
            }
            (this.axis.x.scrollbar.el = this.axis.x.track.el.querySelector(
              '.' + this.classNames.scrollbar
            )),
              (this.axis.y.scrollbar.el = this.axis.y.track.el.querySelector(
                '.' + this.classNames.scrollbar
              )),
              this.options.autoHide ||
                (this.axis.x.scrollbar.el.classList.add(
                  this.classNames.visible
                ),
                this.axis.y.scrollbar.el.classList.add(
                  this.classNames.visible
                )),
              this.el.setAttribute('data-simplebar', 'init');
          }),
          (_proto.initListeners = function() {
            var _this3 = this,
              elWindow = getElementWindow(this.el);
            this.options.autoHide &&
              this.el.addEventListener('mouseenter', this.onMouseEnter),
              ['mousedown', 'click', 'dblclick'].forEach(function(e) {
                _this3.el.addEventListener(e, _this3.onPointerEvent, !0);
              }),
              ['touchstart', 'touchend', 'touchmove'].forEach(function(e) {
                _this3.el.addEventListener(e, _this3.onPointerEvent, {
                  capture: !0,
                  passive: !0
                });
              }),
              this.el.addEventListener('mousemove', this.onMouseMove),
              this.el.addEventListener('mouseleave', this.onMouseLeave),
              this.contentWrapperEl.addEventListener('scroll', this.onScroll),
              elWindow.addEventListener('resize', this.onWindowResize);
            var resizeObserverStarted = !1;
            (this.resizeObserver = new (elWindow.ResizeObserver ||
              ResizeObserver_es)(function() {
              resizeObserverStarted && _this3.recalculate();
            })),
              this.resizeObserver.observe(this.el),
              this.resizeObserver.observe(this.contentEl),
              elWindow.requestAnimationFrame(function() {
                resizeObserverStarted = !0;
              }),
              (this.mutationObserver = new elWindow.MutationObserver(
                this.recalculate
              )),
              this.mutationObserver.observe(this.contentEl, {
                childList: !0,
                subtree: !0,
                characterData: !0
              });
          }),
          (_proto.recalculate = function() {
            var elWindow = getElementWindow(this.el);
            (this.elStyles = elWindow.getComputedStyle(this.el)),
              (this.isRtl = 'rtl' === this.elStyles.direction);
            var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1,
              isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1,
              contentElOffsetWidth = this.contentEl.offsetWidth,
              contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth,
              elOverflowX = this.elStyles.overflowX,
              elOverflowY = this.elStyles.overflowY;
            (this.contentEl.style.padding =
              this.elStyles.paddingTop +
              ' ' +
              this.elStyles.paddingRight +
              ' ' +
              this.elStyles.paddingBottom +
              ' ' +
              this.elStyles.paddingLeft),
              (this.wrapperEl.style.margin =
                '-' +
                this.elStyles.paddingTop +
                ' -' +
                this.elStyles.paddingRight +
                ' -' +
                this.elStyles.paddingBottom +
                ' -' +
                this.elStyles.paddingLeft);
            var contentElScrollHeight = this.contentEl.scrollHeight,
              contentElScrollWidth = this.contentEl.scrollWidth;
            (this.contentWrapperEl.style.height = isHeightAuto
              ? 'auto'
              : '100%'),
              (this.placeholderEl.style.width = isWidthAuto
                ? contentElOffsetWidth + 'px'
                : 'auto'),
              (this.placeholderEl.style.height = contentElScrollHeight + 'px');
            var contentWrapperElOffsetHeight = this.contentWrapperEl
              .offsetHeight;
            (this.axis.x.isOverflowing =
              contentElScrollWidth > contentElOffsetWidth),
              (this.axis.y.isOverflowing =
                contentElScrollHeight > contentWrapperElOffsetHeight),
              (this.axis.x.isOverflowing =
                'hidden' !== elOverflowX && this.axis.x.isOverflowing),
              (this.axis.y.isOverflowing =
                'hidden' !== elOverflowY && this.axis.y.isOverflowing),
              (this.axis.x.forceVisible =
                'x' === this.options.forceVisible ||
                !0 === this.options.forceVisible),
              (this.axis.y.forceVisible =
                'y' === this.options.forceVisible ||
                !0 === this.options.forceVisible),
              this.hideNativeScrollbar();
            var offsetForXScrollbar = this.axis.x.isOverflowing
              ? this.scrollbarWidth
              : 0;
            (this.axis.x.isOverflowing =
              this.axis.x.isOverflowing &&
              contentElScrollWidth >
                contentWrapperElOffsetWidth -
                  (this.axis.y.isOverflowing ? this.scrollbarWidth : 0)),
              (this.axis.y.isOverflowing =
                this.axis.y.isOverflowing &&
                contentElScrollHeight >
                  contentWrapperElOffsetHeight - offsetForXScrollbar),
              (this.axis.x.scrollbar.size = this.getScrollbarSize('x')),
              (this.axis.y.scrollbar.size = this.getScrollbarSize('y')),
              (this.axis.x.scrollbar.el.style.width =
                this.axis.x.scrollbar.size + 'px'),
              (this.axis.y.scrollbar.el.style.height =
                this.axis.y.scrollbar.size + 'px'),
              this.positionScrollbar('x'),
              this.positionScrollbar('y'),
              this.toggleTrackVisibility('x'),
              this.toggleTrackVisibility('y');
          }),
          (_proto.getScrollbarSize = function(axis) {
            if (
              (void 0 === axis && (axis = 'y'), !this.axis[axis].isOverflowing)
            )
              return 0;
            var scrollbarSize,
              trackSize = this.axis[axis].track.el[
                this.axis[axis].offsetSizeAttr
              ];
            return (
              (scrollbarSize = Math.max(
                ~~(
                  (trackSize / this.contentEl[this.axis[axis].scrollSizeAttr]) *
                  trackSize
                ),
                this.options.scrollbarMinSize
              )),
              this.options.scrollbarMaxSize &&
                (scrollbarSize = Math.min(
                  scrollbarSize,
                  this.options.scrollbarMaxSize
                )),
              scrollbarSize
            );
          }),
          (_proto.positionScrollbar = function(axis) {
            if (
              (void 0 === axis && (axis = 'y'), this.axis[axis].isOverflowing)
            ) {
              var contentSize = this.contentWrapperEl[
                  this.axis[axis].scrollSizeAttr
                ],
                trackSize = this.axis[axis].track.el[
                  this.axis[axis].offsetSizeAttr
                ],
                hostSize = parseInt(
                  this.elStyles[this.axis[axis].sizeAttr],
                  10
                ),
                scrollbar = this.axis[axis].scrollbar,
                scrollOffset = this.contentWrapperEl[
                  this.axis[axis].scrollOffsetAttr
                ],
                handleOffset = ~~(
                  ((scrollOffset =
                    'x' === axis &&
                    this.isRtl &&
                    SimpleBar.getRtlHelpers().isRtlScrollingInverted
                      ? -scrollOffset
                      : scrollOffset) /
                    (contentSize - hostSize)) *
                  (trackSize - scrollbar.size)
                );
              (handleOffset =
                'x' === axis &&
                this.isRtl &&
                SimpleBar.getRtlHelpers().isRtlScrollbarInverted
                  ? handleOffset + (trackSize - scrollbar.size)
                  : handleOffset),
                (scrollbar.el.style.transform =
                  'x' === axis
                    ? 'translate3d(' + handleOffset + 'px, 0, 0)'
                    : 'translate3d(0, ' + handleOffset + 'px, 0)');
            }
          }),
          (_proto.toggleTrackVisibility = function(axis) {
            void 0 === axis && (axis = 'y');
            var track = this.axis[axis].track.el,
              scrollbar = this.axis[axis].scrollbar.el;
            this.axis[axis].isOverflowing || this.axis[axis].forceVisible
              ? ((track.style.visibility = 'visible'),
                (this.contentWrapperEl.style[this.axis[axis].overflowAttr] =
                  'scroll'))
              : ((track.style.visibility = 'hidden'),
                (this.contentWrapperEl.style[this.axis[axis].overflowAttr] =
                  'hidden')),
              (scrollbar.style.display = this.axis[axis].isOverflowing
                ? 'block'
                : 'none');
          }),
          (_proto.hideNativeScrollbar = function() {
            (this.offsetEl.style[this.isRtl ? 'left' : 'right'] =
              this.axis.y.isOverflowing || this.axis.y.forceVisible
                ? '-' + this.scrollbarWidth + 'px'
                : 0),
              (this.offsetEl.style.bottom =
                this.axis.x.isOverflowing || this.axis.x.forceVisible
                  ? '-' + this.scrollbarWidth + 'px'
                  : 0);
          }),
          (_proto.onMouseMoveForAxis = function(axis) {
            void 0 === axis && (axis = 'y'),
              (this.axis[axis].track.rect = this.axis[
                axis
              ].track.el.getBoundingClientRect()),
              (this.axis[axis].scrollbar.rect = this.axis[
                axis
              ].scrollbar.el.getBoundingClientRect()),
              this.isWithinBounds(this.axis[axis].scrollbar.rect)
                ? this.axis[axis].scrollbar.el.classList.add(
                    this.classNames.hover
                  )
                : this.axis[axis].scrollbar.el.classList.remove(
                    this.classNames.hover
                  ),
              this.isWithinBounds(this.axis[axis].track.rect)
                ? (this.showScrollbar(axis),
                  this.axis[axis].track.el.classList.add(this.classNames.hover))
                : this.axis[axis].track.el.classList.remove(
                    this.classNames.hover
                  );
          }),
          (_proto.onMouseLeaveForAxis = function(axis) {
            void 0 === axis && (axis = 'y'),
              this.axis[axis].track.el.classList.remove(this.classNames.hover),
              this.axis[axis].scrollbar.el.classList.remove(
                this.classNames.hover
              );
          }),
          (_proto.showScrollbar = function(axis) {
            void 0 === axis && (axis = 'y'),
              this.axis[axis].isVisible ||
                (this.axis[axis].scrollbar.el.classList.add(
                  this.classNames.visible
                ),
                (this.axis[axis].isVisible = !0)),
              this.options.autoHide && this.hideScrollbars();
          }),
          (_proto.onDragStart = function(e, axis) {
            void 0 === axis && (axis = 'y');
            var elDocument = getElementDocument(this.el),
              elWindow = getElementWindow(this.el);
            (this.axis[axis].dragOffset =
              ('y' === axis ? e.pageY : e.pageX) -
              this.axis[axis].scrollbar.rect[this.axis[axis].offsetAttr]),
              (this.draggedAxis = axis),
              this.el.classList.add(this.classNames.dragging),
              elDocument.addEventListener('mousemove', this.drag, !0),
              elDocument.addEventListener('mouseup', this.onEndDrag, !0),
              null === this.removePreventClickId
                ? (elDocument.addEventListener('click', this.preventClick, !0),
                  elDocument.addEventListener(
                    'dblclick',
                    this.preventClick,
                    !0
                  ))
                : (elWindow.clearTimeout(this.removePreventClickId),
                  (this.removePreventClickId = null));
          }),
          (_proto.onTrackClick = function(e, axis) {
            var _this4 = this;
            if ((void 0 === axis && (axis = 'y'), this.options.clickOnTrack)) {
              var elWindow = getElementWindow(this.el);
              this.axis[axis].scrollbar.rect = this.axis[
                axis
              ].scrollbar.el.getBoundingClientRect();
              var scrollbarOffset = this.axis[axis].scrollbar.rect[
                  this.axis[axis].offsetAttr
                ],
                hostSize = parseInt(
                  this.elStyles[this.axis[axis].sizeAttr],
                  10
                ),
                scrolled = this.contentWrapperEl[
                  this.axis[axis].scrollOffsetAttr
                ],
                dir =
                  ('y' === axis
                    ? this.mouseY - scrollbarOffset
                    : this.mouseX - scrollbarOffset) < 0
                    ? -1
                    : 1,
                scrollSize =
                  -1 === dir ? scrolled - hostSize : scrolled + hostSize;
              !(function scrollTo() {
                var _this4$contentWrapper, _this4$contentWrapper2;
                -1 === dir
                  ? scrolled > scrollSize &&
                    (_this4.contentWrapperEl.scrollTo(
                      (((_this4$contentWrapper = {})[
                        _this4.axis[axis].offsetAttr
                      ] = scrolled -= 40),
                      _this4$contentWrapper)
                    ),
                    elWindow.requestAnimationFrame(scrollTo))
                  : scrolled < scrollSize &&
                    (_this4.contentWrapperEl.scrollTo(
                      (((_this4$contentWrapper2 = {})[
                        _this4.axis[axis].offsetAttr
                      ] = scrolled += 40),
                      _this4$contentWrapper2)
                    ),
                    elWindow.requestAnimationFrame(scrollTo));
              })();
            }
          }),
          (_proto.getContentElement = function() {
            return this.contentEl;
          }),
          (_proto.getScrollElement = function() {
            return this.contentWrapperEl;
          }),
          (_proto.getScrollbarWidth = function() {
            try {
              return 'none' ===
                getComputedStyle(this.contentWrapperEl, '::-webkit-scrollbar')
                  .display ||
                'scrollbarWidth' in document.documentElement.style ||
                '-ms-overflow-style' in document.documentElement.style
                ? 0
                : scrollbarWidth();
            } catch (e) {
              return scrollbarWidth();
            }
          }),
          (_proto.removeListeners = function() {
            var _this5 = this,
              elWindow = getElementWindow(this.el);
            this.options.autoHide &&
              this.el.removeEventListener('mouseenter', this.onMouseEnter),
              ['mousedown', 'click', 'dblclick'].forEach(function(e) {
                _this5.el.removeEventListener(e, _this5.onPointerEvent, !0);
              }),
              ['touchstart', 'touchend', 'touchmove'].forEach(function(e) {
                _this5.el.removeEventListener(e, _this5.onPointerEvent, {
                  capture: !0,
                  passive: !0
                });
              }),
              this.el.removeEventListener('mousemove', this.onMouseMove),
              this.el.removeEventListener('mouseleave', this.onMouseLeave),
              this.contentWrapperEl.removeEventListener(
                'scroll',
                this.onScroll
              ),
              elWindow.removeEventListener('resize', this.onWindowResize),
              this.mutationObserver.disconnect(),
              this.resizeObserver.disconnect(),
              this.recalculate.cancel(),
              this.onMouseMove.cancel(),
              this.hideScrollbars.cancel(),
              this.onWindowResize.cancel();
          }),
          (_proto.unMount = function() {
            this.removeListeners(), SimpleBar.instances.delete(this.el);
          }),
          (_proto.isWithinBounds = function(bbox) {
            return (
              this.mouseX >= bbox.left &&
              this.mouseX <= bbox.left + bbox.width &&
              this.mouseY >= bbox.top &&
              this.mouseY <= bbox.top + bbox.height
            );
          }),
          (_proto.findChild = function(el, query) {
            var matches =
              el.matches ||
              el.webkitMatchesSelector ||
              el.mozMatchesSelector ||
              el.msMatchesSelector;
            return Array.prototype.filter.call(el.children, function(child) {
              return matches.call(child, query);
            })[0];
          }),
          SimpleBar
        );
      })();
      (simplebar_esm_SimpleBar.defaultOptions = {
        autoHide: !0,
        forceVisible: !1,
        clickOnTrack: !0,
        classNames: {
          contentEl: 'simplebar-content',
          contentWrapper: 'simplebar-content-wrapper',
          offset: 'simplebar-offset',
          mask: 'simplebar-mask',
          wrapper: 'simplebar-wrapper',
          placeholder: 'simplebar-placeholder',
          scrollbar: 'simplebar-scrollbar',
          track: 'simplebar-track',
          heightAutoObserverWrapperEl: 'simplebar-height-auto-observer-wrapper',
          heightAutoObserverEl: 'simplebar-height-auto-observer',
          visible: 'simplebar-visible',
          horizontal: 'simplebar-horizontal',
          vertical: 'simplebar-vertical',
          hover: 'simplebar-hover',
          dragging: 'simplebar-dragging'
        },
        scrollbarMinSize: 25,
        scrollbarMaxSize: 0,
        timeout: 1e3
      }),
        (simplebar_esm_SimpleBar.instances = new WeakMap()),
        (simplebar_esm_SimpleBar.initDOMLoadedElements = function() {
          document.removeEventListener(
            'DOMContentLoaded',
            this.initDOMLoadedElements
          ),
            window.removeEventListener('load', this.initDOMLoadedElements),
            Array.prototype.forEach.call(
              document.querySelectorAll(
                '[data-simplebar]:not([data-simplebar="init"])'
              ),
              function(el) {
                simplebar_esm_SimpleBar.instances.has(el) ||
                  new simplebar_esm_SimpleBar(el, getOptions(el.attributes));
              }
            );
        }),
        (simplebar_esm_SimpleBar.removeObserver = function() {
          this.globalObserver.disconnect();
        }),
        (simplebar_esm_SimpleBar.initHtmlApi = function() {
          (this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this)),
            'undefined' != typeof MutationObserver &&
              ((this.globalObserver = new MutationObserver(
                simplebar_esm_SimpleBar.handleMutations
              )),
              this.globalObserver.observe(document, {
                childList: !0,
                subtree: !0
              })),
            'complete' === document.readyState ||
            ('loading' !== document.readyState &&
              !document.documentElement.doScroll)
              ? window.setTimeout(this.initDOMLoadedElements)
              : (document.addEventListener(
                  'DOMContentLoaded',
                  this.initDOMLoadedElements
                ),
                window.addEventListener('load', this.initDOMLoadedElements));
        }),
        (simplebar_esm_SimpleBar.handleMutations = function(mutations) {
          mutations.forEach(function(mutation) {
            Array.prototype.forEach.call(mutation.addedNodes, function(
              addedNode
            ) {
              1 === addedNode.nodeType &&
                (addedNode.hasAttribute('data-simplebar')
                  ? !simplebar_esm_SimpleBar.instances.has(addedNode) &&
                    new simplebar_esm_SimpleBar(
                      addedNode,
                      getOptions(addedNode.attributes)
                    )
                  : Array.prototype.forEach.call(
                      addedNode.querySelectorAll(
                        '[data-simplebar]:not([data-simplebar="init"])'
                      ),
                      function(el) {
                        !simplebar_esm_SimpleBar.instances.has(el) &&
                          new simplebar_esm_SimpleBar(
                            el,
                            getOptions(el.attributes)
                          );
                      }
                    ));
            }),
              Array.prototype.forEach.call(mutation.removedNodes, function(
                removedNode
              ) {
                1 === removedNode.nodeType &&
                  (removedNode.hasAttribute('[data-simplebar="init"]')
                    ? simplebar_esm_SimpleBar.instances.has(removedNode) &&
                      simplebar_esm_SimpleBar.instances
                        .get(removedNode)
                        .unMount()
                    : Array.prototype.forEach.call(
                        removedNode.querySelectorAll('[data-simplebar="init"]'),
                        function(el) {
                          simplebar_esm_SimpleBar.instances.has(el) &&
                            simplebar_esm_SimpleBar.instances.get(el).unMount();
                        }
                      ));
              });
          });
        }),
        (simplebar_esm_SimpleBar.getOptions = getOptions),
        can_use_dom_default.a && simplebar_esm_SimpleBar.initHtmlApi();
      let simplebar_angular_SimplebarAngularModule = (() => {
        class SimplebarAngularModule {}
        return (
          (SimplebarAngularModule.ɵmod = fesm2015_core.Jb({
            type: SimplebarAngularModule
          })),
          (SimplebarAngularModule.ɵinj = fesm2015_core.Ib({
            factory: function(t) {
              return new (t || SimplebarAngularModule)();
            },
            imports: [[]]
          })),
          SimplebarAngularModule
        );
      })();
      var common = __webpack_require__('ofXK'),
        Subject = __webpack_require__('XNiG'),
        AsyncAction = __webpack_require__('3N8a');
      class QueueAction_QueueAction extends AsyncAction.a {
        constructor(scheduler, work) {
          super(scheduler, work),
            (this.scheduler = scheduler),
            (this.work = work);
        }
        schedule(state, delay = 0) {
          return delay > 0
            ? super.schedule(state, delay)
            : ((this.delay = delay),
              (this.state = state),
              this.scheduler.flush(this),
              this);
        }
        execute(state, delay) {
          return delay > 0 || this.closed
            ? super.execute(state, delay)
            : this._execute(state, delay);
        }
        requestAsyncId(scheduler, id, delay = 0) {
          return (null !== delay && delay > 0) ||
            (null === delay && this.delay > 0)
            ? super.requestAsyncId(scheduler, id, delay)
            : scheduler.flush(this);
        }
      }
      var AsyncScheduler = __webpack_require__('IjjT');
      class QueueScheduler_QueueScheduler extends AsyncScheduler.a {}
      const queue = new QueueScheduler_QueueScheduler(QueueAction_QueueAction);
      var Subscription = __webpack_require__('quSY'),
        Subscriber = __webpack_require__('7o/Q'),
        Notification = __webpack_require__('WMd4');
      class observeOn_ObserveOnSubscriber extends Subscriber.a {
        constructor(destination, scheduler, delay = 0) {
          super(destination),
            (this.scheduler = scheduler),
            (this.delay = delay);
        }
        static dispatch(arg) {
          const { notification: notification, destination: destination } = arg;
          notification.observe(destination), this.unsubscribe();
        }
        scheduleMessage(notification) {
          this.destination.add(
            this.scheduler.schedule(
              observeOn_ObserveOnSubscriber.dispatch,
              this.delay,
              new ObserveOnMessage(notification, this.destination)
            )
          );
        }
        _next(value) {
          this.scheduleMessage(Notification.a.createNext(value));
        }
        _error(err) {
          this.scheduleMessage(Notification.a.createError(err)),
            this.unsubscribe();
        }
        _complete() {
          this.scheduleMessage(Notification.a.createComplete()),
            this.unsubscribe();
        }
      }
      class ObserveOnMessage {
        constructor(notification, destination) {
          (this.notification = notification), (this.destination = destination);
        }
      }
      var ObjectUnsubscribedError = __webpack_require__('9ppp'),
        SubjectSubscription = __webpack_require__('Ylt2');
      class ReplaySubject_ReplaySubject extends Subject.a {
        constructor(
          bufferSize = Number.POSITIVE_INFINITY,
          windowTime = Number.POSITIVE_INFINITY,
          scheduler
        ) {
          super(),
            (this.scheduler = scheduler),
            (this._events = []),
            (this._infiniteTimeWindow = !1),
            (this._bufferSize = bufferSize < 1 ? 1 : bufferSize),
            (this._windowTime = windowTime < 1 ? 1 : windowTime),
            windowTime === Number.POSITIVE_INFINITY
              ? ((this._infiniteTimeWindow = !0),
                (this.next = this.nextInfiniteTimeWindow))
              : (this.next = this.nextTimeWindow);
        }
        nextInfiniteTimeWindow(value) {
          const _events = this._events;
          _events.push(value),
            _events.length > this._bufferSize && _events.shift(),
            super.next(value);
        }
        nextTimeWindow(value) {
          this._events.push(new ReplayEvent(this._getNow(), value)),
            this._trimBufferThenGetEvents(),
            super.next(value);
        }
        _subscribe(subscriber) {
          const _infiniteTimeWindow = this._infiniteTimeWindow,
            _events = _infiniteTimeWindow
              ? this._events
              : this._trimBufferThenGetEvents(),
            scheduler = this.scheduler,
            len = _events.length;
          let subscription;
          if (this.closed) throw new ObjectUnsubscribedError.a();
          if (
            (this.isStopped || this.hasError
              ? (subscription = Subscription.a.EMPTY)
              : (this.observers.push(subscriber),
                (subscription = new SubjectSubscription.a(this, subscriber))),
            scheduler &&
              subscriber.add(
                (subscriber = new observeOn_ObserveOnSubscriber(
                  subscriber,
                  scheduler
                ))
              ),
            _infiniteTimeWindow)
          )
            for (let i = 0; i < len && !subscriber.closed; i++)
              subscriber.next(_events[i]);
          else
            for (let i = 0; i < len && !subscriber.closed; i++)
              subscriber.next(_events[i].value);
          return (
            this.hasError
              ? subscriber.error(this.thrownError)
              : this.isStopped && subscriber.complete(),
            subscription
          );
        }
        _getNow() {
          return (this.scheduler || queue).now();
        }
        _trimBufferThenGetEvents() {
          const now = this._getNow(),
            _bufferSize = this._bufferSize,
            _windowTime = this._windowTime,
            _events = this._events,
            eventsCount = _events.length;
          let spliceCount = 0;
          for (
            ;
            spliceCount < eventsCount &&
            !(now - _events[spliceCount].time < _windowTime);

          )
            spliceCount++;
          return (
            eventsCount > _bufferSize &&
              (spliceCount = Math.max(spliceCount, eventsCount - _bufferSize)),
            spliceCount > 0 && _events.splice(0, spliceCount),
            _events
          );
        }
      }
      class ReplayEvent {
        constructor(time, value) {
          (this.time = time), (this.value = value);
        }
      }
      var throwError = __webpack_require__('z6cu');
      const DEFAULTS = {
          target: null,
          action: 'click',
          duration: 650,
          easing: 'easeInOutQuad',
          offset: 0,
          offsetMap: new Map()
        },
        EASING = {
          easeInQuad: time => time * time,
          easeOutQuad: time => time * (2 - time),
          easeInOutQuad: time =>
            time < 0.5 ? 2 * time * time : (4 - 2 * time) * time - 1,
          easeInCubic: time => time * time * time,
          easeOutCubic: time => --time * time * time + 1,
          easeInOutCubic: time =>
            time < 0.5
              ? 4 * time * time * time
              : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1,
          easeInQuart: time => time * time * time * time,
          easeOutQuart: time => 1 - --time * time * time * time,
          easeInOutQuart: time =>
            time < 0.5
              ? 8 * time * time * time * time
              : 1 - 8 * --time * time * time * time,
          easeInQuint: time => time * time * time * time * time,
          easeOutQuint: time => 1 + --time * time * time * time * time,
          easeInOutQuint: time =>
            time < 0.5
              ? 16 * time * time * time * time * time
              : 1 + 16 * --time * time * time * time * time,
          easeOutElastic: time =>
            Math.pow(2, -10 * time) *
              Math.sin(((time - 1 / 4) * (2 * Math.PI)) / 1) +
            1
        };
      function isWindow(container) {
        return container === window;
      }
      class nicky_lenaers_ngx_scroll_to_ScrollToAnimation {
        constructor(
          _container,
          _listenerTarget,
          _isWindow,
          _to,
          _options,
          _isBrowser
        ) {
          (this._container = _container),
            (this._listenerTarget = _listenerTarget),
            (this._isWindow = _isWindow),
            (this._to = _to),
            (this._options = _options),
            (this._isBrowser = _isBrowser),
            (this._loop = () => {
              (this._timeLapsed += this._tick),
                (this._percentage = this._timeLapsed / this._options.duration),
                (this._percentage =
                  this._percentage > 1 ? 1 : this._percentage),
                (this._position =
                  this._startPosition +
                  (this._startPosition - this._to <= 0 ? 1 : -1) *
                    this._distance *
                    EASING[this._options.easing](this._percentage)),
                null !== this._lastPosition &&
                this._position === this._lastPosition
                  ? this.stop()
                  : (this._source$.next(this._position),
                    this._isWindow
                      ? this._listenerTarget.scrollTo(
                          0,
                          Math.floor(this._position)
                        )
                      : (this._container.scrollTop = Math.floor(
                          this._position
                        )),
                    (this._lastPosition = this._position));
            }),
            (this._tick = 16),
            (this._interval = null),
            (this._lastPosition = null),
            (this._timeLapsed = 0),
            (this._windowScrollTop =
              window.pageYOffset ||
              document.documentElement.scrollTop ||
              document.body.scrollTop ||
              0),
            (this._startPosition = this._container
              ? this._isWindow
                ? this._windowScrollTop
                : this._container.scrollTop
              : this._windowScrollTop),
            this._container &&
              !this._isWindow &&
              (this._to =
                this._to -
                this._container.getBoundingClientRect().top +
                this._startPosition);
          const directionalDistance = this._startPosition - this._to;
          (this._distance = this._container
            ? Math.abs(this._startPosition - this._to)
            : this._to),
            (this._mappedOffset = this._options.offset),
            this._isBrowser &&
              this._options.offsetMap.forEach(
                (value, key) =>
                  (this._mappedOffset =
                    window.innerWidth > key ? value : this._mappedOffset)
              ),
            (this._distance +=
              this._mappedOffset * (directionalDistance <= 0 ? 1 : -1)),
            (this._source$ = new ReplaySubject_ReplaySubject());
        }
        start() {
          return (
            clearInterval(this._interval),
            (this._interval = setInterval(this._loop, this._tick)),
            this._source$.asObservable()
          );
        }
        stop() {
          clearInterval(this._interval),
            (this._interval = null),
            this._source$.complete();
        }
      }
      let nicky_lenaers_ngx_scroll_to_ScrollToService = (() => {
          class ScrollToService {
            constructor(_document, _platformId) {
              (this._document = _document),
                (this._platformId = _platformId),
                (this._interruptiveEvents = [
                  'mousewheel',
                  'DOMMouseScroll',
                  'touchstart'
                ]);
            }
            scrollTo(options) {
              return Object(common.v)(this._platformId)
                ? this._start(options)
                : new ReplaySubject_ReplaySubject().asObservable();
            }
            _start(options) {
              const mergedConfigOptions = Object.assign({}, DEFAULTS, options);
              this._animation && this._animation.stop();
              const targetNode = this._getNode(mergedConfigOptions.target);
              if (mergedConfigOptions.target && !targetNode)
                return Object(throwError.a)('Unable to find Target Element');
              const container = this._getContainer(
                mergedConfigOptions,
                targetNode
              );
              if (mergedConfigOptions.container && !container)
                return Object(throwError.a)('Unable to find Container Element');
              const listenerTarget =
                this._getListenerTarget(container) || window;
              let to = container ? container.getBoundingClientRect().top : 0;
              targetNode &&
                (to = isWindow(listenerTarget)
                  ? targetNode.offsetTop
                  : targetNode.getBoundingClientRect().top),
                (this._animation = new nicky_lenaers_ngx_scroll_to_ScrollToAnimation(
                  container,
                  listenerTarget,
                  isWindow(listenerTarget),
                  to,
                  mergedConfigOptions,
                  Object(common.v)(this._platformId)
                ));
              const onInterrupt = () => this._animation.stop();
              this._addInterruptiveEventListeners(listenerTarget, onInterrupt);
              const animation$ = this._animation.start();
              return (
                this._subscribeToAnimation(
                  animation$,
                  listenerTarget,
                  onInterrupt
                ),
                animation$
              );
            }
            _subscribeToAnimation(animation$, listenerTarget, onInterrupt) {
              const subscription = animation$.subscribe(
                () => {},
                () => {},
                () => {
                  this._removeInterruptiveEventListeners(
                    this._interruptiveEvents,
                    listenerTarget,
                    onInterrupt
                  ),
                    subscription.unsubscribe();
                }
              );
            }
            _getContainer(options, targetNode) {
              let container = null;
              return (
                options.container
                  ? (container = this._getNode(options.container, !0))
                  : targetNode &&
                    (container = this._getFirstScrollableParent(targetNode)),
                container
              );
            }
            _addInterruptiveEventListeners(listenerTarget, handler) {
              listenerTarget || (listenerTarget = window),
                this._interruptiveEvents.forEach(event =>
                  listenerTarget.addEventListener(
                    event,
                    handler,
                    !!this._supportPassive() && { passive: !0 }
                  )
                );
            }
            _supportPassive() {
              let supportsPassive = !1;
              try {
                const opts = Object.defineProperty({}, 'passive', {
                  get: function() {
                    supportsPassive = !0;
                  }
                });
                window.addEventListener('testPassive', null, opts),
                  window.removeEventListener('testPassive', null, opts);
              } catch (e) {}
              return supportsPassive;
            }
            _removeInterruptiveEventListeners(events, listenerTarget, handler) {
              listenerTarget || (listenerTarget = window),
                events.forEach(event =>
                  listenerTarget.removeEventListener(event, handler)
                );
            }
            _getFirstScrollableParent(nativeElement) {
              let style = window.getComputedStyle(nativeElement);
              const overflowRegex = /(auto|scroll|overlay)/;
              if ('fixed' === style.position) return null;
              for (
                let parent = nativeElement;
                (parent = parent.parentElement);
                null
              )
                if (
                  ((style = window.getComputedStyle(parent)),
                  'absolute' !== style.position &&
                    'hidden' !== style.overflow &&
                    'hidden' !== style.overflowY &&
                    (overflowRegex.test(style.overflow + style.overflowY) ||
                      'BODY' === parent.tagName))
                )
                  return parent;
              return null;
            }
            _getNode(id, allowBodyTag = !1) {
              let targetNode;
              var value;
              return (
                'string' == typeof (value = id) || value instanceof String
                  ? (targetNode =
                      !allowBodyTag || ('body' !== id && 'BODY' !== id)
                        ? this._document.getElementById(
                            (function(value) {
                              return '#' === value.substring(0, 1)
                                ? value.substring(1)
                                : value;
                            })(id)
                          )
                        : this._document.body)
                  : (function(value) {
                      return !isNaN(parseFloat(value)) && isFinite(value);
                    })(id)
                  ? (targetNode = this._document.getElementById(String(id)))
                  : (function(value) {
                      return value instanceof fesm2015_core.l;
                    })(id)
                  ? (targetNode = id.nativeElement)
                  : (function(value) {
                      return value instanceof HTMLElement;
                    })(id) && (targetNode = id),
                targetNode
              );
            }
            _getListenerTarget(container) {
              return container
                ? this._isDocumentBody(container)
                  ? window
                  : container
                : null;
            }
            _isDocumentBody(element) {
              return 'BODY' === element.tagName.toUpperCase();
            }
          }
          return (
            (ScrollToService.ɵfac = function(t) {
              return new (t || ScrollToService)(
                fesm2015_core.Yb(common.c),
                fesm2015_core.Yb(fesm2015_core.B)
              );
            }),
            (ScrollToService.ɵprov = fesm2015_core.Hb({
              token: ScrollToService,
              factory: ScrollToService.ɵfac
            })),
            ScrollToService
          );
        })(),
        nicky_lenaers_ngx_scroll_to_ScrollToModule = (() => {
          class ScrollToModule {
            static forRoot() {
              return {
                ngModule: ScrollToModule,
                providers: [nicky_lenaers_ngx_scroll_to_ScrollToService]
              };
            }
          }
          return (
            (ScrollToModule.ɵmod = fesm2015_core.Jb({ type: ScrollToModule })),
            (ScrollToModule.ɵinj = fesm2015_core.Ib({
              factory: function(t) {
                return new (t || ScrollToModule)();
              }
            })),
            ScrollToModule
          );
        })();
      const home_routing_module_routes = [
        shell_service_Shell.childRoutes([
          { path: '', redirectTo: '/drones', pathMatch: 'full' }
        ])
      ];
      let home_routing_module_HomeRoutingModule = (() => {
          class HomeRoutingModule {}
          return (
            (HomeRoutingModule.ɵmod = fesm2015_core.Jb({
              type: HomeRoutingModule
            })),
            (HomeRoutingModule.ɵinj = fesm2015_core.Ib({
              factory: function(t) {
                return new (t || HomeRoutingModule)();
              },
              providers: [],
              imports: [
                [router.g.forChild(home_routing_module_routes)],
                router.g
              ]
            })),
            HomeRoutingModule
          );
        })(),
        home_module_HomeModule = (() => {
          class HomeModule {}
          return (
            (HomeModule.ɵmod = fesm2015_core.Jb({ type: HomeModule })),
            (HomeModule.ɵinj = fesm2015_core.Ib({
              factory: function(t) {
                return new (t || HomeModule)();
              },
              imports: [
                [
                  shared.a,
                  simplebar_angular_SimplebarAngularModule,
                  nicky_lenaers_ngx_scroll_to_ScrollToModule.forRoot(),
                  home_routing_module_HomeRoutingModule
                ]
              ]
            })),
            HomeModule
          );
        })(),
        app_module_AppModule = (() => {
          class AppModule {}
          return (
            (AppModule.ɵmod = fesm2015_core.Jb({
              type: AppModule,
              bootstrap: [app_component_AppComponent]
            })),
            (AppModule.ɵinj = fesm2015_core.Ib({
              factory: function(t) {
                return new (t || AppModule)();
              },
              providers: [common.g, { provide: common.h, useClass: common.e }],
              imports: [
                [
                  platform_browser.a,
                  ngx_translate_core.a.forRoot(),
                  shell_module.a,
                  shared.a,
                  ng_bootstrap.f,
                  home_module_HomeModule,
                  app_routing_module_AppRoutingModule
                ]
              ]
            })),
            AppModule
          );
        })();
    },
    ZUHj: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return subscribeToResult;
      });
      var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          '51Dv'
        ),
        _subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__('SeVD'),
        _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__('HDdC');
      function subscribeToResult(
        outerSubscriber,
        result,
        outerValue,
        outerIndex,
        destination = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__.a(
          outerSubscriber,
          outerValue,
          outerIndex
        )
      ) {
        if (!destination.closed)
          return result instanceof _Observable__WEBPACK_IMPORTED_MODULE_2__.a
            ? result.subscribe(destination)
            : Object(_subscribeTo__WEBPACK_IMPORTED_MODULE_1__.a)(result)(
                destination
              );
      }
    },
    ZUd8: function(module, exports, __webpack_require__) {
      var toInteger = __webpack_require__('ppGB'),
        requireObjectCoercible = __webpack_require__('HYAF'),
        createMethod = function(CONVERT_TO_STRING) {
          return function($this, pos) {
            var first,
              second,
              S = String(requireObjectCoercible($this)),
              position = toInteger(pos),
              size = S.length;
            return position < 0 || position >= size
              ? CONVERT_TO_STRING
                ? ''
                : void 0
              : (first = S.charCodeAt(position)) < 55296 ||
                first > 56319 ||
                position + 1 === size ||
                (second = S.charCodeAt(position + 1)) < 56320 ||
                second > 57343
              ? CONVERT_TO_STRING
                ? S.charAt(position)
                : first
              : CONVERT_TO_STRING
              ? S.slice(position, position + 2)
              : second - 56320 + ((first - 55296) << 10) + 65536;
          };
        };
      module.exports = { codeAt: createMethod(!1), charAt: createMethod(!0) };
    },
    ZfDv: function(module, exports, __webpack_require__) {
      var isObject = __webpack_require__('hh1v'),
        isArray = __webpack_require__('6LWA'),
        SPECIES = __webpack_require__('tiKp')('species');
      module.exports = function(originalArray, length) {
        var C;
        return (
          isArray(originalArray) &&
            ('function' != typeof (C = originalArray.constructor) ||
            (C !== Array && !isArray(C.prototype))
              ? isObject(C) && null === (C = C[SPECIES]) && (C = void 0)
              : (C = void 0)),
          new (void 0 === C ? Array : C)(0 === length ? 0 : length)
        );
      };
    },
    ZpN7: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return ShellModule;
      });
      var _app_shared_shared_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'PCNd'
        ),
        _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          '1kSV'
        ),
        _ngx_translate_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'sYmb'
        ),
        _angular_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          'tyNb'
        ),
        _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          'fXoL'
        );
      let ShellModule = (() => {
        class ShellModule {}
        return (
          (ShellModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_4__.Jb({
            type: ShellModule
          })),
          (ShellModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_4__.Ib({
            factory: function(t) {
              return new (t || ShellModule)();
            },
            imports: [
              [
                _app_shared_shared_module__WEBPACK_IMPORTED_MODULE_0__.a,
                _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_1__.h,
                _ngx_translate_core__WEBPACK_IMPORTED_MODULE_2__.a,
                _angular_router__WEBPACK_IMPORTED_MODULE_3__.g,
                _ngx_translate_core__WEBPACK_IMPORTED_MODULE_2__.a.forChild()
              ]
            ]
          })),
          ShellModule
        );
      })();
    },
    afO8: function(module, exports, __webpack_require__) {
      var set,
        get,
        has,
        NATIVE_WEAK_MAP = __webpack_require__('f5p1'),
        global = __webpack_require__('2oRo'),
        isObject = __webpack_require__('hh1v'),
        hide = __webpack_require__('X2U+'),
        objectHas = __webpack_require__('UTVS'),
        sharedKey = __webpack_require__('93I0'),
        hiddenKeys = __webpack_require__('0BK2');
      if (NATIVE_WEAK_MAP) {
        var store = new (0, global.WeakMap)(),
          wmget = store.get,
          wmhas = store.has,
          wmset = store.set;
        (set = function(it, metadata) {
          return wmset.call(store, it, metadata), metadata;
        }),
          (get = function(it) {
            return wmget.call(store, it) || {};
          }),
          (has = function(it) {
            return wmhas.call(store, it);
          });
      } else {
        var STATE = sharedKey('state');
        (hiddenKeys[STATE] = !0),
          (set = function(it, metadata) {
            return hide(it, STATE, metadata), metadata;
          }),
          (get = function(it) {
            return objectHas(it, STATE) ? it[STATE] : {};
          }),
          (has = function(it) {
            return objectHas(it, STATE);
          });
      }
      module.exports = {
        set: set,
        get: get,
        has: has,
        enforce: function(it) {
          return has(it) ? get(it) : set(it, {});
        },
        getterFor: function(TYPE) {
          return function(it) {
            var state;
            if (!isObject(it) || (state = get(it)).type !== TYPE)
              throw TypeError('Incompatible receiver, ' + TYPE + ' required');
            return state;
          };
        }
      };
    },
    bHdf: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return mergeAll;
      });
      var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__('5+tZ'),
        _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'SpAZ'
        );
      function mergeAll(concurrent = Number.POSITIVE_INFINITY) {
        return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(
          _util_identity__WEBPACK_IMPORTED_MODULE_1__.a,
          concurrent
        );
      }
    },
    bOdf: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return concatMap;
      });
      var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__('5+tZ');
      function concatMap(project, resultSelector) {
        return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(
          project,
          resultSelector,
          1
        );
      }
    },
    bWFh: function(module, exports, __webpack_require__) {
      'use strict';
      var $ = __webpack_require__('I+eb'),
        global = __webpack_require__('2oRo'),
        isForced = __webpack_require__('lMq5'),
        redefine = __webpack_require__('busE'),
        InternalMetadataModule = __webpack_require__('8YOa'),
        iterate = __webpack_require__('ImZN'),
        anInstance = __webpack_require__('GarU'),
        isObject = __webpack_require__('hh1v'),
        fails = __webpack_require__('0Dky'),
        checkCorrectnessOfIteration = __webpack_require__('HH4o'),
        setToStringTag = __webpack_require__('1E5z'),
        inheritIfRequired = __webpack_require__('cVYH');
      module.exports = function(
        CONSTRUCTOR_NAME,
        wrapper,
        common,
        IS_MAP,
        IS_WEAK
      ) {
        var NativeConstructor = global[CONSTRUCTOR_NAME],
          NativePrototype = NativeConstructor && NativeConstructor.prototype,
          Constructor = NativeConstructor,
          ADDER = IS_MAP ? 'set' : 'add',
          exported = {},
          fixMethod = function(KEY) {
            var nativeMethod = NativePrototype[KEY];
            redefine(
              NativePrototype,
              KEY,
              'add' == KEY
                ? function(a) {
                    return nativeMethod.call(this, 0 === a ? 0 : a), this;
                  }
                : 'delete' == KEY
                ? function(a) {
                    return (
                      !(IS_WEAK && !isObject(a)) &&
                      nativeMethod.call(this, 0 === a ? 0 : a)
                    );
                  }
                : 'get' == KEY
                ? function(a) {
                    return IS_WEAK && !isObject(a)
                      ? void 0
                      : nativeMethod.call(this, 0 === a ? 0 : a);
                  }
                : 'has' == KEY
                ? function(a) {
                    return (
                      !(IS_WEAK && !isObject(a)) &&
                      nativeMethod.call(this, 0 === a ? 0 : a)
                    );
                  }
                : function(a, b) {
                    return nativeMethod.call(this, 0 === a ? 0 : a, b), this;
                  }
            );
          };
        if (
          isForced(
            CONSTRUCTOR_NAME,
            'function' != typeof NativeConstructor ||
              !(
                IS_WEAK ||
                (NativePrototype.forEach &&
                  !fails(function() {
                    new NativeConstructor().entries().next();
                  }))
              )
          )
        )
          (Constructor = common.getConstructor(
            wrapper,
            CONSTRUCTOR_NAME,
            IS_MAP,
            ADDER
          )),
            (InternalMetadataModule.REQUIRED = !0);
        else if (isForced(CONSTRUCTOR_NAME, !0)) {
          var instance = new Constructor(),
            HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance,
            THROWS_ON_PRIMITIVES = fails(function() {
              instance.has(1);
            }),
            ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
              new NativeConstructor(iterable);
            }),
            BUGGY_ZERO =
              !IS_WEAK &&
              fails(function() {
                for (
                  var $instance = new NativeConstructor(), index = 5;
                  index--;

                )
                  $instance[ADDER](index, index);
                return !$instance.has(-0);
              });
          ACCEPT_ITERABLES ||
            (((Constructor = wrapper(function(dummy, iterable) {
              anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
              var that = inheritIfRequired(
                new NativeConstructor(),
                dummy,
                Constructor
              );
              return (
                null != iterable &&
                  iterate(iterable, that[ADDER], that, IS_MAP),
                that
              );
            })).prototype = NativePrototype),
            (NativePrototype.constructor = Constructor)),
            (THROWS_ON_PRIMITIVES || BUGGY_ZERO) &&
              (fixMethod('delete'),
              fixMethod('has'),
              IS_MAP && fixMethod('get')),
            (BUGGY_ZERO || HASNT_CHAINING) && fixMethod(ADDER),
            IS_WEAK && NativePrototype.clear && delete NativePrototype.clear;
        }
        return (
          (exported[CONSTRUCTOR_NAME] = Constructor),
          $({ global: !0, forced: Constructor != NativeConstructor }, exported),
          setToStringTag(Constructor, CONSTRUCTOR_NAME),
          IS_WEAK || common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP),
          Constructor
        );
      };
    },
    busE: function(module, exports, __webpack_require__) {
      var global = __webpack_require__('2oRo'),
        shared = __webpack_require__('VpIT'),
        hide = __webpack_require__('X2U+'),
        has = __webpack_require__('UTVS'),
        setGlobal = __webpack_require__('zk60'),
        nativeFunctionToString = __webpack_require__('noGo'),
        InternalStateModule = __webpack_require__('afO8'),
        getInternalState = InternalStateModule.get,
        enforceInternalState = InternalStateModule.enforce,
        TEMPLATE = String(nativeFunctionToString).split('toString');
      shared('inspectSource', function(it) {
        return nativeFunctionToString.call(it);
      }),
        (module.exports = function(O, key, value, options) {
          var unsafe = !!options && !!options.unsafe,
            simple = !!options && !!options.enumerable,
            noTargetGet = !!options && !!options.noTargetGet;
          'function' == typeof value &&
            ('string' != typeof key ||
              has(value, 'name') ||
              hide(value, 'name', key),
            (enforceInternalState(value).source = TEMPLATE.join(
              'string' == typeof key ? key : ''
            ))),
            O !== global
              ? (unsafe
                  ? !noTargetGet && O[key] && (simple = !0)
                  : delete O[key],
                simple ? (O[key] = value) : hide(O, key, value))
              : simple
              ? (O[key] = value)
              : setGlobal(key, value);
        })(Function.prototype, 'toString', function() {
          return (
            ('function' == typeof this && getInternalState(this).source) ||
            nativeFunctionToString.call(this)
          );
        });
    },
    c2HN: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function isPromise(value) {
        return (
          !!value &&
          'function' != typeof value.subscribe &&
          'function' == typeof value.then
        );
      }
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return isPromise;
      });
    },
    cVYH: function(module, exports, __webpack_require__) {
      var isObject = __webpack_require__('hh1v'),
        setPrototypeOf = __webpack_require__('0rvr');
      module.exports = function($this, dummy, Wrapper) {
        var NewTarget, NewTargetPrototype;
        return (
          setPrototypeOf &&
            'function' == typeof (NewTarget = dummy.constructor) &&
            NewTarget !== Wrapper &&
            isObject((NewTargetPrototype = NewTarget.prototype)) &&
            NewTargetPrototype !== Wrapper.prototype &&
            setPrototypeOf($this, NewTargetPrototype),
          $this
        );
      };
    },
    'dBg+': function(module, exports) {
      exports.f = Object.getOwnPropertySymbols;
    },
    'eDl+': function(module, exports) {
      module.exports = [
        'constructor',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'toLocaleString',
        'toString',
        'valueOf'
      ];
    },
    eIep: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return switchMap;
      });
      var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'l7GE'
        ),
        _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          '51Dv'
        ),
        _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'ZUHj'
        ),
        _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__('lJxs'),
        _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          'Cfvw'
        );
      function switchMap(project, resultSelector) {
        return 'function' == typeof resultSelector
          ? source =>
              source.pipe(
                switchMap((a, i) =>
                  Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__.a)(
                    project(a, i)
                  ).pipe(
                    Object(_map__WEBPACK_IMPORTED_MODULE_3__.a)((b, ii) =>
                      resultSelector(a, b, i, ii)
                    )
                  )
                )
              )
          : source => source.lift(new SwitchMapOperator(project));
      }
      class SwitchMapOperator {
        constructor(project) {
          this.project = project;
        }
        call(subscriber, source) {
          return source.subscribe(
            new SwitchMapSubscriber(subscriber, this.project)
          );
        }
      }
      class SwitchMapSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(destination, project) {
          super(destination), (this.project = project), (this.index = 0);
        }
        _next(value) {
          let result;
          const index = this.index++;
          try {
            result = this.project(value, index);
          } catch (error) {
            return void this.destination.error(error);
          }
          this._innerSub(result, value, index);
        }
        _innerSub(result, value, index) {
          const innerSubscription = this.innerSubscription;
          innerSubscription && innerSubscription.unsubscribe();
          const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__.a(
            this,
            void 0,
            void 0
          );
          this.destination.add(innerSubscriber),
            (this.innerSubscription = Object(
              _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__.a
            )(this, result, value, index, innerSubscriber));
        }
        _complete() {
          const { innerSubscription: innerSubscription } = this;
          (innerSubscription && !innerSubscription.closed) || super._complete(),
            this.unsubscribe();
        }
        _unsubscribe() {
          this.innerSubscription = null;
        }
        notifyComplete(innerSub) {
          this.destination.remove(innerSub),
            (this.innerSubscription = null),
            this.isStopped && super._complete();
        }
        notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(innerValue);
        }
      }
    },
    ewvW: function(module, exports, __webpack_require__) {
      var requireObjectCoercible = __webpack_require__('HYAF');
      module.exports = function(argument) {
        return Object(requireObjectCoercible(argument));
      };
    },
    ey9i: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'c', function() {
        return i18n_service.b;
      }),
        __webpack_require__.d(__webpack_exports__, 'a', function() {
          return i18n_service.a;
        }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return logger_service.a;
        }),
        __webpack_require__.d(__webpack_exports__, 'd', function() {
          return untilDestroyed;
        }),
        __webpack_require__('ofXK'),
        __webpack_require__('tk/3');
      var fesm2015_router = __webpack_require__('tyNb'),
        core = (__webpack_require__('sYmb'), __webpack_require__('fXoL'));
      let route_reusable_strategy_RouteReusableStrategy = (() => {
        class RouteReusableStrategy extends fesm2015_router.d {
          shouldDetach(route) {
            return !1;
          }
          store(route, detachedTree) {}
          shouldAttach(route) {
            return !1;
          }
          retrieve(route) {
            return null;
          }
          shouldReuseRoute(future, curr) {
            return future.routeConfig === curr.routeConfig || future.data.reuse;
          }
        }
        return (
          (RouteReusableStrategy.ɵfac = function(t) {
            return ɵRouteReusableStrategy_BaseFactory(
              t || RouteReusableStrategy
            );
          }),
          (RouteReusableStrategy.ɵprov = core.Hb({
            token: RouteReusableStrategy,
            factory: RouteReusableStrategy.ɵfac
          })),
          RouteReusableStrategy
        );
      })();
      const ɵRouteReusableStrategy_BaseFactory = core.Sb(
        route_reusable_strategy_RouteReusableStrategy
      );
      __webpack_require__('JIr8'), __webpack_require__('AytR');
      var logger_service = __webpack_require__('fSl4');
      new logger_service.a('ErrorHandlerInterceptor'),
        __webpack_require__('HDdC'),
        new logger_service.a('HttpCacheService'),
        new core.q('HTTP_DYNAMIC_INTERCEPTORS'),
        __webpack_require__('LRne'),
        new logger_service.a('AuthenticationGuard');
      var i18n_service = __webpack_require__('4WJ2');
      __webpack_require__('jhN1');
      var Subject = __webpack_require__('XNiG'),
        takeUntil = __webpack_require__('1G5W');
      const untilDestroyedSymbol = Symbol('untilDestroyed');
      function untilDestroyed(instance, destroyMethodName = 'ngOnDestroy') {
        return source => {
          const originalDestroy = instance[destroyMethodName],
            hasDestroyFunction = 'function' == typeof originalDestroy;
          if (!hasDestroyFunction)
            throw new Error(
              `${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`
            );
          return (
            instance[untilDestroyedSymbol] ||
              ((instance[untilDestroyedSymbol] = new Subject.a()),
              (instance[destroyMethodName] = function() {
                hasDestroyFunction && originalDestroy.apply(this, arguments),
                  instance[untilDestroyedSymbol].next(),
                  instance[untilDestroyedSymbol].complete();
              })),
            source.pipe(Object(takeUntil.a)(instance[untilDestroyedSymbol]))
          );
        };
      }
    },
    f5p1: function(module, exports, __webpack_require__) {
      var global = __webpack_require__('2oRo'),
        nativeFunctionToString = __webpack_require__('noGo'),
        WeakMap = global.WeakMap;
      module.exports =
        'function' == typeof WeakMap &&
        /native code/.test(nativeFunctionToString.call(WeakMap));
    },
    fHMY: function(module, exports, __webpack_require__) {
      var anObject = __webpack_require__('glrk'),
        defineProperties = __webpack_require__('N+g0'),
        enumBugKeys = __webpack_require__('eDl+'),
        hiddenKeys = __webpack_require__('0BK2'),
        html = __webpack_require__('G+Rx'),
        documentCreateElement = __webpack_require__('zBJ4'),
        IE_PROTO = __webpack_require__('93I0')('IE_PROTO'),
        Empty = function() {},
        createDict = function() {
          var iframeDocument,
            iframe = documentCreateElement('iframe'),
            length = enumBugKeys.length;
          for (
            iframe.style.display = 'none',
              html.appendChild(iframe),
              iframe.src = String('javascript:'),
              (iframeDocument = iframe.contentWindow.document).open(),
              iframeDocument.write('<script>document.F=Object</script>'),
              iframeDocument.close(),
              createDict = iframeDocument.F;
            length--;

          )
            delete createDict.prototype[enumBugKeys[length]];
          return createDict();
        };
      (module.exports =
        Object.create ||
        function(O, Properties) {
          var result;
          return (
            null !== O
              ? ((Empty.prototype = anObject(O)),
                (result = new Empty()),
                (Empty.prototype = null),
                (result[IE_PROTO] = O))
              : (result = createDict()),
            void 0 === Properties
              ? result
              : defineProperties(result, Properties)
          );
        }),
        (hiddenKeys[IE_PROTO] = !0);
    },
    fSl4: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return Logger;
      });
      var LogLevel = (function(LogLevel) {
        return (
          (LogLevel[(LogLevel.Off = 0)] = 'Off'),
          (LogLevel[(LogLevel.Error = 1)] = 'Error'),
          (LogLevel[(LogLevel.Warning = 2)] = 'Warning'),
          (LogLevel[(LogLevel.Info = 3)] = 'Info'),
          (LogLevel[(LogLevel.Debug = 4)] = 'Debug'),
          LogLevel
        );
      })({});
      let Logger = (() => {
        class Logger {
          constructor(source) {
            this.source = source;
          }
          static enableProductionMode() {
            Logger.level = LogLevel.Warning;
          }
          debug(...objects) {
            this.log(console.log, LogLevel.Debug, objects);
          }
          info(...objects) {
            this.log(console.info, LogLevel.Info, objects);
          }
          warn(...objects) {
            this.log(console.warn, LogLevel.Warning, objects);
          }
          error(...objects) {
            this.log(console.error, LogLevel.Error, objects);
          }
          log(func, level, objects) {
            if (level <= Logger.level) {
              const log = this.source
                ? ['[' + this.source + ']'].concat(objects)
                : objects;
              func.apply(console, log),
                Logger.outputs.forEach(output =>
                  output.apply(output, [this.source, level, ...objects])
                );
            }
          }
        }
        return (Logger.level = LogLevel.Debug), (Logger.outputs = []), Logger;
      })();
    },
    fXoL: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return ANALYZE_FOR_ENTRY_COMPONENTS;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return APP_BOOTSTRAP_LISTENER;
        }),
        __webpack_require__.d(__webpack_exports__, 'c', function() {
          return APP_ID;
        }),
        __webpack_require__.d(__webpack_exports__, 'd', function() {
          return APP_INITIALIZER;
        }),
        __webpack_require__.d(__webpack_exports__, 'e', function() {
          return ApplicationInitStatus;
        }),
        __webpack_require__.d(__webpack_exports__, 'f', function() {
          return ApplicationModule;
        }),
        __webpack_require__.d(__webpack_exports__, 'g', function() {
          return ApplicationRef;
        }),
        __webpack_require__.d(__webpack_exports__, 'h', function() {
          return ChangeDetectorRef;
        }),
        __webpack_require__.d(__webpack_exports__, 'i', function() {
          return Compiler;
        }),
        __webpack_require__.d(__webpack_exports__, 'j', function() {
          return ComponentFactoryResolver;
        }),
        __webpack_require__.d(__webpack_exports__, 'k', function() {
          return DEFAULT_CURRENCY_CODE;
        }),
        __webpack_require__.d(__webpack_exports__, 'l', function() {
          return ElementRef;
        }),
        __webpack_require__.d(__webpack_exports__, 'm', function() {
          return ErrorHandler;
        }),
        __webpack_require__.d(__webpack_exports__, 'n', function() {
          return EventEmitter;
        }),
        __webpack_require__.d(__webpack_exports__, 'o', function() {
          return INJECTOR;
        }),
        __webpack_require__.d(__webpack_exports__, 'p', function() {
          return Inject;
        }),
        __webpack_require__.d(__webpack_exports__, 'q', function() {
          return InjectionToken;
        }),
        __webpack_require__.d(__webpack_exports__, 'r', function() {
          return Injector;
        }),
        __webpack_require__.d(__webpack_exports__, 's', function() {
          return IterableDiffers;
        }),
        __webpack_require__.d(__webpack_exports__, 't', function() {
          return KeyValueDiffers;
        }),
        __webpack_require__.d(__webpack_exports__, 'u', function() {
          return LOCALE_ID$1;
        }),
        __webpack_require__.d(__webpack_exports__, 'v', function() {
          return NgModuleFactory;
        }),
        __webpack_require__.d(__webpack_exports__, 'w', function() {
          return NgModuleFactoryLoader;
        }),
        __webpack_require__.d(__webpack_exports__, 'x', function() {
          return NgModuleRef;
        }),
        __webpack_require__.d(__webpack_exports__, 'y', function() {
          return NgProbeToken;
        }),
        __webpack_require__.d(__webpack_exports__, 'z', function() {
          return NgZone;
        }),
        __webpack_require__.d(__webpack_exports__, 'A', function() {
          return Optional;
        }),
        __webpack_require__.d(__webpack_exports__, 'B', function() {
          return PLATFORM_ID;
        }),
        __webpack_require__.d(__webpack_exports__, 'C', function() {
          return PLATFORM_INITIALIZER;
        }),
        __webpack_require__.d(__webpack_exports__, 'D', function() {
          return Renderer2;
        }),
        __webpack_require__.d(__webpack_exports__, 'E', function() {
          return RendererFactory2;
        }),
        __webpack_require__.d(__webpack_exports__, 'F', function() {
          return RendererStyleFlags2;
        }),
        __webpack_require__.d(__webpack_exports__, 'G', function() {
          return Sanitizer;
        }),
        __webpack_require__.d(__webpack_exports__, 'H', function() {
          return SecurityContext;
        }),
        __webpack_require__.d(__webpack_exports__, 'I', function() {
          return SkipSelf;
        }),
        __webpack_require__.d(__webpack_exports__, 'J', function() {
          return SystemJsNgModuleLoader;
        }),
        __webpack_require__.d(__webpack_exports__, 'K', function() {
          return TemplateRef;
        }),
        __webpack_require__.d(__webpack_exports__, 'L', function() {
          return Testability;
        }),
        __webpack_require__.d(__webpack_exports__, 'M', function() {
          return Type;
        }),
        __webpack_require__.d(__webpack_exports__, 'N', function() {
          return Version;
        }),
        __webpack_require__.d(__webpack_exports__, 'O', function() {
          return ViewContainerRef;
        }),
        __webpack_require__.d(__webpack_exports__, 'P', function() {
          return ViewEncapsulation$1;
        }),
        __webpack_require__.d(__webpack_exports__, 'Q', function() {
          return createPlatformFactory;
        }),
        __webpack_require__.d(__webpack_exports__, 'R', function() {
          return enableProdMode;
        }),
        __webpack_require__.d(__webpack_exports__, 'S', function() {
          return forwardRef;
        }),
        __webpack_require__.d(__webpack_exports__, 'T', function() {
          return isDevMode;
        }),
        __webpack_require__.d(__webpack_exports__, 'U', function() {
          return platformCore;
        }),
        __webpack_require__.d(__webpack_exports__, 'V', function() {
          return setTestabilityGetter;
        }),
        __webpack_require__.d(__webpack_exports__, 'W', function() {
          return Console;
        }),
        __webpack_require__.d(__webpack_exports__, 'X', function() {
          return INJECTOR_SCOPE;
        }),
        __webpack_require__.d(__webpack_exports__, 'Y', function() {
          return LocaleDataIndex;
        }),
        __webpack_require__.d(__webpack_exports__, 'Z', function() {
          return _sanitizeHtml;
        }),
        __webpack_require__.d(__webpack_exports__, 'ab', function() {
          return _sanitizeUrl;
        }),
        __webpack_require__.d(__webpack_exports__, 'bb', function() {
          return allowSanitizationBypassAndThrow;
        }),
        __webpack_require__.d(__webpack_exports__, 'cb', function() {
          return bypassSanitizationTrustHtml;
        }),
        __webpack_require__.d(__webpack_exports__, 'db', function() {
          return bypassSanitizationTrustResourceUrl;
        }),
        __webpack_require__.d(__webpack_exports__, 'eb', function() {
          return bypassSanitizationTrustScript;
        }),
        __webpack_require__.d(__webpack_exports__, 'fb', function() {
          return bypassSanitizationTrustStyle;
        }),
        __webpack_require__.d(__webpack_exports__, 'gb', function() {
          return bypassSanitizationTrustUrl;
        }),
        __webpack_require__.d(__webpack_exports__, 'hb', function() {
          return findLocaleData;
        }),
        __webpack_require__.d(__webpack_exports__, 'ib', function() {
          return getDebugNodeR2;
        }),
        __webpack_require__.d(__webpack_exports__, 'jb', function() {
          return getLocaleCurrencyCode;
        }),
        __webpack_require__.d(__webpack_exports__, 'kb', function() {
          return getLocalePluralCase;
        }),
        __webpack_require__.d(__webpack_exports__, 'lb', function() {
          return getSanitizationBypassType;
        }),
        __webpack_require__.d(__webpack_exports__, 'mb', function() {
          return _global;
        }),
        __webpack_require__.d(__webpack_exports__, 'nb', function() {
          return isListLikeIterable;
        }),
        __webpack_require__.d(__webpack_exports__, 'ob', function() {
          return isObservable;
        }),
        __webpack_require__.d(__webpack_exports__, 'pb', function() {
          return isPromise;
        }),
        __webpack_require__.d(__webpack_exports__, 'qb', function() {
          return registerLocaleData;
        }),
        __webpack_require__.d(__webpack_exports__, 'rb', function() {
          return setDocument;
        }),
        __webpack_require__.d(__webpack_exports__, 'sb', function() {
          return stringify;
        }),
        __webpack_require__.d(__webpack_exports__, 'tb', function() {
          return unwrapSafeValue;
        }),
        __webpack_require__.d(__webpack_exports__, 'ub', function() {
          return ɵɵInheritDefinitionFeature;
        }),
        __webpack_require__.d(__webpack_exports__, 'vb', function() {
          return ɵɵNgOnChangesFeature;
        }),
        __webpack_require__.d(__webpack_exports__, 'wb', function() {
          return ɵɵProvidersFeature;
        }),
        __webpack_require__.d(__webpack_exports__, 'xb', function() {
          return ɵɵadvance;
        }),
        __webpack_require__.d(__webpack_exports__, 'yb', function() {
          return ɵɵattribute;
        }),
        __webpack_require__.d(__webpack_exports__, 'zb', function() {
          return ɵɵclassMap;
        }),
        __webpack_require__.d(__webpack_exports__, 'Ab', function() {
          return ɵɵclassMapInterpolate1;
        }),
        __webpack_require__.d(__webpack_exports__, 'Bb', function() {
          return ɵɵclassMapInterpolate2;
        }),
        __webpack_require__.d(__webpack_exports__, 'Cb', function() {
          return ɵɵclassMapInterpolate3;
        }),
        __webpack_require__.d(__webpack_exports__, 'Db', function() {
          return ɵɵclassProp;
        }),
        __webpack_require__.d(__webpack_exports__, 'Eb', function() {
          return ɵɵcontentQuery;
        }),
        __webpack_require__.d(__webpack_exports__, 'Fb', function() {
          return ɵɵdefineComponent;
        }),
        __webpack_require__.d(__webpack_exports__, 'Gb', function() {
          return ɵɵdefineDirective;
        }),
        __webpack_require__.d(__webpack_exports__, 'Hb', function() {
          return ɵɵdefineInjectable;
        }),
        __webpack_require__.d(__webpack_exports__, 'Ib', function() {
          return ɵɵdefineInjector;
        }),
        __webpack_require__.d(__webpack_exports__, 'Jb', function() {
          return ɵɵdefineNgModule;
        }),
        __webpack_require__.d(__webpack_exports__, 'Kb', function() {
          return ɵɵdefinePipe;
        }),
        __webpack_require__.d(__webpack_exports__, 'Lb', function() {
          return ɵɵdirectiveInject;
        }),
        __webpack_require__.d(__webpack_exports__, 'Mb', function() {
          return ɵɵelement;
        }),
        __webpack_require__.d(__webpack_exports__, 'Nb', function() {
          return ɵɵelementContainerEnd;
        }),
        __webpack_require__.d(__webpack_exports__, 'Ob', function() {
          return ɵɵelementContainerStart;
        }),
        __webpack_require__.d(__webpack_exports__, 'Pb', function() {
          return ɵɵelementEnd;
        }),
        __webpack_require__.d(__webpack_exports__, 'Qb', function() {
          return ɵɵelementStart;
        }),
        __webpack_require__.d(__webpack_exports__, 'Rb', function() {
          return ɵɵgetCurrentView;
        }),
        __webpack_require__.d(__webpack_exports__, 'Sb', function() {
          return ɵɵgetInheritedFactory;
        }),
        __webpack_require__.d(__webpack_exports__, 'Tb', function() {
          return ɵɵhostProperty;
        }),
        __webpack_require__.d(__webpack_exports__, 'Ub', function() {
          return ɵɵi18n;
        }),
        __webpack_require__.d(__webpack_exports__, 'Vb', function() {
          return ɵɵi18nApply;
        }),
        __webpack_require__.d(__webpack_exports__, 'Wb', function() {
          return ɵɵi18nAttributes;
        }),
        __webpack_require__.d(__webpack_exports__, 'Xb', function() {
          return ɵɵi18nExp;
        }),
        __webpack_require__.d(__webpack_exports__, 'Yb', function() {
          return ɵɵinject;
        }),
        __webpack_require__.d(__webpack_exports__, 'Zb', function() {
          return ɵɵinjectAttribute;
        }),
        __webpack_require__.d(__webpack_exports__, 'ac', function() {
          return ɵɵinjectPipeChangeDetectorRef;
        }),
        __webpack_require__.d(__webpack_exports__, 'bc', function() {
          return ɵɵlistener;
        }),
        __webpack_require__.d(__webpack_exports__, 'cc', function() {
          return ɵɵloadQuery;
        }),
        __webpack_require__.d(__webpack_exports__, 'dc', function() {
          return ɵɵnamespaceHTML;
        }),
        __webpack_require__.d(__webpack_exports__, 'ec', function() {
          return ɵɵnamespaceSVG;
        }),
        __webpack_require__.d(__webpack_exports__, 'fc', function() {
          return ɵɵnextContext;
        }),
        __webpack_require__.d(__webpack_exports__, 'gc', function() {
          return ɵɵpipe;
        }),
        __webpack_require__.d(__webpack_exports__, 'hc', function() {
          return ɵɵpipeBind1;
        }),
        __webpack_require__.d(__webpack_exports__, 'ic', function() {
          return ɵɵprojection;
        }),
        __webpack_require__.d(__webpack_exports__, 'jc', function() {
          return ɵɵprojectionDef;
        }),
        __webpack_require__.d(__webpack_exports__, 'kc', function() {
          return ɵɵproperty;
        }),
        __webpack_require__.d(__webpack_exports__, 'lc', function() {
          return ɵɵpropertyInterpolate;
        }),
        __webpack_require__.d(__webpack_exports__, 'mc', function() {
          return ɵɵpropertyInterpolate1;
        }),
        __webpack_require__.d(__webpack_exports__, 'nc', function() {
          return ɵɵpureFunction0;
        }),
        __webpack_require__.d(__webpack_exports__, 'oc', function() {
          return ɵɵpureFunction1;
        }),
        __webpack_require__.d(__webpack_exports__, 'pc', function() {
          return ɵɵpureFunction2;
        }),
        __webpack_require__.d(__webpack_exports__, 'qc', function() {
          return ɵɵpureFunction3;
        }),
        __webpack_require__.d(__webpack_exports__, 'rc', function() {
          return ɵɵpureFunction4;
        }),
        __webpack_require__.d(__webpack_exports__, 'sc', function() {
          return ɵɵqueryRefresh;
        }),
        __webpack_require__.d(__webpack_exports__, 'tc', function() {
          return ɵɵreference;
        }),
        __webpack_require__.d(__webpack_exports__, 'uc', function() {
          return ɵɵresolveWindow;
        }),
        __webpack_require__.d(__webpack_exports__, 'vc', function() {
          return ɵɵrestoreView;
        }),
        __webpack_require__.d(__webpack_exports__, 'wc', function() {
          return ɵɵsanitizeHtml;
        }),
        __webpack_require__.d(__webpack_exports__, 'xc', function() {
          return ɵɵsanitizeResourceUrl;
        }),
        __webpack_require__.d(__webpack_exports__, 'yc', function() {
          return ɵɵsanitizeUrl;
        }),
        __webpack_require__.d(__webpack_exports__, 'zc', function() {
          return ɵɵsetNgModuleScope;
        }),
        __webpack_require__.d(__webpack_exports__, 'Ac', function() {
          return ɵɵstaticContentQuery;
        }),
        __webpack_require__.d(__webpack_exports__, 'Bc', function() {
          return ɵɵstaticViewQuery;
        }),
        __webpack_require__.d(__webpack_exports__, 'Cc', function() {
          return ɵɵstyleProp;
        }),
        __webpack_require__.d(__webpack_exports__, 'Dc', function() {
          return ɵɵtemplate;
        }),
        __webpack_require__.d(__webpack_exports__, 'Ec', function() {
          return ɵɵtemplateRefExtractor;
        }),
        __webpack_require__.d(__webpack_exports__, 'Fc', function() {
          return ɵɵtext;
        }),
        __webpack_require__.d(__webpack_exports__, 'Gc', function() {
          return ɵɵtextInterpolate;
        }),
        __webpack_require__.d(__webpack_exports__, 'Hc', function() {
          return ɵɵtextInterpolate1;
        }),
        __webpack_require__.d(__webpack_exports__, 'Ic', function() {
          return ɵɵtextInterpolate2;
        }),
        __webpack_require__.d(__webpack_exports__, 'Jc', function() {
          return ɵɵviewQuery;
        });
      var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__('XNiG'),
        rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__('quSY'),
        rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__('HDdC'),
        rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__('VRyK'),
        rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          'w1tV'
        );
      function noSideEffects(fn) {
        return { toString: fn }.toString();
      }
      function makeParamDecorator(name, props, parentClass) {
        return noSideEffects(() => {
          const metaCtor = (function(props) {
            return function(...args) {
              if (props) {
                const values = props(...args);
                for (const propName in values)
                  this[propName] = values[propName];
              }
            };
          })(props);
          function ParamDecoratorFactory(...args) {
            if (this instanceof ParamDecoratorFactory)
              return metaCtor.apply(this, args), this;
            const annotationInstance = new ParamDecoratorFactory(...args);
            return (
              (ParamDecorator.annotation = annotationInstance), ParamDecorator
            );
            function ParamDecorator(cls, unusedKey, index) {
              const parameters = cls.hasOwnProperty('__parameters__')
                ? cls.__parameters__
                : Object.defineProperty(cls, '__parameters__', { value: [] })
                    .__parameters__;
              for (; parameters.length <= index; ) parameters.push(null);
              return (
                (parameters[index] = parameters[index] || []).push(
                  annotationInstance
                ),
                cls
              );
            }
          }
          return (
            parentClass &&
              (ParamDecoratorFactory.prototype = Object.create(
                parentClass.prototype
              )),
            (ParamDecoratorFactory.prototype.ngMetadataName = name),
            (ParamDecoratorFactory.annotationCls = ParamDecoratorFactory),
            ParamDecoratorFactory
          );
        });
      }
      const Inject = makeParamDecorator('Inject', token => ({ token: token })),
        Optional = makeParamDecorator('Optional'),
        Self = makeParamDecorator('Self'),
        SkipSelf = makeParamDecorator('SkipSelf');
      var InjectFlags = (function(InjectFlags) {
        return (
          (InjectFlags[(InjectFlags.Default = 0)] = 'Default'),
          (InjectFlags[(InjectFlags.Host = 1)] = 'Host'),
          (InjectFlags[(InjectFlags.Self = 2)] = 'Self'),
          (InjectFlags[(InjectFlags.SkipSelf = 4)] = 'SkipSelf'),
          (InjectFlags[(InjectFlags.Optional = 8)] = 'Optional'),
          InjectFlags
        );
      })({});
      function getClosureSafeProperty(objWithPropertyToExtract) {
        for (let key in objWithPropertyToExtract)
          if (objWithPropertyToExtract[key] === getClosureSafeProperty)
            return key;
        throw Error('Could not find renamed property on target object.');
      }
      function fillProperties(target, source) {
        for (const key in source)
          source.hasOwnProperty(key) &&
            !target.hasOwnProperty(key) &&
            (target[key] = source[key]);
      }
      function ɵɵdefineInjectable(opts) {
        return {
          token: opts.token,
          providedIn: opts.providedIn || null,
          factory: opts.factory,
          value: void 0
        };
      }
      function ɵɵdefineInjector(options) {
        return {
          factory: options.factory,
          providers: options.providers || [],
          imports: options.imports || []
        };
      }
      function getInjectableDef(type) {
        return (
          getOwnDefinition(type, type[NG_PROV_DEF]) ||
          getOwnDefinition(type, type[NG_INJECTABLE_DEF])
        );
      }
      function getOwnDefinition(type, def) {
        return def && def.token === type ? def : null;
      }
      function getInjectorDef(type) {
        return type &&
          (type.hasOwnProperty(NG_INJ_DEF) ||
            type.hasOwnProperty(NG_INJECTOR_DEF))
          ? type[NG_INJ_DEF]
          : null;
      }
      const NG_PROV_DEF = getClosureSafeProperty({
          ɵprov: getClosureSafeProperty
        }),
        NG_INJ_DEF = getClosureSafeProperty({ ɵinj: getClosureSafeProperty }),
        NG_PROV_DEF_FALLBACK = getClosureSafeProperty({
          ɵprovFallback: getClosureSafeProperty
        }),
        NG_INJECTABLE_DEF = getClosureSafeProperty({
          ngInjectableDef: getClosureSafeProperty
        }),
        NG_INJECTOR_DEF = getClosureSafeProperty({
          ngInjectorDef: getClosureSafeProperty
        });
      function stringify(token) {
        if ('string' == typeof token) return token;
        if (Array.isArray(token))
          return '[' + token.map(stringify).join(', ') + ']';
        if (null == token) return '' + token;
        if (token.overriddenName) return '' + token.overriddenName;
        if (token.name) return '' + token.name;
        const res = token.toString();
        if (null == res) return '' + res;
        const newLineIndex = res.indexOf('\n');
        return -1 === newLineIndex ? res : res.substring(0, newLineIndex);
      }
      function concatStringsWithSpace(before, after) {
        return null == before || '' === before
          ? null === after
            ? ''
            : after
          : null == after || '' === after
          ? before
          : before + ' ' + after;
      }
      const __forward_ref__ = getClosureSafeProperty({
        __forward_ref__: getClosureSafeProperty
      });
      function forwardRef(forwardRefFn) {
        return (
          (forwardRefFn.__forward_ref__ = forwardRef),
          (forwardRefFn.toString = function() {
            return stringify(this());
          }),
          forwardRefFn
        );
      }
      function resolveForwardRef(type) {
        return isForwardRef(type) ? type() : type;
      }
      function isForwardRef(fn) {
        return (
          'function' == typeof fn &&
          fn.hasOwnProperty(__forward_ref__) &&
          fn.__forward_ref__ === forwardRef
        );
      }
      const __globalThis = 'undefined' != typeof globalThis && globalThis,
        __window = 'undefined' != typeof window && window,
        __self =
          'undefined' != typeof self &&
          'undefined' != typeof WorkerGlobalScope &&
          self instanceof WorkerGlobalScope &&
          self,
        __global = 'undefined' != typeof global && global,
        _global = __globalThis || __global || __window || __self,
        NG_COMP_DEF = getClosureSafeProperty({ ɵcmp: getClosureSafeProperty }),
        NG_DIR_DEF = getClosureSafeProperty({ ɵdir: getClosureSafeProperty }),
        NG_PIPE_DEF = getClosureSafeProperty({ ɵpipe: getClosureSafeProperty }),
        NG_MOD_DEF = getClosureSafeProperty({ ɵmod: getClosureSafeProperty }),
        NG_LOC_ID_DEF = getClosureSafeProperty({
          ɵloc: getClosureSafeProperty
        }),
        NG_FACTORY_DEF = getClosureSafeProperty({
          ɵfac: getClosureSafeProperty
        }),
        NG_ELEMENT_ID = getClosureSafeProperty({
          __NG_ELEMENT_ID__: getClosureSafeProperty
        });
      class InjectionToken {
        constructor(_desc, options) {
          (this._desc = _desc),
            (this.ngMetadataName = 'InjectionToken'),
            (this.ɵprov = void 0),
            'number' == typeof options
              ? (this.__NG_ELEMENT_ID__ = options)
              : void 0 !== options &&
                (this.ɵprov = ɵɵdefineInjectable({
                  token: this,
                  providedIn: options.providedIn || 'root',
                  factory: options.factory
                }));
        }
        toString() {
          return 'InjectionToken ' + this._desc;
        }
      }
      const INJECTOR = new InjectionToken('INJECTOR', -1),
        THROW_IF_NOT_FOUND = {},
        NEW_LINE = /\n/gm,
        USE_VALUE = getClosureSafeProperty({
          provide: String,
          useValue: getClosureSafeProperty
        });
      let _injectImplementation,
        _currentInjector = void 0;
      function setCurrentInjector(injector) {
        const former = _currentInjector;
        return (_currentInjector = injector), former;
      }
      function setInjectImplementation(impl) {
        const previous = _injectImplementation;
        return (_injectImplementation = impl), previous;
      }
      function injectInjectorOnly(token, flags = InjectFlags.Default) {
        if (void 0 === _currentInjector)
          throw new Error('inject() must be called from an injection context');
        return null === _currentInjector
          ? injectRootLimpMode(token, void 0, flags)
          : _currentInjector.get(
              token,
              flags & InjectFlags.Optional ? null : void 0,
              flags
            );
      }
      function ɵɵinject(token, flags = InjectFlags.Default) {
        return (_injectImplementation || injectInjectorOnly)(
          resolveForwardRef(token),
          flags
        );
      }
      function injectRootLimpMode(token, notFoundValue, flags) {
        const injectableDef = getInjectableDef(token);
        if (injectableDef && 'root' == injectableDef.providedIn)
          return void 0 === injectableDef.value
            ? (injectableDef.value = injectableDef.factory())
            : injectableDef.value;
        if (flags & InjectFlags.Optional) return null;
        if (void 0 !== notFoundValue) return notFoundValue;
        throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);
      }
      function injectArgs(types) {
        const args = [];
        for (let i = 0; i < types.length; i++) {
          const arg = resolveForwardRef(types[i]);
          if (Array.isArray(arg)) {
            if (0 === arg.length)
              throw new Error('Arguments array must have arguments.');
            let type = void 0,
              flags = InjectFlags.Default;
            for (let j = 0; j < arg.length; j++) {
              const meta = arg[j];
              meta instanceof Optional ||
              'Optional' === meta.ngMetadataName ||
              meta === Optional
                ? (flags |= InjectFlags.Optional)
                : meta instanceof SkipSelf ||
                  'SkipSelf' === meta.ngMetadataName ||
                  meta === SkipSelf
                ? (flags |= InjectFlags.SkipSelf)
                : meta instanceof Self ||
                  'Self' === meta.ngMetadataName ||
                  meta === Self
                ? (flags |= InjectFlags.Self)
                : (type =
                    meta instanceof Inject || meta === Inject
                      ? meta.token
                      : meta);
            }
            args.push(ɵɵinject(type, flags));
          } else args.push(ɵɵinject(arg));
        }
        return args;
      }
      class NullInjector {
        get(token, notFoundValue = THROW_IF_NOT_FOUND) {
          if (notFoundValue === THROW_IF_NOT_FOUND) {
            const error = new Error(
              `NullInjectorError: No provider for ${stringify(token)}!`
            );
            throw ((error.name = 'NullInjectorError'), error);
          }
          return notFoundValue;
        }
      }
      class NgModuleRef {}
      class NgModuleFactory {}
      function addAllToArray(items, arr) {
        for (let i = 0; i < items.length; i++) arr.push(items[i]);
      }
      function deepForEach(input, fn) {
        input.forEach(value =>
          Array.isArray(value) ? deepForEach(value, fn) : fn(value)
        );
      }
      function addToArray(arr, index, value) {
        index >= arr.length ? arr.push(value) : arr.splice(index, 0, value);
      }
      function removeFromArray(arr, index) {
        return index >= arr.length - 1 ? arr.pop() : arr.splice(index, 1)[0];
      }
      function newArray(size, value) {
        const list = [];
        for (let i = 0; i < size; i++) list.push(value);
        return list;
      }
      function keyValueArraySet(keyValueArray, key, value) {
        let index = keyValueArrayIndexOf(keyValueArray, key);
        return (
          index >= 0
            ? (keyValueArray[1 | index] = value)
            : ((index = ~index),
              (function(array, index, value1, value2) {
                let end = array.length;
                if (end == index) array.push(value1, value2);
                else if (1 === end)
                  array.push(value2, array[0]), (array[0] = value1);
                else {
                  for (
                    end--, array.push(array[end - 1], array[end]);
                    end > index;

                  )
                    (array[end] = array[end - 2]), end--;
                  (array[index] = value1), (array[index + 1] = value2);
                }
              })(keyValueArray, index, key, value)),
          index
        );
      }
      function keyValueArrayGet(keyValueArray, key) {
        const index = keyValueArrayIndexOf(keyValueArray, key);
        if (index >= 0) return keyValueArray[1 | index];
      }
      function keyValueArrayIndexOf(keyValueArray, key) {
        return (function(array, value, shift) {
          let start = 0,
            end = array.length >> 1;
          for (; end !== start; ) {
            const middle = start + ((end - start) >> 1),
              current = array[middle << 1];
            if (value === current) return middle << 1;
            current > value ? (end = middle) : (start = middle + 1);
          }
          return ~(end << 1);
        })(keyValueArray, key);
      }
      var ChangeDetectionStrategy = (function(ChangeDetectionStrategy) {
          return (
            (ChangeDetectionStrategy[(ChangeDetectionStrategy.OnPush = 0)] =
              'OnPush'),
            (ChangeDetectionStrategy[(ChangeDetectionStrategy.Default = 1)] =
              'Default'),
            ChangeDetectionStrategy
          );
        })({}),
        ViewEncapsulation$1 = (function(ViewEncapsulation) {
          return (
            (ViewEncapsulation[(ViewEncapsulation.Emulated = 0)] = 'Emulated'),
            (ViewEncapsulation[(ViewEncapsulation.Native = 1)] = 'Native'),
            (ViewEncapsulation[(ViewEncapsulation.None = 2)] = 'None'),
            (ViewEncapsulation[(ViewEncapsulation.ShadowDom = 3)] =
              'ShadowDom'),
            ViewEncapsulation
          );
        })({});
      const EMPTY_OBJ = {},
        EMPTY_ARRAY = [];
      let _renderCompCount = 0;
      function ɵɵdefineComponent(componentDefinition) {
        return noSideEffects(() => {
          const type = componentDefinition.type,
            typePrototype = type.prototype,
            declaredInputs = {},
            def = {
              type: type,
              providersResolver: null,
              decls: componentDefinition.decls,
              vars: componentDefinition.vars,
              factory: null,
              template: componentDefinition.template || null,
              consts: componentDefinition.consts || null,
              ngContentSelectors: componentDefinition.ngContentSelectors,
              hostBindings: componentDefinition.hostBindings || null,
              hostVars: componentDefinition.hostVars || 0,
              hostAttrs: componentDefinition.hostAttrs || null,
              contentQueries: componentDefinition.contentQueries || null,
              declaredInputs: declaredInputs,
              inputs: null,
              outputs: null,
              exportAs: componentDefinition.exportAs || null,
              onChanges: null,
              onInit: typePrototype.ngOnInit || null,
              doCheck: typePrototype.ngDoCheck || null,
              afterContentInit: typePrototype.ngAfterContentInit || null,
              afterContentChecked: typePrototype.ngAfterContentChecked || null,
              afterViewInit: typePrototype.ngAfterViewInit || null,
              afterViewChecked: typePrototype.ngAfterViewChecked || null,
              onDestroy: typePrototype.ngOnDestroy || null,
              onPush:
                componentDefinition.changeDetection ===
                ChangeDetectionStrategy.OnPush,
              directiveDefs: null,
              pipeDefs: null,
              selectors: componentDefinition.selectors || EMPTY_ARRAY,
              viewQuery: componentDefinition.viewQuery || null,
              features: componentDefinition.features || null,
              data: componentDefinition.data || {},
              encapsulation:
                componentDefinition.encapsulation ||
                ViewEncapsulation$1.Emulated,
              id: 'c',
              styles: componentDefinition.styles || EMPTY_ARRAY,
              _: null,
              setInput: null,
              schemas: componentDefinition.schemas || null,
              tView: null
            },
            directiveTypes = componentDefinition.directives,
            feature = componentDefinition.features,
            pipeTypes = componentDefinition.pipes;
          return (
            (def.id += _renderCompCount++),
            (def.inputs = invertObject(
              componentDefinition.inputs,
              declaredInputs
            )),
            (def.outputs = invertObject(componentDefinition.outputs)),
            feature && feature.forEach(fn => fn(def)),
            (def.directiveDefs = directiveTypes
              ? () =>
                  ('function' == typeof directiveTypes
                    ? directiveTypes()
                    : directiveTypes
                  ).map(extractDirectiveDef)
              : null),
            (def.pipeDefs = pipeTypes
              ? () =>
                  ('function' == typeof pipeTypes
                    ? pipeTypes()
                    : pipeTypes
                  ).map(extractPipeDef)
              : null),
            def
          );
        });
      }
      function extractDirectiveDef(type) {
        return (
          getComponentDef(type) ||
          (function(type) {
            return type[NG_DIR_DEF] || null;
          })(type)
        );
      }
      function extractPipeDef(type) {
        return (function(type) {
          return type[NG_PIPE_DEF] || null;
        })(type);
      }
      const autoRegisterModuleById = {};
      function ɵɵdefineNgModule(def) {
        const res = {
          type: def.type,
          bootstrap: def.bootstrap || EMPTY_ARRAY,
          declarations: def.declarations || EMPTY_ARRAY,
          imports: def.imports || EMPTY_ARRAY,
          exports: def.exports || EMPTY_ARRAY,
          transitiveCompileScopes: null,
          schemas: def.schemas || null,
          id: def.id || null
        };
        return (
          null != def.id &&
            noSideEffects(() => {
              autoRegisterModuleById[def.id] = def.type;
            }),
          res
        );
      }
      function ɵɵsetNgModuleScope(type, scope) {
        return noSideEffects(() => {
          const ngModuleDef = getNgModuleDef(type, !0);
          (ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY),
            (ngModuleDef.imports = scope.imports || EMPTY_ARRAY),
            (ngModuleDef.exports = scope.exports || EMPTY_ARRAY);
        });
      }
      function invertObject(obj, secondary) {
        if (null == obj) return EMPTY_OBJ;
        const newLookup = {};
        for (const minifiedKey in obj)
          if (obj.hasOwnProperty(minifiedKey)) {
            let publicName = obj[minifiedKey],
              declaredName = publicName;
            Array.isArray(publicName) &&
              ((declaredName = publicName[1]), (publicName = publicName[0])),
              (newLookup[publicName] = minifiedKey),
              secondary && (secondary[publicName] = declaredName);
          }
        return newLookup;
      }
      const ɵɵdefineDirective = ɵɵdefineComponent;
      function ɵɵdefinePipe(pipeDef) {
        return {
          type: pipeDef.type,
          name: pipeDef.name,
          factory: null,
          pure: !1 !== pipeDef.pure,
          onDestroy: pipeDef.type.prototype.ngOnDestroy || null
        };
      }
      function getComponentDef(type) {
        return type[NG_COMP_DEF] || null;
      }
      function getFactoryDef(type, throwNotFound) {
        return type.hasOwnProperty(NG_FACTORY_DEF)
          ? type[NG_FACTORY_DEF]
          : null;
      }
      function getNgModuleDef(type, throwNotFound) {
        const ngModuleDef = type[NG_MOD_DEF] || null;
        if (!ngModuleDef && !0 === throwNotFound)
          throw new Error(
            `Type ${stringify(type)} does not have 'ɵmod' property.`
          );
        return ngModuleDef;
      }
      function isLView(value) {
        return Array.isArray(value) && 'object' == typeof value[1];
      }
      function isLContainer(value) {
        return Array.isArray(value) && !0 === value[1];
      }
      function isContentQueryHost(tNode) {
        return 0 != (8 & tNode.flags);
      }
      function isComponentHost(tNode) {
        return 2 == (2 & tNode.flags);
      }
      function isDirectiveHost(tNode) {
        return 1 == (1 & tNode.flags);
      }
      function isComponentDef(def) {
        return null !== def.template;
      }
      function isRootView(target) {
        return 0 != (512 & target[2]);
      }
      let DOCUMENT = void 0;
      function setDocument(document) {
        DOCUMENT = document;
      }
      function getDocument() {
        return void 0 !== DOCUMENT
          ? DOCUMENT
          : 'undefined' != typeof document
          ? document
          : void 0;
      }
      function isProceduralRenderer(renderer) {
        return !!renderer.listen;
      }
      const domRendererFactory3 = {
        createRenderer: (hostElement, rendererType) => getDocument()
      };
      function unwrapRNode(value) {
        for (; Array.isArray(value); ) value = value[0];
        return value;
      }
      function getNativeByIndex(index, lView) {
        return unwrapRNode(lView[index + 20]);
      }
      function getNativeByTNode(tNode, lView) {
        return unwrapRNode(lView[tNode.index]);
      }
      function getTNode(tView, index) {
        return tView.data[index + 20];
      }
      function load(view, index) {
        return view[index + 20];
      }
      function getComponentLViewByIndex(nodeIndex, hostView) {
        const slotValue = hostView[nodeIndex];
        return isLView(slotValue) ? slotValue : slotValue[0];
      }
      function readPatchedLView(target) {
        const value = (function(target) {
          return target.__ngContext__ || null;
        })(target);
        return value ? (Array.isArray(value) ? value : value.lView) : null;
      }
      function isCreationMode(view) {
        return 4 == (4 & view[2]);
      }
      function viewAttachedToChangeDetector(view) {
        return 128 == (128 & view[2]);
      }
      function getConstant(consts, index) {
        return null === consts || null == index ? null : consts[index];
      }
      function resetPreOrderHookFlags(lView) {
        lView[18] = 0;
      }
      function updateTransplantedViewCount(lContainer, amount) {
        lContainer[5] += amount;
        let viewOrContainer = lContainer,
          parent = lContainer[3];
        for (
          ;
          null !== parent &&
          ((1 === amount && 1 === viewOrContainer[5]) ||
            (-1 === amount && 0 === viewOrContainer[5]));

        )
          (parent[5] += amount),
            (viewOrContainer = parent),
            (parent = parent[3]);
      }
      const instructionState = {
        lFrame: createLFrame(null),
        bindingsEnabled: !0,
        checkNoChangesMode: !1
      };
      function getBindingsEnabled() {
        return instructionState.bindingsEnabled;
      }
      function getLView() {
        return instructionState.lFrame.lView;
      }
      function getTView() {
        return instructionState.lFrame.tView;
      }
      function ɵɵrestoreView(viewToRestore) {
        instructionState.lFrame.contextLView = viewToRestore;
      }
      function getPreviousOrParentTNode() {
        return instructionState.lFrame.previousOrParentTNode;
      }
      function setPreviousOrParentTNode(tNode, isParent) {
        (instructionState.lFrame.previousOrParentTNode = tNode),
          (instructionState.lFrame.isParent = isParent);
      }
      function getIsParent() {
        return instructionState.lFrame.isParent;
      }
      function setIsNotParent() {
        instructionState.lFrame.isParent = !1;
      }
      function getCheckNoChangesMode() {
        return instructionState.checkNoChangesMode;
      }
      function setCheckNoChangesMode(mode) {
        instructionState.checkNoChangesMode = mode;
      }
      function getBindingRoot() {
        const lFrame = instructionState.lFrame;
        let index = lFrame.bindingRootIndex;
        return (
          -1 === index &&
            (index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex),
          index
        );
      }
      function getBindingIndex() {
        return instructionState.lFrame.bindingIndex;
      }
      function nextBindingIndex() {
        return instructionState.lFrame.bindingIndex++;
      }
      function incrementBindingIndex(count) {
        const lFrame = instructionState.lFrame,
          index = lFrame.bindingIndex;
        return (lFrame.bindingIndex = lFrame.bindingIndex + count), index;
      }
      function setBindingRootForHostBindings(
        bindingRootIndex,
        currentDirectiveIndex
      ) {
        const lFrame = instructionState.lFrame;
        (lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex),
          setCurrentDirectiveIndex(currentDirectiveIndex);
      }
      function setCurrentDirectiveIndex(currentDirectiveIndex) {
        instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
      }
      function getCurrentQueryIndex() {
        return instructionState.lFrame.currentQueryIndex;
      }
      function setCurrentQueryIndex(value) {
        instructionState.lFrame.currentQueryIndex = value;
      }
      function enterDI(newView, tNode) {
        const newLFrame = allocLFrame();
        (instructionState.lFrame = newLFrame),
          (newLFrame.previousOrParentTNode = tNode),
          (newLFrame.lView = newView);
      }
      function enterView(newView, tNode) {
        const newLFrame = allocLFrame(),
          tView = newView[1];
        (instructionState.lFrame = newLFrame),
          (newLFrame.previousOrParentTNode = tNode),
          (newLFrame.lView = newView),
          (newLFrame.tView = tView),
          (newLFrame.contextLView = newView),
          (newLFrame.bindingIndex = tView.bindingStartIndex);
      }
      function allocLFrame() {
        const currentLFrame = instructionState.lFrame,
          childLFrame = null === currentLFrame ? null : currentLFrame.child;
        return null === childLFrame ? createLFrame(currentLFrame) : childLFrame;
      }
      function createLFrame(parent) {
        const lFrame = {
          previousOrParentTNode: null,
          isParent: !0,
          lView: null,
          tView: null,
          selectedIndex: 0,
          contextLView: null,
          elementDepthCount: 0,
          currentNamespace: null,
          currentDirectiveIndex: -1,
          bindingRootIndex: -1,
          bindingIndex: -1,
          currentQueryIndex: 0,
          parent: parent,
          child: null
        };
        return null !== parent && (parent.child = lFrame), lFrame;
      }
      function leaveViewLight() {
        const oldLFrame = instructionState.lFrame;
        return (
          (instructionState.lFrame = oldLFrame.parent),
          (oldLFrame.previousOrParentTNode = null),
          (oldLFrame.lView = null),
          oldLFrame
        );
      }
      const leaveDI = leaveViewLight;
      function leaveView() {
        const oldLFrame = leaveViewLight();
        (oldLFrame.isParent = !0),
          (oldLFrame.tView = null),
          (oldLFrame.selectedIndex = 0),
          (oldLFrame.contextLView = null),
          (oldLFrame.elementDepthCount = 0),
          (oldLFrame.currentDirectiveIndex = -1),
          (oldLFrame.currentNamespace = null),
          (oldLFrame.bindingRootIndex = -1),
          (oldLFrame.bindingIndex = -1),
          (oldLFrame.currentQueryIndex = 0);
      }
      function getSelectedIndex() {
        return instructionState.lFrame.selectedIndex;
      }
      function setSelectedIndex(index) {
        instructionState.lFrame.selectedIndex = index;
      }
      function getSelectedTNode() {
        const lFrame = instructionState.lFrame;
        return getTNode(lFrame.tView, lFrame.selectedIndex);
      }
      function ɵɵnamespaceSVG() {
        instructionState.lFrame.currentNamespace = 'http://www.w3.org/2000/svg';
      }
      function ɵɵnamespaceHTML() {
        instructionState.lFrame.currentNamespace = null;
      }
      function registerPostOrderHooks(tView, tNode) {
        for (
          let i = tNode.directiveStart, end = tNode.directiveEnd;
          i < end;
          i++
        ) {
          const directiveDef = tView.data[i];
          directiveDef.afterContentInit &&
            (tView.contentHooks || (tView.contentHooks = [])).push(
              -i,
              directiveDef.afterContentInit
            ),
            directiveDef.afterContentChecked &&
              ((tView.contentHooks || (tView.contentHooks = [])).push(
                i,
                directiveDef.afterContentChecked
              ),
              (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(
                i,
                directiveDef.afterContentChecked
              )),
            directiveDef.afterViewInit &&
              (tView.viewHooks || (tView.viewHooks = [])).push(
                -i,
                directiveDef.afterViewInit
              ),
            directiveDef.afterViewChecked &&
              ((tView.viewHooks || (tView.viewHooks = [])).push(
                i,
                directiveDef.afterViewChecked
              ),
              (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(
                i,
                directiveDef.afterViewChecked
              )),
            null != directiveDef.onDestroy &&
              (tView.destroyHooks || (tView.destroyHooks = [])).push(
                i,
                directiveDef.onDestroy
              );
        }
      }
      function executeCheckHooks(lView, hooks, nodeIndex) {
        callHooks(lView, hooks, 3, nodeIndex);
      }
      function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
        (3 & lView[2]) === initPhase &&
          callHooks(lView, hooks, initPhase, nodeIndex);
      }
      function incrementInitPhaseFlags(lView, initPhase) {
        let flags = lView[2];
        (3 & flags) === initPhase &&
          ((flags &= 2047), (flags += 1), (lView[2] = flags));
      }
      function callHooks(currentView, arr, initPhase, currentNodeIndex) {
        const nodeIndexLimit = null != currentNodeIndex ? currentNodeIndex : -1;
        let lastNodeIndexFound = 0;
        for (
          let i = void 0 !== currentNodeIndex ? 65535 & currentView[18] : 0;
          i < arr.length;
          i++
        )
          if ('number' == typeof arr[i + 1]) {
            if (
              ((lastNodeIndexFound = arr[i]),
              null != currentNodeIndex &&
                lastNodeIndexFound >= currentNodeIndex)
            )
              break;
          } else
            arr[i] < 0 && (currentView[18] += 65536),
              (lastNodeIndexFound < nodeIndexLimit || -1 == nodeIndexLimit) &&
                (callHook(currentView, initPhase, arr, i),
                (currentView[18] = (4294901760 & currentView[18]) + i + 2)),
              i++;
      }
      function callHook(currentView, initPhase, arr, i) {
        const isInitHook = arr[i] < 0,
          hook = arr[i + 1],
          directive = currentView[isInitHook ? -arr[i] : arr[i]];
        isInitHook
          ? currentView[2] >> 11 < currentView[18] >> 16 &&
            (3 & currentView[2]) === initPhase &&
            ((currentView[2] += 2048), hook.call(directive))
          : hook.call(directive);
      }
      class NodeInjectorFactory {
        constructor(factory, isViewProvider, injectImplementation) {
          (this.factory = factory),
            (this.resolving = !1),
            (this.canSeeViewProviders = isViewProvider),
            (this.injectImpl = injectImplementation);
        }
      }
      function setUpAttributes(renderer, native, attrs) {
        const isProc = isProceduralRenderer(renderer);
        let i = 0;
        for (; i < attrs.length; ) {
          const value = attrs[i];
          if ('number' == typeof value) {
            if (0 !== value) break;
            i++;
            const namespaceURI = attrs[i++],
              attrName = attrs[i++],
              attrVal = attrs[i++];
            isProc
              ? renderer.setAttribute(native, attrName, attrVal, namespaceURI)
              : native.setAttributeNS(namespaceURI, attrName, attrVal);
          } else {
            const attrName = value,
              attrVal = attrs[++i];
            isAnimationProp(attrName)
              ? isProc && renderer.setProperty(native, attrName, attrVal)
              : isProc
              ? renderer.setAttribute(native, attrName, attrVal)
              : native.setAttribute(attrName, attrVal),
              i++;
          }
        }
        return i;
      }
      function isNameOnlyAttributeMarker(marker) {
        return 3 === marker || 4 === marker || 6 === marker;
      }
      function isAnimationProp(name) {
        return 64 === name.charCodeAt(0);
      }
      function mergeHostAttrs(dst, src) {
        if (null === src || 0 === src.length);
        else if (null === dst || 0 === dst.length) dst = src.slice();
        else {
          let srcMarker = -1;
          for (let i = 0; i < src.length; i++) {
            const item = src[i];
            'number' == typeof item
              ? (srcMarker = item)
              : 0 === srcMarker ||
                mergeHostAttribute(
                  dst,
                  srcMarker,
                  item,
                  null,
                  -1 === srcMarker || 2 === srcMarker ? src[++i] : null
                );
          }
        }
        return dst;
      }
      function mergeHostAttribute(dst, marker, key1, key2, value) {
        let i = 0,
          markerInsertPosition = dst.length;
        if (-1 === marker) markerInsertPosition = -1;
        else
          for (; i < dst.length; ) {
            const dstValue = dst[i++];
            if ('number' == typeof dstValue) {
              if (dstValue === marker) {
                markerInsertPosition = -1;
                break;
              }
              if (dstValue > marker) {
                markerInsertPosition = i - 1;
                break;
              }
            }
          }
        for (; i < dst.length; ) {
          const item = dst[i];
          if ('number' == typeof item) break;
          if (item === key1) {
            if (null === key2)
              return void (null !== value && (dst[i + 1] = value));
            if (key2 === dst[i + 1]) return void (dst[i + 2] = value);
          }
          i++, null !== key2 && i++, null !== value && i++;
        }
        -1 !== markerInsertPosition &&
          (dst.splice(markerInsertPosition, 0, marker),
          (i = markerInsertPosition + 1)),
          dst.splice(i++, 0, key1),
          null !== key2 && dst.splice(i++, 0, key2),
          null !== value && dst.splice(i++, 0, value);
      }
      function hasParentInjector(parentLocation) {
        return -1 !== parentLocation;
      }
      function getParentInjectorIndex(parentLocation) {
        return 32767 & parentLocation;
      }
      function getParentInjectorViewOffset(parentLocation) {
        return parentLocation >> 16;
      }
      function getParentInjectorView(location, startView) {
        let viewOffset = getParentInjectorViewOffset(location),
          parentView = startView;
        for (; viewOffset > 0; ) (parentView = parentView[15]), viewOffset--;
        return parentView;
      }
      function renderStringify(value) {
        return 'string' == typeof value
          ? value
          : null == value
          ? ''
          : '' + value;
      }
      function stringifyForError(value) {
        return 'function' == typeof value
          ? value.name || value.toString()
          : 'object' == typeof value &&
            null != value &&
            'function' == typeof value.type
          ? value.type.name || value.type.toString()
          : renderStringify(value);
      }
      const defaultScheduler = (() =>
        (
          ('undefined' != typeof requestAnimationFrame &&
            requestAnimationFrame) ||
          setTimeout
        ).bind(_global))();
      function ɵɵresolveWindow(element) {
        return { name: 'window', target: element.ownerDocument.defaultView };
      }
      function maybeUnwrapFn(value) {
        return value instanceof Function ? value() : value;
      }
      let includeViewProviders = !0;
      function setIncludeViewProviders(v) {
        const oldValue = includeViewProviders;
        return (includeViewProviders = v), oldValue;
      }
      let nextNgElementId = 0;
      function getOrCreateNodeInjectorForNode(tNode, hostView) {
        const existingInjectorIndex = getInjectorIndex(tNode, hostView);
        if (-1 !== existingInjectorIndex) return existingInjectorIndex;
        const tView = hostView[1];
        tView.firstCreatePass &&
          ((tNode.injectorIndex = hostView.length),
          insertBloom(tView.data, tNode),
          insertBloom(hostView, null),
          insertBloom(tView.blueprint, null));
        const parentLoc = getParentInjectorLocation(tNode, hostView),
          injectorIndex = tNode.injectorIndex;
        if (hasParentInjector(parentLoc)) {
          const parentIndex = getParentInjectorIndex(parentLoc),
            parentLView = getParentInjectorView(parentLoc, hostView),
            parentData = parentLView[1].data;
          for (let i = 0; i < 8; i++)
            hostView[injectorIndex + i] =
              parentLView[parentIndex + i] | parentData[parentIndex + i];
        }
        return (hostView[injectorIndex + 8] = parentLoc), injectorIndex;
      }
      function insertBloom(arr, footer) {
        arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
      }
      function getInjectorIndex(tNode, hostView) {
        return -1 === tNode.injectorIndex ||
          (tNode.parent &&
            tNode.parent.injectorIndex === tNode.injectorIndex) ||
          null == hostView[tNode.injectorIndex + 8]
          ? -1
          : tNode.injectorIndex;
      }
      function getParentInjectorLocation(tNode, view) {
        if (tNode.parent && -1 !== tNode.parent.injectorIndex)
          return tNode.parent.injectorIndex;
        let hostTNode = view[6],
          viewOffset = 1;
        for (; hostTNode && -1 === hostTNode.injectorIndex; )
          (hostTNode = (view = view[15]) ? view[6] : null), viewOffset++;
        return hostTNode ? hostTNode.injectorIndex | (viewOffset << 16) : -1;
      }
      function diPublicInInjector(injectorIndex, tView, token) {
        !(function(injectorIndex, tView, type) {
          let id;
          'string' == typeof type
            ? (id = type.charCodeAt(0) || 0)
            : type.hasOwnProperty(NG_ELEMENT_ID) && (id = type[NG_ELEMENT_ID]),
            null == id && (id = type[NG_ELEMENT_ID] = nextNgElementId++);
          const bloomBit = 255 & id,
            mask = 1 << bloomBit,
            b6 = 64 & bloomBit,
            b5 = 32 & bloomBit,
            tData = tView.data;
          128 & bloomBit
            ? b6
              ? b5
                ? (tData[injectorIndex + 7] |= mask)
                : (tData[injectorIndex + 6] |= mask)
              : b5
              ? (tData[injectorIndex + 5] |= mask)
              : (tData[injectorIndex + 4] |= mask)
            : b6
            ? b5
              ? (tData[injectorIndex + 3] |= mask)
              : (tData[injectorIndex + 2] |= mask)
            : b5
            ? (tData[injectorIndex + 1] |= mask)
            : (tData[injectorIndex] |= mask);
        })(injectorIndex, tView, token);
      }
      function getOrCreateInjectable(
        tNode,
        lView,
        token,
        flags = InjectFlags.Default,
        notFoundValue
      ) {
        if (null !== tNode) {
          const bloomHash = (function(token) {
            if ('string' == typeof token) return token.charCodeAt(0) || 0;
            const tokenId = token.hasOwnProperty(NG_ELEMENT_ID)
              ? token[NG_ELEMENT_ID]
              : void 0;
            return 'number' == typeof tokenId && tokenId > 0
              ? 255 & tokenId
              : tokenId;
          })(token);
          if ('function' == typeof bloomHash) {
            enterDI(lView, tNode);
            try {
              const value = bloomHash();
              if (null != value || flags & InjectFlags.Optional) return value;
              throw new Error(`No provider for ${stringifyForError(token)}!`);
            } finally {
              leaveDI();
            }
          } else if ('number' == typeof bloomHash) {
            if (-1 === bloomHash) return new NodeInjector(tNode, lView);
            let previousTView = null,
              injectorIndex = getInjectorIndex(tNode, lView),
              parentLocation = -1,
              hostTElementNode = flags & InjectFlags.Host ? lView[16][6] : null;
            for (
              (-1 === injectorIndex || flags & InjectFlags.SkipSelf) &&
              ((parentLocation =
                -1 === injectorIndex
                  ? getParentInjectorLocation(tNode, lView)
                  : lView[injectorIndex + 8]),
              shouldSearchParent(flags, !1)
                ? ((previousTView = lView[1]),
                  (injectorIndex = getParentInjectorIndex(parentLocation)),
                  (lView = getParentInjectorView(parentLocation, lView)))
                : (injectorIndex = -1));
              -1 !== injectorIndex;

            ) {
              parentLocation = lView[injectorIndex + 8];
              const tView = lView[1];
              if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
                const instance = searchTokensOnInjector(
                  injectorIndex,
                  lView,
                  token,
                  previousTView,
                  flags,
                  hostTElementNode
                );
                if (instance !== NOT_FOUND) return instance;
              }
              shouldSearchParent(
                flags,
                lView[1].data[injectorIndex + 8] === hostTElementNode
              ) && bloomHasToken(bloomHash, injectorIndex, lView)
                ? ((previousTView = tView),
                  (injectorIndex = getParentInjectorIndex(parentLocation)),
                  (lView = getParentInjectorView(parentLocation, lView)))
                : (injectorIndex = -1);
            }
          }
        }
        if (
          (flags & InjectFlags.Optional &&
            void 0 === notFoundValue &&
            (notFoundValue = null),
          0 == (flags & (InjectFlags.Self | InjectFlags.Host)))
        ) {
          const moduleInjector = lView[9],
            previousInjectImplementation = setInjectImplementation(void 0);
          try {
            return moduleInjector
              ? moduleInjector.get(
                  token,
                  notFoundValue,
                  flags & InjectFlags.Optional
                )
              : injectRootLimpMode(
                  token,
                  notFoundValue,
                  flags & InjectFlags.Optional
                );
          } finally {
            setInjectImplementation(previousInjectImplementation);
          }
        }
        if (flags & InjectFlags.Optional) return notFoundValue;
        throw new Error(
          `NodeInjector: NOT_FOUND [${stringifyForError(token)}]`
        );
      }
      const NOT_FOUND = {};
      function searchTokensOnInjector(
        injectorIndex,
        lView,
        token,
        previousTView,
        flags,
        hostTElementNode
      ) {
        const currentTView = lView[1],
          tNode = currentTView.data[injectorIndex + 8],
          injectableIdx = locateDirectiveOrProvider(
            tNode,
            currentTView,
            token,
            null == previousTView
              ? isComponentHost(tNode) && includeViewProviders
              : previousTView != currentTView && 3 === tNode.type,
            flags & InjectFlags.Host && hostTElementNode === tNode
          );
        return null !== injectableIdx
          ? getNodeInjectable(lView, currentTView, injectableIdx, tNode)
          : NOT_FOUND;
      }
      function locateDirectiveOrProvider(
        tNode,
        tView,
        token,
        canAccessViewProviders,
        isHostSpecialCase
      ) {
        const nodeProviderIndexes = tNode.providerIndexes,
          tInjectables = tView.data,
          injectablesStart = 65535 & nodeProviderIndexes,
          directivesStart = tNode.directiveStart,
          cptViewProvidersCount = nodeProviderIndexes >> 16,
          endIndex = isHostSpecialCase
            ? injectablesStart + cptViewProvidersCount
            : tNode.directiveEnd;
        for (
          let i = canAccessViewProviders
            ? injectablesStart
            : injectablesStart + cptViewProvidersCount;
          i < endIndex;
          i++
        ) {
          const providerTokenOrDef = tInjectables[i];
          if (
            (i < directivesStart && token === providerTokenOrDef) ||
            (i >= directivesStart && providerTokenOrDef.type === token)
          )
            return i;
        }
        if (isHostSpecialCase) {
          const dirDef = tInjectables[directivesStart];
          if (dirDef && isComponentDef(dirDef) && dirDef.type === token)
            return directivesStart;
        }
        return null;
      }
      function getNodeInjectable(lView, tView, index, tNode) {
        let value = lView[index];
        const tData = tView.data;
        if (value instanceof NodeInjectorFactory) {
          const factory = value;
          if (factory.resolving)
            throw new Error(
              'Circular dep for ' + stringifyForError(tData[index])
            );
          const previousIncludeViewProviders = setIncludeViewProviders(
            factory.canSeeViewProviders
          );
          let previousInjectImplementation;
          (factory.resolving = !0),
            factory.injectImpl &&
              (previousInjectImplementation = setInjectImplementation(
                factory.injectImpl
              )),
            enterDI(lView, tNode);
          try {
            (value = lView[index] = factory.factory(
              void 0,
              tData,
              lView,
              tNode
            )),
              tView.firstCreatePass &&
                index >= tNode.directiveStart &&
                (function(directiveIndex, directiveDef, tView) {
                  const {
                    onChanges: onChanges,
                    onInit: onInit,
                    doCheck: doCheck
                  } = directiveDef;
                  onChanges &&
                    ((tView.preOrderHooks || (tView.preOrderHooks = [])).push(
                      directiveIndex,
                      onChanges
                    ),
                    (
                      tView.preOrderCheckHooks ||
                      (tView.preOrderCheckHooks = [])
                    ).push(directiveIndex, onChanges)),
                    onInit &&
                      (tView.preOrderHooks || (tView.preOrderHooks = [])).push(
                        -directiveIndex,
                        onInit
                      ),
                    doCheck &&
                      ((tView.preOrderHooks || (tView.preOrderHooks = [])).push(
                        directiveIndex,
                        doCheck
                      ),
                      (
                        tView.preOrderCheckHooks ||
                        (tView.preOrderCheckHooks = [])
                      ).push(directiveIndex, doCheck));
                })(index, tData[index], tView);
          } finally {
            factory.injectImpl &&
              setInjectImplementation(previousInjectImplementation),
              setIncludeViewProviders(previousIncludeViewProviders),
              (factory.resolving = !1),
              leaveDI();
          }
        }
        return value;
      }
      function bloomHasToken(bloomHash, injectorIndex, injectorView) {
        const b6 = 64 & bloomHash,
          b5 = 32 & bloomHash;
        let value;
        return (
          (value =
            128 & bloomHash
              ? b6
                ? b5
                  ? injectorView[injectorIndex + 7]
                  : injectorView[injectorIndex + 6]
                : b5
                ? injectorView[injectorIndex + 5]
                : injectorView[injectorIndex + 4]
              : b6
              ? b5
                ? injectorView[injectorIndex + 3]
                : injectorView[injectorIndex + 2]
              : b5
              ? injectorView[injectorIndex + 1]
              : injectorView[injectorIndex]),
          !!(value & (1 << bloomHash))
        );
      }
      function shouldSearchParent(flags, isFirstHostTNode) {
        return !(
          flags & InjectFlags.Self ||
          (flags & InjectFlags.Host && isFirstHostTNode)
        );
      }
      class NodeInjector {
        constructor(_tNode, _lView) {
          (this._tNode = _tNode), (this._lView = _lView);
        }
        get(token, notFoundValue) {
          return getOrCreateInjectable(
            this._tNode,
            this._lView,
            token,
            void 0,
            notFoundValue
          );
        }
      }
      function ɵɵgetFactoryOf(type) {
        const typeAny = type;
        if (isForwardRef(type))
          return () => {
            const factory = ɵɵgetFactoryOf(resolveForwardRef(typeAny));
            return factory ? factory() : null;
          };
        let factory = getFactoryDef(typeAny);
        if (null === factory) {
          const injectorDef = getInjectorDef(typeAny);
          factory = injectorDef && injectorDef.factory;
        }
        return factory || null;
      }
      function ɵɵgetInheritedFactory(type) {
        return noSideEffects(() => {
          const ownConstructor = type.prototype.constructor,
            ownFactory =
              ownConstructor[NG_FACTORY_DEF] || ɵɵgetFactoryOf(ownConstructor),
            objectPrototype = Object.prototype;
          let parent = Object.getPrototypeOf(type.prototype).constructor;
          for (; parent && parent !== objectPrototype; ) {
            const factory = parent[NG_FACTORY_DEF] || ɵɵgetFactoryOf(parent);
            if (factory && factory !== ownFactory) return factory;
            parent = Object.getPrototypeOf(parent);
          }
          return t => new t();
        });
      }
      function getDebugContext(error) {
        return error.ngDebugContext;
      }
      function getOriginalError(error) {
        return error.ngOriginalError;
      }
      function defaultErrorLogger(console, ...values) {
        console.error(...values);
      }
      class ErrorHandler {
        constructor() {
          this._console = console;
        }
        handleError(error) {
          const originalError = this._findOriginalError(error),
            context = this._findContext(error),
            errorLogger = (function(error) {
              return error.ngErrorLogger || defaultErrorLogger;
            })(error);
          errorLogger(this._console, 'ERROR', error),
            originalError &&
              errorLogger(this._console, 'ORIGINAL ERROR', originalError),
            context && errorLogger(this._console, 'ERROR CONTEXT', context);
        }
        _findContext(error) {
          return error
            ? getDebugContext(error)
              ? getDebugContext(error)
              : this._findContext(getOriginalError(error))
            : null;
        }
        _findOriginalError(error) {
          let e = getOriginalError(error);
          for (; e && getOriginalError(e); ) e = getOriginalError(e);
          return e;
        }
      }
      class SafeValueImpl {
        constructor(changingThisBreaksApplicationSecurity) {
          this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
        }
        toString() {
          return (
            'SafeValue must use [property]=binding: ' +
            this.changingThisBreaksApplicationSecurity +
            ' (see http://g.co/ng/security#xss)'
          );
        }
      }
      class SafeHtmlImpl extends SafeValueImpl {
        getTypeName() {
          return 'HTML';
        }
      }
      class SafeStyleImpl extends SafeValueImpl {
        getTypeName() {
          return 'Style';
        }
      }
      class SafeScriptImpl extends SafeValueImpl {
        getTypeName() {
          return 'Script';
        }
      }
      class SafeUrlImpl extends SafeValueImpl {
        getTypeName() {
          return 'URL';
        }
      }
      class SafeResourceUrlImpl extends SafeValueImpl {
        getTypeName() {
          return 'ResourceURL';
        }
      }
      function unwrapSafeValue(value) {
        return value instanceof SafeValueImpl
          ? value.changingThisBreaksApplicationSecurity
          : value;
      }
      function allowSanitizationBypassAndThrow(value, type) {
        const actualType = getSanitizationBypassType(value);
        if (null != actualType && actualType !== type) {
          if ('ResourceURL' === actualType && 'URL' === type) return !0;
          throw new Error(
            `Required a safe ${type}, got a ${actualType} (see http://g.co/ng/security#xss)`
          );
        }
        return actualType === type;
      }
      function getSanitizationBypassType(value) {
        return (value instanceof SafeValueImpl && value.getTypeName()) || null;
      }
      function bypassSanitizationTrustHtml(trustedHtml) {
        return new SafeHtmlImpl(trustedHtml);
      }
      function bypassSanitizationTrustStyle(trustedStyle) {
        return new SafeStyleImpl(trustedStyle);
      }
      function bypassSanitizationTrustScript(trustedScript) {
        return new SafeScriptImpl(trustedScript);
      }
      function bypassSanitizationTrustUrl(trustedUrl) {
        return new SafeUrlImpl(trustedUrl);
      }
      function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
        return new SafeResourceUrlImpl(trustedResourceUrl);
      }
      let _devMode = !0,
        _runModeLocked = !1;
      function isDevMode() {
        return (_runModeLocked = !0), _devMode;
      }
      function enableProdMode() {
        if (_runModeLocked)
          throw new Error('Cannot enable prod mode after platform setup.');
        _devMode = !1;
      }
      function getInertBodyHelper(defaultDoc) {
        return (function() {
          try {
            return !!new window.DOMParser().parseFromString('', 'text/html');
          } catch (_a) {
            return !1;
          }
        })()
          ? new DOMParserHelper()
          : new InertDocumentHelper(defaultDoc);
      }
      class DOMParserHelper {
        getInertBodyElement(html) {
          html = '<body><remove></remove>' + html + '</body>';
          try {
            const body = new window.DOMParser().parseFromString(
              html,
              'text/html'
            ).body;
            return body.removeChild(body.firstChild), body;
          } catch (_a) {
            return null;
          }
        }
      }
      class InertDocumentHelper {
        constructor(defaultDoc) {
          if (
            ((this.defaultDoc = defaultDoc),
            (this.inertDocument = this.defaultDoc.implementation.createHTMLDocument(
              'sanitization-inert'
            )),
            null == this.inertDocument.body)
          ) {
            const inertHtml = this.inertDocument.createElement('html');
            this.inertDocument.appendChild(inertHtml);
            const inertBodyElement = this.inertDocument.createElement('body');
            inertHtml.appendChild(inertBodyElement);
          }
        }
        getInertBodyElement(html) {
          const templateEl = this.inertDocument.createElement('template');
          if ('content' in templateEl)
            return (templateEl.innerHTML = html), templateEl;
          const inertBody = this.inertDocument.createElement('body');
          return (
            (inertBody.innerHTML = html),
            this.defaultDoc.documentMode && this.stripCustomNsAttrs(inertBody),
            inertBody
          );
        }
        stripCustomNsAttrs(el) {
          const elAttrs = el.attributes;
          for (let i = elAttrs.length - 1; 0 < i; i--) {
            const attrName = elAttrs.item(i).name;
            ('xmlns:ns1' !== attrName && 0 !== attrName.indexOf('ns1:')) ||
              el.removeAttribute(attrName);
          }
          let childNode = el.firstChild;
          for (; childNode; )
            childNode.nodeType === Node.ELEMENT_NODE &&
              this.stripCustomNsAttrs(childNode),
              (childNode = childNode.nextSibling);
        }
      }
      const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi,
        DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
      function _sanitizeUrl(url) {
        return (url = String(url)).match(SAFE_URL_PATTERN) ||
          url.match(DATA_URL_PATTERN)
          ? url
          : (isDevMode() &&
              console.warn(
                `WARNING: sanitizing unsafe URL value ${url} (see http://g.co/ng/security#xss)`
              ),
            'unsafe:' + url);
      }
      function sanitizeSrcset(srcset) {
        return (srcset = String(srcset))
          .split(',')
          .map(srcset => _sanitizeUrl(srcset.trim()))
          .join(', ');
      }
      function tagSet(tags) {
        const res = {};
        for (const t of tags.split(',')) res[t] = !0;
        return res;
      }
      function merge(...sets) {
        const res = {};
        for (const s of sets)
          for (const v in s) s.hasOwnProperty(v) && (res[v] = !0);
        return res;
      }
      const VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr'),
        OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet(
          'colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr'
        ),
        OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt'),
        OPTIONAL_END_TAG_ELEMENTS = merge(
          OPTIONAL_END_TAG_INLINE_ELEMENTS,
          OPTIONAL_END_TAG_BLOCK_ELEMENTS
        ),
        VALID_ELEMENTS = merge(
          VOID_ELEMENTS,
          merge(
            OPTIONAL_END_TAG_BLOCK_ELEMENTS,
            tagSet(
              'address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'
            )
          ),
          merge(
            OPTIONAL_END_TAG_INLINE_ELEMENTS,
            tagSet(
              'a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'
            )
          ),
          OPTIONAL_END_TAG_ELEMENTS
        ),
        URI_ATTRS = tagSet(
          'background,cite,href,itemtype,longdesc,poster,src,xlink:href'
        ),
        SRCSET_ATTRS = tagSet('srcset'),
        VALID_ATTRS = merge(
          URI_ATTRS,
          SRCSET_ATTRS,
          tagSet(
            'abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width'
          ),
          tagSet(
            'aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext'
          )
        ),
        SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet(
          'script,style,template'
        );
      class SanitizingHtmlSerializer {
        constructor() {
          (this.sanitizedSomething = !1), (this.buf = []);
        }
        sanitizeChildren(el) {
          let current = el.firstChild,
            traverseContent = !0;
          for (; current; )
            if (
              (current.nodeType === Node.ELEMENT_NODE
                ? (traverseContent = this.startElement(current))
                : current.nodeType === Node.TEXT_NODE
                ? this.chars(current.nodeValue)
                : (this.sanitizedSomething = !0),
              traverseContent && current.firstChild)
            )
              current = current.firstChild;
            else
              for (; current; ) {
                current.nodeType === Node.ELEMENT_NODE &&
                  this.endElement(current);
                let next = this.checkClobberedElement(
                  current,
                  current.nextSibling
                );
                if (next) {
                  current = next;
                  break;
                }
                current = this.checkClobberedElement(
                  current,
                  current.parentNode
                );
              }
          return this.buf.join('');
        }
        startElement(element) {
          const tagName = element.nodeName.toLowerCase();
          if (!VALID_ELEMENTS.hasOwnProperty(tagName))
            return (
              (this.sanitizedSomething = !0),
              !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(
                tagName
              )
            );
          this.buf.push('<'), this.buf.push(tagName);
          const elAttrs = element.attributes;
          for (let i = 0; i < elAttrs.length; i++) {
            const elAttr = elAttrs.item(i),
              attrName = elAttr.name,
              lower = attrName.toLowerCase();
            if (!VALID_ATTRS.hasOwnProperty(lower)) {
              this.sanitizedSomething = !0;
              continue;
            }
            let value = elAttr.value;
            URI_ATTRS[lower] && (value = _sanitizeUrl(value)),
              SRCSET_ATTRS[lower] && (value = sanitizeSrcset(value)),
              this.buf.push(' ', attrName, '="', encodeEntities(value), '"');
          }
          return this.buf.push('>'), !0;
        }
        endElement(current) {
          const tagName = current.nodeName.toLowerCase();
          VALID_ELEMENTS.hasOwnProperty(tagName) &&
            !VOID_ELEMENTS.hasOwnProperty(tagName) &&
            (this.buf.push('</'), this.buf.push(tagName), this.buf.push('>'));
        }
        chars(chars) {
          this.buf.push(encodeEntities(chars));
        }
        checkClobberedElement(node, nextNode) {
          if (
            nextNode &&
            (node.compareDocumentPosition(nextNode) &
              Node.DOCUMENT_POSITION_CONTAINED_BY) ===
              Node.DOCUMENT_POSITION_CONTAINED_BY
          )
            throw new Error(
              'Failed to sanitize html because the element is clobbered: ' +
                node.outerHTML
            );
          return nextNode;
        }
      }
      const SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
        NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
      function encodeEntities(value) {
        return value
          .replace(/&/g, '&amp;')
          .replace(SURROGATE_PAIR_REGEXP, function(match) {
            return (
              '&#' +
              (1024 * (match.charCodeAt(0) - 55296) +
                (match.charCodeAt(1) - 56320) +
                65536) +
              ';'
            );
          })
          .replace(NON_ALPHANUMERIC_REGEXP, function(match) {
            return '&#' + match.charCodeAt(0) + ';';
          })
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }
      let inertBodyHelper;
      function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
        let inertBodyElement = null;
        try {
          inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
          let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
          inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
          let mXSSAttempts = 5,
            parsedHtml = unsafeHtml;
          do {
            if (0 === mXSSAttempts)
              throw new Error(
                'Failed to sanitize html because the input is unstable'
              );
            mXSSAttempts--,
              (unsafeHtml = parsedHtml),
              (parsedHtml = inertBodyElement.innerHTML),
              (inertBodyElement = inertBodyHelper.getInertBodyElement(
                unsafeHtml
              ));
          } while (unsafeHtml !== parsedHtml);
          const sanitizer = new SanitizingHtmlSerializer(),
            safeHtml = sanitizer.sanitizeChildren(
              getTemplateContent(inertBodyElement) || inertBodyElement
            );
          return (
            isDevMode() &&
              sanitizer.sanitizedSomething &&
              console.warn(
                'WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss'
              ),
            safeHtml
          );
        } finally {
          if (inertBodyElement) {
            const parent =
              getTemplateContent(inertBodyElement) || inertBodyElement;
            for (; parent.firstChild; ) parent.removeChild(parent.firstChild);
          }
        }
      }
      function getTemplateContent(el) {
        return 'content' in el &&
          (function(el) {
            return (
              el.nodeType === Node.ELEMENT_NODE && 'TEMPLATE' === el.nodeName
            );
          })(el)
          ? el.content
          : null;
      }
      var SecurityContext = (function(SecurityContext) {
        return (
          (SecurityContext[(SecurityContext.NONE = 0)] = 'NONE'),
          (SecurityContext[(SecurityContext.HTML = 1)] = 'HTML'),
          (SecurityContext[(SecurityContext.STYLE = 2)] = 'STYLE'),
          (SecurityContext[(SecurityContext.SCRIPT = 3)] = 'SCRIPT'),
          (SecurityContext[(SecurityContext.URL = 4)] = 'URL'),
          (SecurityContext[(SecurityContext.RESOURCE_URL = 5)] =
            'RESOURCE_URL'),
          SecurityContext
        );
      })({});
      function ɵɵsanitizeHtml(unsafeHtml) {
        const sanitizer = getSanitizer();
        return sanitizer
          ? sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || ''
          : allowSanitizationBypassAndThrow(unsafeHtml, 'HTML')
          ? unwrapSafeValue(unsafeHtml)
          : _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
      }
      function ɵɵsanitizeUrl(unsafeUrl) {
        const sanitizer = getSanitizer();
        return sanitizer
          ? sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || ''
          : allowSanitizationBypassAndThrow(unsafeUrl, 'URL')
          ? unwrapSafeValue(unsafeUrl)
          : _sanitizeUrl(renderStringify(unsafeUrl));
      }
      function ɵɵsanitizeResourceUrl(unsafeResourceUrl) {
        const sanitizer = getSanitizer();
        if (sanitizer)
          return (
            sanitizer.sanitize(
              SecurityContext.RESOURCE_URL,
              unsafeResourceUrl
            ) || ''
          );
        if (allowSanitizationBypassAndThrow(unsafeResourceUrl, 'ResourceURL'))
          return unwrapSafeValue(unsafeResourceUrl);
        throw new Error(
          'unsafe value used in a resource URL context (see http://g.co/ng/security#xss)'
        );
      }
      function getSanitizer() {
        const lView = getLView();
        return lView && lView[12];
      }
      function attachPatchData(target, data) {
        target.__ngContext__ = data;
      }
      function throwMultipleComponentError(tNode) {
        throw new Error(
          'Multiple components match node with tagname ' + tNode.tagName
        );
      }
      function throwMixedMultiProviderError() {
        throw new Error('Cannot mix multi providers and regular providers');
      }
      function classIndexOf(className, classToSearch, startingIndex) {
        let end = className.length;
        for (;;) {
          const foundIndex = className.indexOf(classToSearch, startingIndex);
          if (-1 === foundIndex) return foundIndex;
          if (0 === foundIndex || className.charCodeAt(foundIndex - 1) <= 32) {
            const length = classToSearch.length;
            if (
              foundIndex + length === end ||
              className.charCodeAt(foundIndex + length) <= 32
            )
              return foundIndex;
          }
          startingIndex = foundIndex + 1;
        }
      }
      function isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {
        let i = 0;
        for (; i < attrs.length; ) {
          let item = attrs[i++];
          if (isProjectionMode && 'class' === item) {
            if (
              ((item = attrs[i]),
              -1 !== classIndexOf(item.toLowerCase(), cssClassToMatch, 0))
            )
              return !0;
          } else if (1 === item) {
            for (; i < attrs.length && 'string' == typeof (item = attrs[i++]); )
              if (item.toLowerCase() === cssClassToMatch) return !0;
            return !1;
          }
        }
        return !1;
      }
      function isInlineTemplate(tNode) {
        return 0 === tNode.type && 'ng-template' !== tNode.tagName;
      }
      function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
        return (
          currentSelector ===
          (0 !== tNode.type || isProjectionMode ? tNode.tagName : 'ng-template')
        );
      }
      function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
        let mode = 4;
        const nodeAttrs = tNode.attrs || [],
          nameOnlyMarkerIdx = (function(nodeAttrs) {
            for (let i = 0; i < nodeAttrs.length; i++)
              if (isNameOnlyAttributeMarker(nodeAttrs[i])) return i;
            return nodeAttrs.length;
          })(nodeAttrs);
        let skipToNextSelector = !1;
        for (let i = 0; i < selector.length; i++) {
          const current = selector[i];
          if ('number' != typeof current) {
            if (!skipToNextSelector)
              if (4 & mode) {
                if (
                  ((mode = 2 | (1 & mode)),
                  ('' !== current &&
                    !hasTagAndTypeMatch(tNode, current, isProjectionMode)) ||
                    ('' === current && 1 === selector.length))
                ) {
                  if (isPositive(mode)) return !1;
                  skipToNextSelector = !0;
                }
              } else {
                const selectorAttrValue = 8 & mode ? current : selector[++i];
                if (8 & mode && null !== tNode.attrs) {
                  if (
                    !isCssClassMatching(
                      tNode.attrs,
                      selectorAttrValue,
                      isProjectionMode
                    )
                  ) {
                    if (isPositive(mode)) return !1;
                    skipToNextSelector = !0;
                  }
                  continue;
                }
                const attrIndexInNode = findAttrIndexInNode(
                  8 & mode ? 'class' : current,
                  nodeAttrs,
                  isInlineTemplate(tNode),
                  isProjectionMode
                );
                if (-1 === attrIndexInNode) {
                  if (isPositive(mode)) return !1;
                  skipToNextSelector = !0;
                  continue;
                }
                if ('' !== selectorAttrValue) {
                  let nodeAttrValue;
                  nodeAttrValue =
                    attrIndexInNode > nameOnlyMarkerIdx
                      ? ''
                      : nodeAttrs[attrIndexInNode + 1].toLowerCase();
                  const compareAgainstClassName =
                    8 & mode ? nodeAttrValue : null;
                  if (
                    (compareAgainstClassName &&
                      -1 !==
                        classIndexOf(
                          compareAgainstClassName,
                          selectorAttrValue,
                          0
                        )) ||
                    (2 & mode && selectorAttrValue !== nodeAttrValue)
                  ) {
                    if (isPositive(mode)) return !1;
                    skipToNextSelector = !0;
                  }
                }
              }
          } else {
            if (
              !skipToNextSelector &&
              !isPositive(mode) &&
              !isPositive(current)
            )
              return !1;
            if (skipToNextSelector && isPositive(current)) continue;
            (skipToNextSelector = !1), (mode = current | (1 & mode));
          }
        }
        return isPositive(mode) || skipToNextSelector;
      }
      function isPositive(mode) {
        return 0 == (1 & mode);
      }
      function findAttrIndexInNode(
        name,
        attrs,
        isInlineTemplate,
        isProjectionMode
      ) {
        if (null === attrs) return -1;
        let i = 0;
        if (isProjectionMode || !isInlineTemplate) {
          let bindingsMode = !1;
          for (; i < attrs.length; ) {
            const maybeAttrName = attrs[i];
            if (maybeAttrName === name) return i;
            if (3 === maybeAttrName || 6 === maybeAttrName) bindingsMode = !0;
            else {
              if (1 === maybeAttrName || 2 === maybeAttrName) {
                let value = attrs[++i];
                for (; 'string' == typeof value; ) value = attrs[++i];
                continue;
              }
              if (4 === maybeAttrName) break;
              if (0 === maybeAttrName) {
                i += 4;
                continue;
              }
            }
            i += bindingsMode ? 1 : 2;
          }
          return -1;
        }
        return (function(attrs, name) {
          let i = attrs.indexOf(4);
          if (i > -1)
            for (i++; i < attrs.length; ) {
              const attr = attrs[i];
              if ('number' == typeof attr) return -1;
              if (attr === name) return i;
              i++;
            }
          return -1;
        })(attrs, name);
      }
      function isNodeMatchingSelectorList(
        tNode,
        selector,
        isProjectionMode = !1
      ) {
        for (let i = 0; i < selector.length; i++)
          if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode))
            return !0;
        return !1;
      }
      function isSelectorInSelectorList(selector, list) {
        selectorListLoop: for (let i = 0; i < list.length; i++) {
          const currentSelectorInList = list[i];
          if (selector.length === currentSelectorInList.length) {
            for (let j = 0; j < selector.length; j++)
              if (selector[j] !== currentSelectorInList[j])
                continue selectorListLoop;
            return !0;
          }
        }
        return !1;
      }
      function maybeWrapInNotSelector(isNegativeMode, chunk) {
        return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;
      }
      function stringifyCSSSelector(selector) {
        let result = selector[0],
          i = 1,
          mode = 2,
          currentChunk = '',
          isNegativeMode = !1;
        for (; i < selector.length; ) {
          let valueOrMarker = selector[i];
          if ('string' == typeof valueOrMarker)
            if (2 & mode) {
              const attrValue = selector[++i];
              currentChunk +=
                '[' +
                valueOrMarker +
                (attrValue.length > 0 ? '="' + attrValue + '"' : '') +
                ']';
            } else
              8 & mode
                ? (currentChunk += '.' + valueOrMarker)
                : 4 & mode && (currentChunk += ' ' + valueOrMarker);
          else
            '' === currentChunk ||
              isPositive(valueOrMarker) ||
              ((result += maybeWrapInNotSelector(isNegativeMode, currentChunk)),
              (currentChunk = '')),
              (mode = valueOrMarker),
              (isNegativeMode = isNegativeMode || !isPositive(mode));
          i++;
        }
        return (
          '' !== currentChunk &&
            (result += maybeWrapInNotSelector(isNegativeMode, currentChunk)),
          result
        );
      }
      const NO_CHANGE = {};
      function getLViewParent(lView) {
        const parent = lView[3];
        return isLContainer(parent) ? parent[3] : parent;
      }
      function getFirstLContainer(lView) {
        return getNearestLContainer(lView[13]);
      }
      function getNextLContainer(container) {
        return getNearestLContainer(container[4]);
      }
      function getNearestLContainer(viewOrContainer) {
        for (; null !== viewOrContainer && !isLContainer(viewOrContainer); )
          viewOrContainer = viewOrContainer[4];
        return viewOrContainer;
      }
      function ɵɵadvance(delta) {
        selectIndexInternal(
          getTView(),
          getLView(),
          getSelectedIndex() + delta,
          getCheckNoChangesMode()
        );
      }
      function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
        if (!checkNoChangesMode)
          if (3 == (3 & lView[2])) {
            const preOrderCheckHooks = tView.preOrderCheckHooks;
            null !== preOrderCheckHooks &&
              executeCheckHooks(lView, preOrderCheckHooks, index);
          } else {
            const preOrderHooks = tView.preOrderHooks;
            null !== preOrderHooks &&
              executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
          }
        setSelectedIndex(index);
      }
      const ELEMENT_MARKER = { marker: 'element' },
        COMMENT_MARKER = { marker: 'comment' };
      function toTStylingRange(prev, next) {
        return (prev << 17) | (next << 2);
      }
      function getTStylingRangePrev(tStylingRange) {
        return (tStylingRange >> 17) & 32767;
      }
      function setTStylingRangePrevDuplicate(tStylingRange) {
        return 2 | tStylingRange;
      }
      function getTStylingRangeNext(tStylingRange) {
        return (131068 & tStylingRange) >> 2;
      }
      function setTStylingRangeNext(tStylingRange, next) {
        return (-131069 & tStylingRange) | (next << 2);
      }
      function setTStylingRangeNextDuplicate(tStylingRange) {
        return 1 | tStylingRange;
      }
      function refreshContentQueries(tView, lView) {
        const contentQueries = tView.contentQueries;
        if (null !== contentQueries)
          for (let i = 0; i < contentQueries.length; i += 2) {
            const queryStartIdx = contentQueries[i],
              directiveDefIdx = contentQueries[i + 1];
            if (-1 !== directiveDefIdx) {
              const directiveDef = tView.data[directiveDefIdx];
              setCurrentQueryIndex(queryStartIdx),
                directiveDef.contentQueries(
                  2,
                  lView[directiveDefIdx],
                  directiveDefIdx
                );
            }
          }
      }
      function elementCreate(name, renderer, namespace) {
        return isProceduralRenderer(renderer)
          ? renderer.createElement(name, namespace)
          : null === namespace
          ? renderer.createElement(name)
          : renderer.createElementNS(namespace, name);
      }
      function createLView(
        parentLView,
        tView,
        context,
        flags,
        host,
        tHostNode,
        rendererFactory,
        renderer,
        sanitizer,
        injector
      ) {
        const lView = tView.blueprint.slice();
        return (
          (lView[0] = host),
          (lView[2] = 140 | flags),
          resetPreOrderHookFlags(lView),
          (lView[3] = lView[15] = parentLView),
          (lView[8] = context),
          (lView[10] = rendererFactory || (parentLView && parentLView[10])),
          (lView[11] = renderer || (parentLView && parentLView[11])),
          (lView[12] = sanitizer || (parentLView && parentLView[12]) || null),
          (lView[9] = injector || (parentLView && parentLView[9]) || null),
          (lView[6] = tHostNode),
          (lView[16] = 2 == tView.type ? parentLView[16] : lView),
          lView
        );
      }
      function getOrCreateTNode(tView, tHostNode, index, type, name, attrs) {
        const adjustedIndex = index + 20,
          tNode =
            tView.data[adjustedIndex] ||
            (function(tView, tHostNode, adjustedIndex, type, name, attrs) {
              const previousOrParentTNode = getPreviousOrParentTNode(),
                isParent = getIsParent(),
                parent = isParent
                  ? previousOrParentTNode
                  : previousOrParentTNode && previousOrParentTNode.parent,
                tNode = (tView.data[adjustedIndex] = createTNode(
                  0,
                  parent && parent !== tHostNode ? parent : null,
                  type,
                  adjustedIndex,
                  name,
                  attrs
                ));
              return (
                null === tView.firstChild && (tView.firstChild = tNode),
                previousOrParentTNode &&
                  (!isParent ||
                  null != previousOrParentTNode.child ||
                  (null === tNode.parent && 2 !== previousOrParentTNode.type)
                    ? isParent || (previousOrParentTNode.next = tNode)
                    : (previousOrParentTNode.child = tNode)),
                tNode
              );
            })(tView, tHostNode, adjustedIndex, type, name, attrs);
        return setPreviousOrParentTNode(tNode, !0), tNode;
      }
      function renderView(tView, lView, context) {
        enterView(lView, lView[6]);
        try {
          const viewQuery = tView.viewQuery;
          null !== viewQuery && executeViewQueryFn(1, viewQuery, context);
          const templateFn = tView.template;
          null !== templateFn &&
            executeTemplate(tView, lView, templateFn, 1, context),
            tView.firstCreatePass && (tView.firstCreatePass = !1),
            tView.staticContentQueries && refreshContentQueries(tView, lView),
            tView.staticViewQueries &&
              executeViewQueryFn(2, tView.viewQuery, context);
          const components = tView.components;
          null !== components &&
            (function(hostLView, components) {
              for (let i = 0; i < components.length; i++)
                renderComponent(hostLView, components[i]);
            })(lView, components);
        } catch (error) {
          throw (tView.firstCreatePass && (tView.incompleteFirstPass = !0),
          error);
        } finally {
          (lView[2] &= -5), leaveView();
        }
      }
      function refreshView(tView, lView, templateFn, context) {
        const flags = lView[2];
        if (256 == (256 & flags)) return;
        enterView(lView, lView[6]);
        const checkNoChangesMode = getCheckNoChangesMode();
        try {
          resetPreOrderHookFlags(lView),
            (instructionState.lFrame.bindingIndex = tView.bindingStartIndex),
            null !== templateFn &&
              executeTemplate(tView, lView, templateFn, 2, context);
          const hooksInitPhaseCompleted = 3 == (3 & flags);
          if (!checkNoChangesMode)
            if (hooksInitPhaseCompleted) {
              const preOrderCheckHooks = tView.preOrderCheckHooks;
              null !== preOrderCheckHooks &&
                executeCheckHooks(lView, preOrderCheckHooks, null);
            } else {
              const preOrderHooks = tView.preOrderHooks;
              null !== preOrderHooks &&
                executeInitAndCheckHooks(lView, preOrderHooks, 0, null),
                incrementInitPhaseFlags(lView, 0);
            }
          if (
            ((function(lView) {
              for (
                let lContainer = getFirstLContainer(lView);
                null !== lContainer;
                lContainer = getNextLContainer(lContainer)
              ) {
                if (!lContainer[2]) continue;
                const movedViews = lContainer[9];
                for (let i = 0; i < movedViews.length; i++) {
                  const movedLView = movedViews[i],
                    insertionLContainer = movedLView[3];
                  0 == (1024 & movedLView[2]) &&
                    updateTransplantedViewCount(insertionLContainer, 1),
                    (movedLView[2] |= 1024);
                }
              }
            })(lView),
            (function(lView) {
              for (
                let lContainer = getFirstLContainer(lView);
                null !== lContainer;
                lContainer = getNextLContainer(lContainer)
              )
                for (let i = 10; i < lContainer.length; i++) {
                  const embeddedLView = lContainer[i],
                    embeddedTView = embeddedLView[1];
                  viewAttachedToChangeDetector(embeddedLView) &&
                    refreshView(
                      embeddedTView,
                      embeddedLView,
                      embeddedTView.template,
                      embeddedLView[8]
                    );
                }
            })(lView),
            null !== tView.contentQueries &&
              refreshContentQueries(tView, lView),
            !checkNoChangesMode)
          )
            if (hooksInitPhaseCompleted) {
              const contentCheckHooks = tView.contentCheckHooks;
              null !== contentCheckHooks &&
                executeCheckHooks(lView, contentCheckHooks);
            } else {
              const contentHooks = tView.contentHooks;
              null !== contentHooks &&
                executeInitAndCheckHooks(lView, contentHooks, 1),
                incrementInitPhaseFlags(lView, 1);
            }
          !(function(tView, lView) {
            try {
              const expandoInstructions = tView.expandoInstructions;
              if (null !== expandoInstructions) {
                let bindingRootIndex = tView.expandoStartIndex,
                  currentDirectiveIndex = -1,
                  currentElementIndex = -1;
                for (let i = 0; i < expandoInstructions.length; i++) {
                  const instruction = expandoInstructions[i];
                  'number' == typeof instruction
                    ? instruction <= 0
                      ? ((currentElementIndex = 0 - instruction),
                        setSelectedIndex(currentElementIndex),
                        (bindingRootIndex += 9 + expandoInstructions[++i]),
                        (currentDirectiveIndex = bindingRootIndex))
                      : (bindingRootIndex += instruction)
                    : (null !== instruction &&
                        (setBindingRootForHostBindings(
                          bindingRootIndex,
                          currentDirectiveIndex
                        ),
                        instruction(2, lView[currentDirectiveIndex])),
                      currentDirectiveIndex++);
                }
              }
            } finally {
              setSelectedIndex(-1);
            }
          })(tView, lView);
          const components = tView.components;
          null !== components &&
            (function(hostLView, components) {
              for (let i = 0; i < components.length; i++)
                refreshComponent(hostLView, components[i]);
            })(lView, components);
          const viewQuery = tView.viewQuery;
          if (
            (null !== viewQuery && executeViewQueryFn(2, viewQuery, context),
            !checkNoChangesMode)
          )
            if (hooksInitPhaseCompleted) {
              const viewCheckHooks = tView.viewCheckHooks;
              null !== viewCheckHooks &&
                executeCheckHooks(lView, viewCheckHooks);
            } else {
              const viewHooks = tView.viewHooks;
              null !== viewHooks &&
                executeInitAndCheckHooks(lView, viewHooks, 2),
                incrementInitPhaseFlags(lView, 2);
            }
          !0 === tView.firstUpdatePass && (tView.firstUpdatePass = !1),
            checkNoChangesMode || (lView[2] &= -73),
            1024 & lView[2] &&
              ((lView[2] &= -1025), updateTransplantedViewCount(lView[3], -1));
        } finally {
          leaveView();
        }
      }
      function renderComponentOrTemplate(tView, lView, templateFn, context) {
        const rendererFactory = lView[10],
          normalExecutionPath = !getCheckNoChangesMode(),
          creationModeIsActive = isCreationMode(lView);
        try {
          normalExecutionPath &&
            !creationModeIsActive &&
            rendererFactory.begin &&
            rendererFactory.begin(),
            creationModeIsActive && renderView(tView, lView, context),
            refreshView(tView, lView, templateFn, context);
        } finally {
          normalExecutionPath &&
            !creationModeIsActive &&
            rendererFactory.end &&
            rendererFactory.end();
        }
      }
      function executeTemplate(tView, lView, templateFn, rf, context) {
        const prevSelectedIndex = getSelectedIndex();
        try {
          setSelectedIndex(-1),
            2 & rf &&
              lView.length > 20 &&
              selectIndexInternal(tView, lView, 0, getCheckNoChangesMode()),
            templateFn(rf, context);
        } finally {
          setSelectedIndex(prevSelectedIndex);
        }
      }
      function executeContentQueries(tView, tNode, lView) {
        if (isContentQueryHost(tNode)) {
          const end = tNode.directiveEnd;
          for (
            let directiveIndex = tNode.directiveStart;
            directiveIndex < end;
            directiveIndex++
          ) {
            const def = tView.data[directiveIndex];
            def.contentQueries &&
              def.contentQueries(1, lView[directiveIndex], directiveIndex);
          }
        }
      }
      function createDirectivesInstances(tView, lView, tNode) {
        getBindingsEnabled() &&
          ((function(tView, lView, tNode, native) {
            const start = tNode.directiveStart,
              end = tNode.directiveEnd;
            tView.firstCreatePass ||
              getOrCreateNodeInjectorForNode(tNode, lView),
              attachPatchData(native, lView);
            const initialInputs = tNode.initialInputs;
            for (let i = start; i < end; i++) {
              const def = tView.data[i],
                isComponent = isComponentDef(def);
              isComponent && addComponentLogic(lView, tNode, def);
              const directive = getNodeInjectable(lView, tView, i, tNode);
              attachPatchData(directive, lView),
                null !== initialInputs &&
                  setInputsFromAttrs(
                    0,
                    i - start,
                    directive,
                    def,
                    0,
                    initialInputs
                  ),
                isComponent &&
                  (getComponentLViewByIndex(tNode.index, lView)[8] = directive);
            }
          })(tView, lView, tNode, getNativeByTNode(tNode, lView)),
          128 == (128 & tNode.flags) &&
            (function(tView, lView, tNode) {
              const start = tNode.directiveStart,
                end = tNode.directiveEnd,
                expando = tView.expandoInstructions,
                firstCreatePass = tView.firstCreatePass,
                elementIndex = tNode.index - 20,
                currentDirectiveIndex =
                  instructionState.lFrame.currentDirectiveIndex;
              try {
                setSelectedIndex(elementIndex);
                for (let dirIndex = start; dirIndex < end; dirIndex++) {
                  const def = tView.data[dirIndex],
                    directive = lView[dirIndex];
                  setCurrentDirectiveIndex(dirIndex),
                    null !== def.hostBindings ||
                    0 !== def.hostVars ||
                    null !== def.hostAttrs
                      ? invokeHostBindingsInCreationMode(def, directive)
                      : firstCreatePass && expando.push(null);
                }
              } finally {
                setSelectedIndex(-1),
                  setCurrentDirectiveIndex(currentDirectiveIndex);
              }
            })(tView, lView, tNode));
      }
      function saveResolvedLocalsInData(
        viewData,
        tNode,
        localRefExtractor = getNativeByTNode
      ) {
        const localNames = tNode.localNames;
        if (null !== localNames) {
          let localIndex = tNode.index + 1;
          for (let i = 0; i < localNames.length; i += 2) {
            const index = localNames[i + 1],
              value =
                -1 === index
                  ? localRefExtractor(tNode, viewData)
                  : viewData[index];
            viewData[localIndex++] = value;
          }
        }
      }
      function getOrCreateTComponentView(def) {
        const tView = def.tView;
        return null === tView || tView.incompleteFirstPass
          ? (def.tView = createTView(
              1,
              -1,
              def.template,
              def.decls,
              def.vars,
              def.directiveDefs,
              def.pipeDefs,
              def.viewQuery,
              def.schemas,
              def.consts
            ))
          : tView;
      }
      function createTView(
        type,
        viewIndex,
        templateFn,
        decls,
        vars,
        directives,
        pipes,
        viewQuery,
        schemas,
        consts
      ) {
        const bindingStartIndex = 20 + decls,
          initialViewLength = bindingStartIndex + vars,
          blueprint = (function(bindingStartIndex, initialViewLength) {
            const blueprint = [];
            for (let i = 0; i < initialViewLength; i++)
              blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
            return blueprint;
          })(bindingStartIndex, initialViewLength);
        return (blueprint[1] = {
          type: type,
          id: viewIndex,
          blueprint: blueprint,
          template: templateFn,
          queries: null,
          viewQuery: viewQuery,
          node: null,
          data: blueprint.slice().fill(null, bindingStartIndex),
          bindingStartIndex: bindingStartIndex,
          expandoStartIndex: initialViewLength,
          expandoInstructions: null,
          firstCreatePass: !0,
          firstUpdatePass: !0,
          staticViewQueries: !1,
          staticContentQueries: !1,
          preOrderHooks: null,
          preOrderCheckHooks: null,
          contentHooks: null,
          contentCheckHooks: null,
          viewHooks: null,
          viewCheckHooks: null,
          destroyHooks: null,
          cleanup: null,
          contentQueries: null,
          components: null,
          directiveRegistry:
            'function' == typeof directives ? directives() : directives,
          pipeRegistry: 'function' == typeof pipes ? pipes() : pipes,
          firstChild: null,
          schemas: schemas,
          consts: consts,
          incompleteFirstPass: !1
        });
      }
      function storeCleanupWithContext(tView, lView, context, cleanupFn) {
        const lCleanup = getLCleanup(lView);
        lCleanup.push(context),
          tView.firstCreatePass &&
            (function(tView) {
              return tView.cleanup || (tView.cleanup = []);
            })(tView).push(cleanupFn, lCleanup.length - 1);
      }
      function createTNode(
        tView,
        tParent,
        type,
        adjustedIndex,
        tagName,
        attrs
      ) {
        return {
          type: type,
          index: adjustedIndex,
          injectorIndex: tParent ? tParent.injectorIndex : -1,
          directiveStart: -1,
          directiveEnd: -1,
          directiveStylingLast: -1,
          propertyBindings: null,
          flags: 0,
          providerIndexes: 0,
          tagName: tagName,
          attrs: attrs,
          mergedAttrs: null,
          localNames: null,
          initialInputs: void 0,
          inputs: null,
          outputs: null,
          tViews: null,
          next: null,
          projectionNext: null,
          child: null,
          parent: tParent,
          projection: null,
          styles: null,
          stylesWithoutHost: null,
          residualStyles: void 0,
          classes: null,
          classesWithoutHost: null,
          residualClasses: void 0,
          classBindings: 0,
          styleBindings: 0
        };
      }
      function generatePropertyAliases(
        inputAliasMap,
        directiveDefIdx,
        propStore
      ) {
        for (let publicName in inputAliasMap)
          if (inputAliasMap.hasOwnProperty(publicName)) {
            const internalName = inputAliasMap[publicName];
            (propStore = null === propStore ? {} : propStore).hasOwnProperty(
              publicName
            )
              ? propStore[publicName].push(directiveDefIdx, internalName)
              : (propStore[publicName] = [directiveDefIdx, internalName]);
          }
        return propStore;
      }
      function elementPropertyInternal(
        tView,
        tNode,
        lView,
        propName,
        value,
        renderer,
        sanitizer,
        nativeOnly
      ) {
        const element = getNativeByTNode(tNode, lView);
        let dataValue,
          inputData = tNode.inputs;
        var name;
        !nativeOnly && null != inputData && (dataValue = inputData[propName])
          ? (setInputsForProperty(tView, lView, dataValue, propName, value),
            isComponentHost(tNode) &&
              (function(lView, viewIndex) {
                const childComponentLView = getComponentLViewByIndex(
                  viewIndex,
                  lView
                );
                16 & childComponentLView[2] || (childComponentLView[2] |= 64);
              })(lView, tNode.index))
          : 3 === tNode.type &&
            ((propName =
              'class' === (name = propName)
                ? 'className'
                : 'for' === name
                ? 'htmlFor'
                : 'formaction' === name
                ? 'formAction'
                : 'innerHtml' === name
                ? 'innerHTML'
                : 'readonly' === name
                ? 'readOnly'
                : 'tabindex' === name
                ? 'tabIndex'
                : name),
            (value =
              null != sanitizer
                ? sanitizer(value, tNode.tagName || '', propName)
                : value),
            isProceduralRenderer(renderer)
              ? renderer.setProperty(element, propName, value)
              : isAnimationProp(propName) ||
                (element.setProperty
                  ? element.setProperty(propName, value)
                  : (element[propName] = value)));
      }
      function resolveDirectives(tView, lView, tNode, localRefs) {
        let hasDirectives = !1;
        if (getBindingsEnabled()) {
          const directiveDefs = (function(tView, viewData, tNode) {
              const registry = tView.directiveRegistry;
              let matches = null;
              if (registry)
                for (let i = 0; i < registry.length; i++) {
                  const def = registry[i];
                  isNodeMatchingSelectorList(tNode, def.selectors, !1) &&
                    (matches || (matches = []),
                    diPublicInInjector(
                      getOrCreateNodeInjectorForNode(tNode, viewData),
                      tView,
                      def.type
                    ),
                    isComponentDef(def)
                      ? (2 & tNode.flags && throwMultipleComponentError(tNode),
                        markAsComponentHost(tView, tNode),
                        matches.unshift(def))
                      : matches.push(def));
                }
              return matches;
            })(tView, lView, tNode),
            exportsMap = null === localRefs ? null : { '': -1 };
          if (null !== directiveDefs) {
            let totalDirectiveHostVars = 0;
            (hasDirectives = !0),
              initTNodeFlags(tNode, tView.data.length, directiveDefs.length);
            for (let i = 0; i < directiveDefs.length; i++) {
              const def = directiveDefs[i];
              def.providersResolver && def.providersResolver(def);
            }
            generateExpandoInstructionBlock(tView, tNode, directiveDefs.length);
            let preOrderHooksFound = !1,
              preOrderCheckHooksFound = !1;
            for (let i = 0; i < directiveDefs.length; i++) {
              const def = directiveDefs[i];
              (tNode.mergedAttrs = mergeHostAttrs(
                tNode.mergedAttrs,
                def.hostAttrs
              )),
                baseResolveDirective(tView, lView, def),
                saveNameToExportMap(tView.data.length - 1, def, exportsMap),
                null !== def.contentQueries && (tNode.flags |= 8),
                (null === def.hostBindings &&
                  null === def.hostAttrs &&
                  0 === def.hostVars) ||
                  (tNode.flags |= 128),
                !preOrderHooksFound &&
                  (def.onChanges || def.onInit || def.doCheck) &&
                  ((tView.preOrderHooks || (tView.preOrderHooks = [])).push(
                    tNode.index - 20
                  ),
                  (preOrderHooksFound = !0)),
                preOrderCheckHooksFound ||
                  (!def.onChanges && !def.doCheck) ||
                  ((
                    tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])
                  ).push(tNode.index - 20),
                  (preOrderCheckHooksFound = !0)),
                addHostBindingsToExpandoInstructions(tView, def),
                (totalDirectiveHostVars += def.hostVars);
            }
            !(function(tView, tNode) {
              const end = tNode.directiveEnd,
                defs = tView.data,
                tNodeAttrs = tNode.attrs,
                inputsFromAttrs = [];
              let inputsStore = null,
                outputsStore = null;
              for (let i = tNode.directiveStart; i < end; i++) {
                const directiveDef = defs[i],
                  directiveInputs = directiveDef.inputs,
                  initialInputs =
                    null === tNodeAttrs || isInlineTemplate(tNode)
                      ? null
                      : generateInitialInputs(directiveInputs, tNodeAttrs);
                inputsFromAttrs.push(initialInputs),
                  (inputsStore = generatePropertyAliases(
                    directiveInputs,
                    i,
                    inputsStore
                  )),
                  (outputsStore = generatePropertyAliases(
                    directiveDef.outputs,
                    i,
                    outputsStore
                  ));
              }
              null !== inputsStore &&
                (inputsStore.hasOwnProperty('class') && (tNode.flags |= 16),
                inputsStore.hasOwnProperty('style') && (tNode.flags |= 32)),
                (tNode.initialInputs = inputsFromAttrs),
                (tNode.inputs = inputsStore),
                (tNode.outputs = outputsStore);
            })(tView, tNode),
              growHostVarsSpace(tView, lView, totalDirectiveHostVars);
          }
          exportsMap &&
            (function(tNode, localRefs, exportsMap) {
              if (localRefs) {
                const localNames = (tNode.localNames = []);
                for (let i = 0; i < localRefs.length; i += 2) {
                  const index = exportsMap[localRefs[i + 1]];
                  if (null == index)
                    throw new Error(
                      `Export of name '${localRefs[i + 1]}' not found!`
                    );
                  localNames.push(localRefs[i], index);
                }
              }
            })(tNode, localRefs, exportsMap);
        }
        return (
          (tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs)),
          hasDirectives
        );
      }
      function addHostBindingsToExpandoInstructions(tView, def) {
        const expando = tView.expandoInstructions;
        expando.push(def.hostBindings),
          0 !== def.hostVars && expando.push(def.hostVars);
      }
      function growHostVarsSpace(tView, lView, count) {
        for (let i = 0; i < count; i++)
          lView.push(NO_CHANGE),
            tView.blueprint.push(NO_CHANGE),
            tView.data.push(null);
      }
      function invokeHostBindingsInCreationMode(def, directive) {
        null !== def.hostBindings && def.hostBindings(1, directive);
      }
      function generateExpandoInstructionBlock(tView, tNode, directiveCount) {
        const elementIndex = 20 - tNode.index,
          providerCount = tView.data.length - (65535 & tNode.providerIndexes);
        (tView.expandoInstructions || (tView.expandoInstructions = [])).push(
          elementIndex,
          providerCount,
          directiveCount
        );
      }
      function markAsComponentHost(tView, hostTNode) {
        (hostTNode.flags |= 2),
          (tView.components || (tView.components = [])).push(hostTNode.index);
      }
      function saveNameToExportMap(index, def, exportsMap) {
        if (exportsMap) {
          if (def.exportAs)
            for (let i = 0; i < def.exportAs.length; i++)
              exportsMap[def.exportAs[i]] = index;
          isComponentDef(def) && (exportsMap[''] = index);
        }
      }
      function initTNodeFlags(tNode, index, numberOfDirectives) {
        (tNode.flags |= 1),
          (tNode.directiveStart = index),
          (tNode.directiveEnd = index + numberOfDirectives),
          (tNode.providerIndexes = index);
      }
      function baseResolveDirective(tView, viewData, def) {
        tView.data.push(def);
        const directiveFactory =
            def.factory || (def.factory = getFactoryDef(def.type)),
          nodeInjectorFactory = new NodeInjectorFactory(
            directiveFactory,
            isComponentDef(def),
            null
          );
        tView.blueprint.push(nodeInjectorFactory),
          viewData.push(nodeInjectorFactory);
      }
      function addComponentLogic(lView, hostTNode, def) {
        const native = getNativeByTNode(hostTNode, lView),
          tView = getOrCreateTComponentView(def),
          rendererFactory = lView[10],
          componentView = addToViewTree(
            lView,
            createLView(
              lView,
              tView,
              null,
              def.onPush ? 64 : 16,
              native,
              hostTNode,
              rendererFactory,
              rendererFactory.createRenderer(native, def)
            )
          );
        lView[hostTNode.index] = componentView;
      }
      function elementAttributeInternal(
        tNode,
        lView,
        name,
        value,
        sanitizer,
        namespace
      ) {
        const element = getNativeByTNode(tNode, lView),
          renderer = lView[11];
        if (null == value)
          isProceduralRenderer(renderer)
            ? renderer.removeAttribute(element, name, namespace)
            : element.removeAttribute(name);
        else {
          const strValue =
            null == sanitizer
              ? renderStringify(value)
              : sanitizer(value, tNode.tagName || '', name);
          isProceduralRenderer(renderer)
            ? renderer.setAttribute(element, name, strValue, namespace)
            : namespace
            ? element.setAttributeNS(namespace, name, strValue)
            : element.setAttribute(name, strValue);
        }
      }
      function setInputsFromAttrs(
        lView,
        directiveIndex,
        instance,
        def,
        tNode,
        initialInputData
      ) {
        const initialInputs = initialInputData[directiveIndex];
        if (null !== initialInputs) {
          const setInput = def.setInput;
          for (let i = 0; i < initialInputs.length; ) {
            const publicName = initialInputs[i++],
              privateName = initialInputs[i++],
              value = initialInputs[i++];
            null !== setInput
              ? def.setInput(instance, value, publicName, privateName)
              : (instance[privateName] = value);
          }
        }
      }
      function generateInitialInputs(inputs, attrs) {
        let inputsToStore = null,
          i = 0;
        for (; i < attrs.length; ) {
          const attrName = attrs[i];
          if (0 !== attrName)
            if (5 !== attrName) {
              if ('number' == typeof attrName) break;
              inputs.hasOwnProperty(attrName) &&
                (null === inputsToStore && (inputsToStore = []),
                inputsToStore.push(attrName, inputs[attrName], attrs[i + 1])),
                (i += 2);
            } else i += 2;
          else i += 4;
        }
        return inputsToStore;
      }
      function createLContainer(hostNative, currentView, native, tNode) {
        return new Array(
          hostNative,
          !0,
          !1,
          currentView,
          null,
          0,
          tNode,
          native,
          null,
          null
        );
      }
      function refreshComponent(hostLView, componentHostIdx) {
        const componentView = getComponentLViewByIndex(
          componentHostIdx,
          hostLView
        );
        if (viewAttachedToChangeDetector(componentView)) {
          const tView = componentView[1];
          80 & componentView[2]
            ? refreshView(
                tView,
                componentView,
                tView.template,
                componentView[8]
              )
            : componentView[5] > 0 &&
              (function refreshContainsDirtyView(lView) {
                for (
                  let lContainer = getFirstLContainer(lView);
                  null !== lContainer;
                  lContainer = getNextLContainer(lContainer)
                )
                  for (let i = 10; i < lContainer.length; i++) {
                    const embeddedLView = lContainer[i];
                    if (1024 & embeddedLView[2]) {
                      const embeddedTView = embeddedLView[1];
                      refreshView(
                        embeddedTView,
                        embeddedLView,
                        embeddedTView.template,
                        embeddedLView[8]
                      );
                    } else
                      embeddedLView[5] > 0 &&
                        refreshContainsDirtyView(embeddedLView);
                  }
                const components = lView[1].components;
                if (null !== components)
                  for (let i = 0; i < components.length; i++) {
                    const componentView = getComponentLViewByIndex(
                      components[i],
                      lView
                    );
                    viewAttachedToChangeDetector(componentView) &&
                      componentView[5] > 0 &&
                      refreshContainsDirtyView(componentView);
                  }
              })(componentView);
        }
      }
      function renderComponent(hostLView, componentHostIdx) {
        const componentView = getComponentLViewByIndex(
            componentHostIdx,
            hostLView
          ),
          componentTView = componentView[1];
        !(function(tView, lView) {
          for (let i = lView.length; i < tView.blueprint.length; i++)
            lView.push(tView.blueprint[i]);
        })(componentTView, componentView),
          renderView(componentTView, componentView, componentView[8]);
      }
      function addToViewTree(lView, lViewOrLContainer) {
        return (
          lView[13]
            ? (lView[14][4] = lViewOrLContainer)
            : (lView[13] = lViewOrLContainer),
          (lView[14] = lViewOrLContainer),
          lViewOrLContainer
        );
      }
      function markViewDirty(lView) {
        for (; lView; ) {
          lView[2] |= 64;
          const parent = getLViewParent(lView);
          if (isRootView(lView) && !parent) return lView;
          lView = parent;
        }
        return null;
      }
      function detectChangesInternal(tView, lView, context) {
        const rendererFactory = lView[10];
        rendererFactory.begin && rendererFactory.begin();
        try {
          refreshView(tView, lView, tView.template, context);
        } catch (error) {
          throw (handleError(lView, error), error);
        } finally {
          rendererFactory.end && rendererFactory.end();
        }
      }
      function detectChangesInRootView(lView) {
        !(function(rootContext) {
          for (let i = 0; i < rootContext.components.length; i++) {
            const rootComponent = rootContext.components[i],
              lView = readPatchedLView(rootComponent),
              tView = lView[1];
            renderComponentOrTemplate(
              tView,
              lView,
              tView.template,
              rootComponent
            );
          }
        })(lView[8]);
      }
      function executeViewQueryFn(flags, viewQueryFn, component) {
        setCurrentQueryIndex(0), viewQueryFn(flags, component);
      }
      const CLEAN_PROMISE = (() => Promise.resolve(null))();
      function getLCleanup(view) {
        return view[7] || (view[7] = []);
      }
      function handleError(lView, error) {
        const injector = lView[9],
          errorHandler = injector ? injector.get(ErrorHandler, null) : null;
        errorHandler && errorHandler.handleError(error);
      }
      function setInputsForProperty(tView, lView, inputs, publicName, value) {
        for (let i = 0; i < inputs.length; ) {
          const index = inputs[i++],
            privateName = inputs[i++],
            instance = lView[index],
            def = tView.data[index];
          null !== def.setInput
            ? def.setInput(instance, value, publicName, privateName)
            : (instance[privateName] = value);
        }
      }
      function textBindingInternal(lView, index, value) {
        const element = getNativeByIndex(index, lView),
          renderer = lView[11];
        isProceduralRenderer(renderer)
          ? renderer.setValue(element, value)
          : (element.textContent = value);
      }
      function getLContainer(tNode, embeddedView) {
        const container = embeddedView[3];
        return -1 === tNode.index
          ? isLContainer(container)
            ? container
            : null
          : container;
      }
      function getContainerRenderParent(tViewNode, view) {
        const container = getLContainer(tViewNode, view);
        return container ? nativeParentNode(view[11], container[7]) : null;
      }
      function applyToElementOrContainer(
        action,
        renderer,
        parent,
        lNodeToHandle,
        beforeNode
      ) {
        if (null != lNodeToHandle) {
          let lContainer,
            isComponent = !1;
          isLContainer(lNodeToHandle)
            ? (lContainer = lNodeToHandle)
            : isLView(lNodeToHandle) &&
              ((isComponent = !0), (lNodeToHandle = lNodeToHandle[0]));
          const rNode = unwrapRNode(lNodeToHandle);
          0 === action && null !== parent
            ? null == beforeNode
              ? nativeAppendChild(renderer, parent, rNode)
              : nativeInsertBefore(renderer, parent, rNode, beforeNode || null)
            : 1 === action && null !== parent
            ? nativeInsertBefore(renderer, parent, rNode, beforeNode || null)
            : 2 === action
            ? nativeRemoveNode(renderer, rNode, isComponent)
            : 3 === action && renderer.destroyNode(rNode),
            null != lContainer &&
              (function(
                renderer,
                action,
                lContainer,
                renderParent,
                beforeNode
              ) {
                const anchor = lContainer[7];
                anchor !== unwrapRNode(lContainer) &&
                  applyToElementOrContainer(
                    action,
                    renderer,
                    renderParent,
                    anchor,
                    beforeNode
                  );
                for (let i = 10; i < lContainer.length; i++) {
                  const lView = lContainer[i];
                  applyView(
                    lView[1],
                    lView,
                    renderer,
                    action,
                    renderParent,
                    anchor
                  );
                }
              })(renderer, action, lContainer, parent, beforeNode);
        }
      }
      function createTextNode(value, renderer) {
        return isProceduralRenderer(renderer)
          ? renderer.createText(value)
          : renderer.createTextNode(value);
      }
      function addRemoveViewFromContainer(
        tView,
        lView,
        insertMode,
        beforeNode
      ) {
        const renderParent = getContainerRenderParent(tView.node, lView);
        renderParent &&
          applyView(
            tView,
            lView,
            lView[11],
            insertMode ? 1 : 2,
            renderParent,
            beforeNode
          );
      }
      function detachMovedView(declarationContainer, lView) {
        const movedViews = declarationContainer[9],
          declarationViewIndex = movedViews.indexOf(lView);
        1024 & lView[2] && updateTransplantedViewCount(lView[3], -1),
          movedViews.splice(declarationViewIndex, 1);
      }
      function detachView(lContainer, removeIndex) {
        if (lContainer.length <= 10) return;
        const indexInContainer = 10 + removeIndex,
          viewToDetach = lContainer[indexInContainer];
        if (viewToDetach) {
          const declarationLContainer = viewToDetach[17];
          null !== declarationLContainer &&
            declarationLContainer !== lContainer &&
            detachMovedView(declarationLContainer, viewToDetach),
            removeIndex > 0 &&
              (lContainer[indexInContainer - 1][4] = viewToDetach[4]);
          const removedLView = removeFromArray(lContainer, 10 + removeIndex);
          addRemoveViewFromContainer(viewToDetach[1], viewToDetach, !1, null);
          const lQueries = removedLView[19];
          null !== lQueries && lQueries.detachView(removedLView[1]),
            (viewToDetach[3] = null),
            (viewToDetach[4] = null),
            (viewToDetach[2] &= -129);
        }
        return viewToDetach;
      }
      function destroyLView(tView, lView) {
        if (!(256 & lView[2])) {
          const renderer = lView[11];
          isProceduralRenderer(renderer) &&
            renderer.destroyNode &&
            applyView(tView, lView, renderer, 3, null, null),
            (function(rootView) {
              let lViewOrLContainer = rootView[13];
              if (!lViewOrLContainer) return cleanUpView(rootView[1], rootView);
              for (; lViewOrLContainer; ) {
                let next = null;
                if (isLView(lViewOrLContainer)) next = lViewOrLContainer[13];
                else {
                  const firstView = lViewOrLContainer[10];
                  firstView && (next = firstView);
                }
                if (!next) {
                  for (
                    ;
                    lViewOrLContainer &&
                    !lViewOrLContainer[4] &&
                    lViewOrLContainer !== rootView;

                  )
                    isLView(lViewOrLContainer) &&
                      cleanUpView(lViewOrLContainer[1], lViewOrLContainer),
                      (lViewOrLContainer = getParentState(
                        lViewOrLContainer,
                        rootView
                      ));
                  null === lViewOrLContainer && (lViewOrLContainer = rootView),
                    isLView(lViewOrLContainer) &&
                      cleanUpView(lViewOrLContainer[1], lViewOrLContainer),
                    (next = lViewOrLContainer && lViewOrLContainer[4]);
                }
                lViewOrLContainer = next;
              }
            })(lView);
        }
      }
      function getParentState(lViewOrLContainer, rootView) {
        let tNode;
        return isLView(lViewOrLContainer) &&
          (tNode = lViewOrLContainer[6]) &&
          2 === tNode.type
          ? getLContainer(tNode, lViewOrLContainer)
          : lViewOrLContainer[3] === rootView
          ? null
          : lViewOrLContainer[3];
      }
      function cleanUpView(tView, lView) {
        if (!(256 & lView[2])) {
          (lView[2] &= -129),
            (lView[2] |= 256),
            (function(tView, lView) {
              let destroyHooks;
              if (null != tView && null != (destroyHooks = tView.destroyHooks))
                for (let i = 0; i < destroyHooks.length; i += 2) {
                  const context = lView[destroyHooks[i]];
                  if (!(context instanceof NodeInjectorFactory)) {
                    const toCall = destroyHooks[i + 1];
                    if (Array.isArray(toCall))
                      for (let j = 0; j < toCall.length; j += 2)
                        toCall[j + 1].call(context[toCall[j]]);
                    else toCall.call(context);
                  }
                }
            })(tView, lView),
            (function(tView, lView) {
              const tCleanup = tView.cleanup;
              if (null !== tCleanup) {
                const lCleanup = lView[7];
                for (let i = 0; i < tCleanup.length - 1; i += 2)
                  if ('string' == typeof tCleanup[i]) {
                    const idxOrTargetGetter = tCleanup[i + 1],
                      target =
                        'function' == typeof idxOrTargetGetter
                          ? idxOrTargetGetter(lView)
                          : unwrapRNode(lView[idxOrTargetGetter]),
                      listener = lCleanup[tCleanup[i + 2]],
                      useCaptureOrSubIdx = tCleanup[i + 3];
                    'boolean' == typeof useCaptureOrSubIdx
                      ? target.removeEventListener(
                          tCleanup[i],
                          listener,
                          useCaptureOrSubIdx
                        )
                      : useCaptureOrSubIdx >= 0
                      ? lCleanup[useCaptureOrSubIdx]()
                      : lCleanup[-useCaptureOrSubIdx].unsubscribe(),
                      (i += 2);
                  } else tCleanup[i].call(lCleanup[tCleanup[i + 1]]);
                lView[7] = null;
              }
            })(tView, lView);
          const hostTNode = lView[6];
          hostTNode &&
            3 === hostTNode.type &&
            isProceduralRenderer(lView[11]) &&
            lView[11].destroy();
          const declarationContainer = lView[17];
          if (null !== declarationContainer && isLContainer(lView[3])) {
            declarationContainer !== lView[3] &&
              detachMovedView(declarationContainer, lView);
            const lQueries = lView[19];
            null !== lQueries && lQueries.detachView(tView);
          }
        }
      }
      function getRenderParent(tView, tNode, currentView) {
        let parentTNode = tNode.parent;
        for (
          ;
          null != parentTNode &&
          (4 === parentTNode.type || 5 === parentTNode.type);

        )
          parentTNode = (tNode = parentTNode).parent;
        if (null == parentTNode) {
          const hostTNode = currentView[6];
          return 2 === hostTNode.type
            ? getContainerRenderParent(hostTNode, currentView)
            : currentView[0];
        }
        if (tNode && 5 === tNode.type && 4 & tNode.flags)
          return getNativeByTNode(tNode, currentView).parentNode;
        if (2 & parentTNode.flags) {
          const tData = tView.data,
            encapsulation =
              tData[tData[parentTNode.index].directiveStart].encapsulation;
          if (
            encapsulation !== ViewEncapsulation$1.ShadowDom &&
            encapsulation !== ViewEncapsulation$1.Native
          )
            return null;
        }
        return getNativeByTNode(parentTNode, currentView);
      }
      function nativeInsertBefore(renderer, parent, child, beforeNode) {
        isProceduralRenderer(renderer)
          ? renderer.insertBefore(parent, child, beforeNode)
          : parent.insertBefore(child, beforeNode, !0);
      }
      function nativeAppendChild(renderer, parent, child) {
        isProceduralRenderer(renderer)
          ? renderer.appendChild(parent, child)
          : parent.appendChild(child);
      }
      function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode) {
        null !== beforeNode
          ? nativeInsertBefore(renderer, parent, child, beforeNode)
          : nativeAppendChild(renderer, parent, child);
      }
      function nativeParentNode(renderer, node) {
        return isProceduralRenderer(renderer)
          ? renderer.parentNode(node)
          : node.parentNode;
      }
      function getNativeAnchorNode(parentTNode, lView) {
        if (2 === parentTNode.type) {
          const lContainer = getLContainer(parentTNode, lView);
          return null === lContainer
            ? null
            : getBeforeNodeForView(
                lContainer.indexOf(lView, 10) - 10,
                lContainer
              );
        }
        return 4 === parentTNode.type || 5 === parentTNode.type
          ? getNativeByTNode(parentTNode, lView)
          : null;
      }
      function appendChild(tView, lView, childEl, childTNode) {
        const renderParent = getRenderParent(tView, childTNode, lView);
        if (null != renderParent) {
          const renderer = lView[11],
            anchorNode = getNativeAnchorNode(
              childTNode.parent || lView[6],
              lView
            );
          if (Array.isArray(childEl))
            for (let i = 0; i < childEl.length; i++)
              nativeAppendOrInsertBefore(
                renderer,
                renderParent,
                childEl[i],
                anchorNode
              );
          else
            nativeAppendOrInsertBefore(
              renderer,
              renderParent,
              childEl,
              anchorNode
            );
        }
      }
      function getBeforeNodeForView(viewIndexInContainer, lContainer) {
        const nextViewIndex = 10 + viewIndexInContainer + 1;
        if (nextViewIndex < lContainer.length) {
          const lView = lContainer[nextViewIndex],
            firstTNodeOfView = lView[1].firstChild;
          if (null !== firstTNodeOfView)
            return (function getFirstNativeNode(lView, tNode) {
              if (null !== tNode) {
                const tNodeType = tNode.type;
                if (3 === tNodeType) return getNativeByTNode(tNode, lView);
                if (0 === tNodeType)
                  return getBeforeNodeForView(-1, lView[tNode.index]);
                if (4 === tNodeType || 5 === tNodeType) {
                  const elIcuContainerChild = tNode.child;
                  if (null !== elIcuContainerChild)
                    return getFirstNativeNode(lView, elIcuContainerChild);
                  {
                    const rNodeOrLContainer = lView[tNode.index];
                    return isLContainer(rNodeOrLContainer)
                      ? getBeforeNodeForView(-1, rNodeOrLContainer)
                      : unwrapRNode(rNodeOrLContainer);
                  }
                }
                {
                  const componentView = lView[16],
                    componentHost = componentView[6],
                    parentView = getLViewParent(componentView),
                    firstProjectedTNode =
                      componentHost.projection[tNode.projection];
                  return null != firstProjectedTNode
                    ? getFirstNativeNode(parentView, firstProjectedTNode)
                    : getFirstNativeNode(lView, tNode.next);
                }
              }
              return null;
            })(lView, firstTNodeOfView);
        }
        return lContainer[7];
      }
      function nativeRemoveNode(renderer, rNode, isHostElement) {
        const nativeParent = nativeParentNode(renderer, rNode);
        nativeParent &&
          (function(renderer, parent, child, isHostElement) {
            isProceduralRenderer(renderer)
              ? renderer.removeChild(parent, child, isHostElement)
              : parent.removeChild(child);
          })(renderer, nativeParent, rNode, isHostElement);
      }
      function applyNodes(
        renderer,
        action,
        tNode,
        lView,
        renderParent,
        beforeNode,
        isProjection
      ) {
        for (; null != tNode; ) {
          const rawSlotValue = lView[tNode.index],
            tNodeType = tNode.type;
          isProjection &&
            0 === action &&
            (rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView),
            (tNode.flags |= 4)),
            64 != (64 & tNode.flags) &&
              (4 === tNodeType || 5 === tNodeType
                ? (applyNodes(
                    renderer,
                    action,
                    tNode.child,
                    lView,
                    renderParent,
                    beforeNode,
                    !1
                  ),
                  applyToElementOrContainer(
                    action,
                    renderer,
                    renderParent,
                    rawSlotValue,
                    beforeNode
                  ))
                : 1 === tNodeType
                ? applyProjectionRecursive(
                    renderer,
                    action,
                    lView,
                    tNode,
                    renderParent,
                    beforeNode
                  )
                : applyToElementOrContainer(
                    action,
                    renderer,
                    renderParent,
                    rawSlotValue,
                    beforeNode
                  )),
            (tNode = isProjection ? tNode.projectionNext : tNode.next);
        }
      }
      function applyView(
        tView,
        lView,
        renderer,
        action,
        renderParent,
        beforeNode
      ) {
        applyNodes(
          renderer,
          action,
          tView.node.child,
          lView,
          renderParent,
          beforeNode,
          !1
        );
      }
      function applyProjection(tView, lView, tProjectionNode) {
        applyProjectionRecursive(
          lView[11],
          0,
          lView,
          tProjectionNode,
          getRenderParent(tView, tProjectionNode, lView),
          getNativeAnchorNode(tProjectionNode.parent || lView[6], lView)
        );
      }
      function applyProjectionRecursive(
        renderer,
        action,
        lView,
        tProjectionNode,
        renderParent,
        beforeNode
      ) {
        const componentLView = lView[16],
          nodeToProjectOrRNodes =
            componentLView[6].projection[tProjectionNode.projection];
        if (Array.isArray(nodeToProjectOrRNodes))
          for (let i = 0; i < nodeToProjectOrRNodes.length; i++)
            applyToElementOrContainer(
              action,
              renderer,
              renderParent,
              nodeToProjectOrRNodes[i],
              beforeNode
            );
        else
          applyNodes(
            renderer,
            action,
            nodeToProjectOrRNodes,
            componentLView[3],
            renderParent,
            beforeNode,
            !0
          );
      }
      function writeDirectStyle(renderer, element, newValue) {
        isProceduralRenderer(renderer)
          ? renderer.setAttribute(element, 'style', newValue)
          : (element.style.cssText = newValue);
      }
      function writeDirectClass(renderer, element, newValue) {
        isProceduralRenderer(renderer)
          ? '' === newValue
            ? renderer.removeAttribute(element, 'class')
            : renderer.setAttribute(element, 'class', newValue)
          : (element.className = newValue);
      }
      class ViewRef {
        constructor(_lView, _cdRefInjectingView) {
          (this._lView = _lView),
            (this._cdRefInjectingView = _cdRefInjectingView),
            (this._appRef = null),
            (this._viewContainerRef = null);
        }
        get rootNodes() {
          const lView = this._lView;
          return null == lView[0]
            ? (function collectNativeNodes(
                tView,
                lView,
                tNode,
                result,
                isProjection = !1
              ) {
                for (; null !== tNode; ) {
                  const lNode = lView[tNode.index];
                  if (
                    (null !== lNode && result.push(unwrapRNode(lNode)),
                    isLContainer(lNode))
                  )
                    for (let i = 10; i < lNode.length; i++) {
                      const lViewInAContainer = lNode[i],
                        lViewFirstChildTNode = lViewInAContainer[1].firstChild;
                      null !== lViewFirstChildTNode &&
                        collectNativeNodes(
                          lViewInAContainer[1],
                          lViewInAContainer,
                          lViewFirstChildTNode,
                          result
                        );
                    }
                  const tNodeType = tNode.type;
                  if (4 === tNodeType || 5 === tNodeType)
                    collectNativeNodes(tView, lView, tNode.child, result);
                  else if (1 === tNodeType) {
                    const componentView = lView[16],
                      nodesInSlot =
                        componentView[6].projection[tNode.projection];
                    if (Array.isArray(nodesInSlot)) result.push(...nodesInSlot);
                    else {
                      const parentView = getLViewParent(componentView);
                      collectNativeNodes(
                        parentView[1],
                        parentView,
                        nodesInSlot,
                        result,
                        !0
                      );
                    }
                  }
                  tNode = isProjection ? tNode.projectionNext : tNode.next;
                }
                return result;
              })(lView[1], lView, lView[6].child, [])
            : [];
        }
        get context() {
          return this._lView[8];
        }
        get destroyed() {
          return 256 == (256 & this._lView[2]);
        }
        destroy() {
          if (this._appRef) this._appRef.detachView(this);
          else if (this._viewContainerRef) {
            const index = this._viewContainerRef.indexOf(this);
            index > -1 && this._viewContainerRef.detach(index),
              (this._viewContainerRef = null);
          }
          destroyLView(this._lView[1], this._lView);
        }
        onDestroy(callback) {
          storeCleanupWithContext(this._lView[1], this._lView, null, callback);
        }
        markForCheck() {
          markViewDirty(this._cdRefInjectingView || this._lView);
        }
        detach() {
          this._lView[2] &= -129;
        }
        reattach() {
          this._lView[2] |= 128;
        }
        detectChanges() {
          detectChangesInternal(this._lView[1], this._lView, this.context);
        }
        checkNoChanges() {
          !(function(tView, view, context) {
            setCheckNoChangesMode(!0);
            try {
              detectChangesInternal(tView, view, context);
            } finally {
              setCheckNoChangesMode(!1);
            }
          })(this._lView[1], this._lView, this.context);
        }
        attachToViewContainerRef(vcRef) {
          if (this._appRef)
            throw new Error(
              'This view is already attached directly to the ApplicationRef!'
            );
          this._viewContainerRef = vcRef;
        }
        detachFromAppRef() {
          var lView;
          (this._appRef = null),
            applyView(
              this._lView[1],
              (lView = this._lView),
              lView[11],
              2,
              null,
              null
            );
        }
        attachToAppRef(appRef) {
          if (this._viewContainerRef)
            throw new Error(
              'This view is already attached to a ViewContainer!'
            );
          this._appRef = appRef;
        }
      }
      class RootViewRef extends ViewRef {
        constructor(_view) {
          super(_view), (this._view = _view);
        }
        detectChanges() {
          detectChangesInRootView(this._view);
        }
        checkNoChanges() {
          !(function(lView) {
            setCheckNoChangesMode(!0);
            try {
              detectChangesInRootView(lView);
            } finally {
              setCheckNoChangesMode(!1);
            }
          })(this._view);
        }
        get context() {
          return null;
        }
      }
      let R3ElementRef, R3TemplateRef, R3ViewContainerRef;
      function createElementRef(ElementRefToken, tNode, view) {
        return (
          R3ElementRef || (R3ElementRef = class extends ElementRefToken {}),
          new R3ElementRef(getNativeByTNode(tNode, view))
        );
      }
      function createTemplateRef(
        TemplateRefToken,
        ElementRefToken,
        hostTNode,
        hostView
      ) {
        return (
          R3TemplateRef ||
            (R3TemplateRef = class extends TemplateRefToken {
              constructor(
                _declarationView,
                _declarationTContainer,
                elementRef
              ) {
                super(),
                  (this._declarationView = _declarationView),
                  (this._declarationTContainer = _declarationTContainer),
                  (this.elementRef = elementRef);
              }
              createEmbeddedView(context) {
                const embeddedTView = this._declarationTContainer.tViews,
                  embeddedLView = createLView(
                    this._declarationView,
                    embeddedTView,
                    context,
                    16,
                    null,
                    embeddedTView.node
                  );
                embeddedLView[17] = this._declarationView[
                  this._declarationTContainer.index
                ];
                const declarationViewLQueries = this._declarationView[19];
                return (
                  null !== declarationViewLQueries &&
                    (embeddedLView[19] = declarationViewLQueries.createEmbeddedView(
                      embeddedTView
                    )),
                  renderView(embeddedTView, embeddedLView, context),
                  new ViewRef(embeddedLView)
                );
              }
            }),
          0 === hostTNode.type
            ? new R3TemplateRef(
                hostView,
                hostTNode,
                createElementRef(ElementRefToken, hostTNode, hostView)
              )
            : null
        );
      }
      function createContainerRef(
        ViewContainerRefToken,
        ElementRefToken,
        hostTNode,
        hostView
      ) {
        let lContainer;
        R3ViewContainerRef ||
          (R3ViewContainerRef = class extends ViewContainerRefToken {
            constructor(_lContainer, _hostTNode, _hostView) {
              super(),
                (this._lContainer = _lContainer),
                (this._hostTNode = _hostTNode),
                (this._hostView = _hostView);
            }
            get element() {
              return createElementRef(
                ElementRefToken,
                this._hostTNode,
                this._hostView
              );
            }
            get injector() {
              return new NodeInjector(this._hostTNode, this._hostView);
            }
            get parentInjector() {
              const parentLocation = getParentInjectorLocation(
                  this._hostTNode,
                  this._hostView
                ),
                parentView = getParentInjectorView(
                  parentLocation,
                  this._hostView
                ),
                parentTNode = (function(location, startView, startTNode) {
                  if (
                    startTNode.parent &&
                    -1 !== startTNode.parent.injectorIndex
                  ) {
                    const injectorIndex = startTNode.parent.injectorIndex;
                    let tNode = startTNode.parent;
                    for (
                      ;
                      null != tNode.parent &&
                      injectorIndex == tNode.parent.injectorIndex;

                    )
                      tNode = tNode.parent;
                    return tNode;
                  }
                  let viewOffset = getParentInjectorViewOffset(location),
                    parentView = startView,
                    parentTNode = startView[6];
                  for (; viewOffset > 1; )
                    (parentView = parentView[15]),
                      (parentTNode = parentView[6]),
                      viewOffset--;
                  return parentTNode;
                })(parentLocation, this._hostView, this._hostTNode);
              return hasParentInjector(parentLocation) && null != parentTNode
                ? new NodeInjector(parentTNode, parentView)
                : new NodeInjector(null, this._hostView);
            }
            clear() {
              for (; this.length > 0; ) this.remove(this.length - 1);
            }
            get(index) {
              return (
                (null !== this._lContainer[8] && this._lContainer[8][index]) ||
                null
              );
            }
            get length() {
              return this._lContainer.length - 10;
            }
            createEmbeddedView(templateRef, context, index) {
              const viewRef = templateRef.createEmbeddedView(context || {});
              return this.insert(viewRef, index), viewRef;
            }
            createComponent(
              componentFactory,
              index,
              injector,
              projectableNodes,
              ngModuleRef
            ) {
              const contextInjector = injector || this.parentInjector;
              if (
                !ngModuleRef &&
                null == componentFactory.ngModule &&
                contextInjector
              ) {
                const result = contextInjector.get(NgModuleRef, null);
                result && (ngModuleRef = result);
              }
              const componentRef = componentFactory.create(
                contextInjector,
                projectableNodes,
                void 0,
                ngModuleRef
              );
              return this.insert(componentRef.hostView, index), componentRef;
            }
            insert(viewRef, index) {
              const lView = viewRef._lView,
                tView = lView[1];
              if (viewRef.destroyed)
                throw new Error(
                  'Cannot insert a destroyed View in a ViewContainer!'
                );
              if ((this.allocateContainerIfNeeded(), isLContainer(lView[3]))) {
                const prevIdx = this.indexOf(viewRef);
                if (-1 !== prevIdx) this.detach(prevIdx);
                else {
                  const prevLContainer = lView[3],
                    prevVCRef = new R3ViewContainerRef(
                      prevLContainer,
                      prevLContainer[6],
                      prevLContainer[3]
                    );
                  prevVCRef.detach(prevVCRef.indexOf(viewRef));
                }
              }
              const adjustedIdx = this._adjustIndex(index);
              return (
                (function(tView, lView, lContainer, index) {
                  const indexInContainer = 10 + index,
                    containerLength = lContainer.length;
                  index > 0 && (lContainer[indexInContainer - 1][4] = lView),
                    index < containerLength - 10
                      ? ((lView[4] = lContainer[indexInContainer]),
                        addToArray(lContainer, 10 + index, lView))
                      : (lContainer.push(lView), (lView[4] = null)),
                    (lView[3] = lContainer);
                  const declarationLContainer = lView[17];
                  null !== declarationLContainer &&
                    lContainer !== declarationLContainer &&
                    (function(declarationContainer, lView) {
                      const movedViews = declarationContainer[9];
                      lView[16] !== lView[3][3][16] &&
                        (declarationContainer[2] = !0),
                        null === movedViews
                          ? (declarationContainer[9] = [lView])
                          : movedViews.push(lView);
                    })(declarationLContainer, lView);
                  const lQueries = lView[19];
                  null !== lQueries && lQueries.insertView(tView),
                    (lView[2] |= 128);
                })(tView, lView, this._lContainer, adjustedIdx),
                addRemoveViewFromContainer(
                  tView,
                  lView,
                  !0,
                  getBeforeNodeForView(adjustedIdx, this._lContainer)
                ),
                viewRef.attachToViewContainerRef(this),
                addToArray(this._lContainer[8], adjustedIdx, viewRef),
                viewRef
              );
            }
            move(viewRef, newIndex) {
              if (viewRef.destroyed)
                throw new Error(
                  'Cannot move a destroyed View in a ViewContainer!'
                );
              return this.insert(viewRef, newIndex);
            }
            indexOf(viewRef) {
              const viewRefsArr = this._lContainer[8];
              return null !== viewRefsArr ? viewRefsArr.indexOf(viewRef) : -1;
            }
            remove(index) {
              this.allocateContainerIfNeeded();
              const adjustedIdx = this._adjustIndex(index, -1);
              !(function(lContainer, removeIndex) {
                const detachedView = detachView(lContainer, removeIndex);
                detachedView && destroyLView(detachedView[1], detachedView);
              })(this._lContainer, adjustedIdx),
                removeFromArray(this._lContainer[8], adjustedIdx);
            }
            detach(index) {
              this.allocateContainerIfNeeded();
              const adjustedIdx = this._adjustIndex(index, -1),
                view = detachView(this._lContainer, adjustedIdx);
              return view &&
                null != removeFromArray(this._lContainer[8], adjustedIdx)
                ? new ViewRef(view)
                : null;
            }
            _adjustIndex(index, shift = 0) {
              return null == index ? this.length + shift : index;
            }
            allocateContainerIfNeeded() {
              null === this._lContainer[8] && (this._lContainer[8] = []);
            }
          });
        const slotValue = hostView[hostTNode.index];
        if (isLContainer(slotValue)) lContainer = slotValue;
        else {
          let commentNode;
          if (4 === hostTNode.type) commentNode = unwrapRNode(slotValue);
          else if (
            ((commentNode = hostView[11].createComment('')),
            isRootView(hostView))
          ) {
            const renderer = hostView[11],
              hostNative = getNativeByTNode(hostTNode, hostView);
            nativeInsertBefore(
              renderer,
              nativeParentNode(renderer, hostNative),
              commentNode,
              (function(renderer, node) {
                return isProceduralRenderer(renderer)
                  ? renderer.nextSibling(node)
                  : node.nextSibling;
              })(renderer, hostNative)
            );
          } else appendChild(hostView[1], hostView, commentNode, hostTNode);
          (hostView[hostTNode.index] = lContainer = createLContainer(
            slotValue,
            hostView,
            commentNode,
            hostTNode
          )),
            addToViewTree(hostView, lContainer);
        }
        return new R3ViewContainerRef(lContainer, hostTNode, hostView);
      }
      function injectChangeDetectorRef(isPipe = !1) {
        return (function(tNode, lView, isPipe) {
          if (!isPipe && isComponentHost(tNode)) {
            const componentView = getComponentLViewByIndex(tNode.index, lView);
            return new ViewRef(componentView, componentView);
          }
          return 3 === tNode.type ||
            0 === tNode.type ||
            4 === tNode.type ||
            5 === tNode.type
            ? new ViewRef(lView[16], lView)
            : null;
        })(getPreviousOrParentTNode(), getLView(), isPipe);
      }
      let ChangeDetectorRef = (() => {
        class ChangeDetectorRef {}
        return (
          (ChangeDetectorRef.__NG_ELEMENT_ID__ = () =>
            SWITCH_CHANGE_DETECTOR_REF_FACTORY()),
          ChangeDetectorRef
        );
      })();
      const SWITCH_CHANGE_DETECTOR_REF_FACTORY = injectChangeDetectorRef,
        Type = Function,
        INJECTOR_SCOPE = new InjectionToken('Set Injector scope.'),
        NOT_YET = {},
        CIRCULAR = {},
        EMPTY_ARRAY$2 = [];
      let NULL_INJECTOR = void 0;
      function getNullInjector() {
        return (
          void 0 === NULL_INJECTOR && (NULL_INJECTOR = new NullInjector()),
          NULL_INJECTOR
        );
      }
      function createInjectorWithoutInjectorInstances(
        defType,
        parent = null,
        additionalProviders = null,
        name
      ) {
        return new R3Injector(
          defType,
          additionalProviders,
          parent || getNullInjector(),
          name
        );
      }
      class R3Injector {
        constructor(def, additionalProviders, parent, source = null) {
          (this.parent = parent),
            (this.records = new Map()),
            (this.injectorDefTypes = new Set()),
            (this.onDestroy = new Set()),
            (this._destroyed = !1);
          const dedupStack = [];
          additionalProviders &&
            deepForEach(additionalProviders, provider =>
              this.processProvider(provider, def, additionalProviders)
            ),
            deepForEach([def], injectorDef =>
              this.processInjectorType(injectorDef, [], dedupStack)
            ),
            this.records.set(INJECTOR, makeRecord(void 0, this));
          const record = this.records.get(INJECTOR_SCOPE);
          (this.scope = null != record ? record.value : null),
            (this.source =
              source || ('object' == typeof def ? null : stringify(def)));
        }
        get destroyed() {
          return this._destroyed;
        }
        destroy() {
          this.assertNotDestroyed(), (this._destroyed = !0);
          try {
            this.onDestroy.forEach(service => service.ngOnDestroy());
          } finally {
            this.records.clear(),
              this.onDestroy.clear(),
              this.injectorDefTypes.clear();
          }
        }
        get(
          token,
          notFoundValue = THROW_IF_NOT_FOUND,
          flags = InjectFlags.Default
        ) {
          this.assertNotDestroyed();
          const previousInjector = setCurrentInjector(this);
          try {
            if (!(flags & InjectFlags.SkipSelf)) {
              let record = this.records.get(token);
              if (void 0 === record) {
                const def =
                  ('function' == typeof (value = token) ||
                    ('object' == typeof value &&
                      value instanceof InjectionToken)) &&
                  getInjectableDef(token);
                (record =
                  def && this.injectableDefInScope(def)
                    ? makeRecord(
                        injectableDefOrInjectorDefFactory(token),
                        NOT_YET
                      )
                    : null),
                  this.records.set(token, record);
              }
              if (null != record) return this.hydrate(token, record);
            }
            return (flags & InjectFlags.Self
              ? getNullInjector()
              : this.parent
            ).get(
              token,
              (notFoundValue =
                flags & InjectFlags.Optional &&
                notFoundValue === THROW_IF_NOT_FOUND
                  ? null
                  : notFoundValue)
            );
          } catch (e) {
            if ('NullInjectorError' === e.name) {
              if (
                ((e.ngTempTokenPath = e.ngTempTokenPath || []).unshift(
                  stringify(token)
                ),
                previousInjector)
              )
                throw e;
              return (function(e, token, injectorErrorName, source) {
                const tokenPath = e.ngTempTokenPath;
                throw (token.__source && tokenPath.unshift(token.__source),
                (e.message = (function(
                  text,
                  obj,
                  injectorErrorName,
                  source = null
                ) {
                  text =
                    text && '\n' === text.charAt(0) && 'ɵ' == text.charAt(1)
                      ? text.substr(2)
                      : text;
                  let context = stringify(obj);
                  if (Array.isArray(obj))
                    context = obj.map(stringify).join(' -> ');
                  else if ('object' == typeof obj) {
                    let parts = [];
                    for (let key in obj)
                      if (obj.hasOwnProperty(key)) {
                        let value = obj[key];
                        parts.push(
                          key +
                            ':' +
                            ('string' == typeof value
                              ? JSON.stringify(value)
                              : stringify(value))
                        );
                      }
                    context = `{${parts.join(', ')}}`;
                  }
                  return `${injectorErrorName}${
                    source ? '(' + source + ')' : ''
                  }[${context}]: ${text.replace(NEW_LINE, '\n  ')}`;
                })('\n' + e.message, tokenPath, injectorErrorName, source)),
                (e.ngTokenPath = tokenPath),
                (e.ngTempTokenPath = null),
                e);
              })(e, token, 'R3InjectorError', this.source);
            }
            throw e;
          } finally {
            setCurrentInjector(previousInjector);
          }
          var value;
        }
        _resolveInjectorDefTypes() {
          this.injectorDefTypes.forEach(defType => this.get(defType));
        }
        toString() {
          const tokens = [];
          return (
            this.records.forEach((v, token) => tokens.push(stringify(token))),
            `R3Injector[${tokens.join(', ')}]`
          );
        }
        assertNotDestroyed() {
          if (this._destroyed)
            throw new Error('Injector has already been destroyed.');
        }
        processInjectorType(defOrWrappedDef, parents, dedupStack) {
          if (!(defOrWrappedDef = resolveForwardRef(defOrWrappedDef)))
            return !1;
          let def = getInjectorDef(defOrWrappedDef);
          const ngModule = (null == def && defOrWrappedDef.ngModule) || void 0,
            defType = void 0 === ngModule ? defOrWrappedDef : ngModule,
            isDuplicate = -1 !== dedupStack.indexOf(defType);
          if (
            (void 0 !== ngModule && (def = getInjectorDef(ngModule)),
            null == def)
          )
            return !1;
          if (null != def.imports && !isDuplicate) {
            let importTypesWithProviders;
            dedupStack.push(defType);
            try {
              deepForEach(def.imports, imported => {
                this.processInjectorType(imported, parents, dedupStack) &&
                  (void 0 === importTypesWithProviders &&
                    (importTypesWithProviders = []),
                  importTypesWithProviders.push(imported));
              });
            } finally {
            }
            if (void 0 !== importTypesWithProviders)
              for (let i = 0; i < importTypesWithProviders.length; i++) {
                const {
                  ngModule: ngModule,
                  providers: providers
                } = importTypesWithProviders[i];
                deepForEach(providers, provider =>
                  this.processProvider(
                    provider,
                    ngModule,
                    providers || EMPTY_ARRAY$2
                  )
                );
              }
          }
          this.injectorDefTypes.add(defType),
            this.records.set(defType, makeRecord(def.factory, NOT_YET));
          const defProviders = def.providers;
          if (null != defProviders && !isDuplicate) {
            const injectorType = defOrWrappedDef;
            deepForEach(defProviders, provider =>
              this.processProvider(provider, injectorType, defProviders)
            );
          }
          return void 0 !== ngModule && void 0 !== defOrWrappedDef.providers;
        }
        processProvider(provider, ngModuleType, providers) {
          let token = isTypeProvider((provider = resolveForwardRef(provider)))
            ? provider
            : resolveForwardRef(provider && provider.provide);
          const record = (function(provider, ngModuleType, providers) {
            return isValueProvider(provider)
              ? makeRecord(void 0, provider.useValue)
              : makeRecord(
                  providerToFactory(provider, ngModuleType, providers),
                  NOT_YET
                );
          })(provider, ngModuleType, providers);
          if (isTypeProvider(provider) || !0 !== provider.multi) {
            const existing = this.records.get(token);
            existing &&
              void 0 !== existing.multi &&
              throwMixedMultiProviderError();
          } else {
            let multiRecord = this.records.get(token);
            multiRecord
              ? void 0 === multiRecord.multi && throwMixedMultiProviderError()
              : ((multiRecord = makeRecord(void 0, NOT_YET, !0)),
                (multiRecord.factory = () => injectArgs(multiRecord.multi)),
                this.records.set(token, multiRecord)),
              (token = provider),
              multiRecord.multi.push(provider);
          }
          this.records.set(token, record);
        }
        hydrate(token, record) {
          var value;
          return (
            record.value === CIRCULAR
              ? (function(token) {
                  throw new Error(
                    'Cannot instantiate cyclic dependency! ' + token
                  );
                })(stringify(token))
              : record.value === NOT_YET &&
                ((record.value = CIRCULAR), (record.value = record.factory())),
            'object' == typeof record.value &&
              record.value &&
              null !== (value = record.value) &&
              'object' == typeof value &&
              'function' == typeof value.ngOnDestroy &&
              this.onDestroy.add(record.value),
            record.value
          );
        }
        injectableDefInScope(def) {
          return (
            !!def.providedIn &&
            ('string' == typeof def.providedIn
              ? 'any' === def.providedIn || def.providedIn === this.scope
              : this.injectorDefTypes.has(def.providedIn))
          );
        }
      }
      function injectableDefOrInjectorDefFactory(token) {
        const injectableDef = getInjectableDef(token),
          factory =
            null !== injectableDef
              ? injectableDef.factory
              : getFactoryDef(token);
        if (null !== factory) return factory;
        const injectorDef = getInjectorDef(token);
        if (null !== injectorDef) return injectorDef.factory;
        if (token instanceof InjectionToken)
          throw new Error(
            `Token ${stringify(token)} is missing a ɵprov definition.`
          );
        if (token instanceof Function)
          return (function(token) {
            const paramLength = token.length;
            if (paramLength > 0) {
              const args = newArray(paramLength, '?');
              throw new Error(
                `Can't resolve all parameters for ${stringify(
                  token
                )}: (${args.join(', ')}).`
              );
            }
            const inheritedInjectableDef = (function(type) {
              const def =
                type &&
                (type[NG_PROV_DEF] ||
                  type[NG_INJECTABLE_DEF] ||
                  (type[NG_PROV_DEF_FALLBACK] && type[NG_PROV_DEF_FALLBACK]()));
              if (def) {
                const typeName = (function(type) {
                  if (type.hasOwnProperty('name')) return type.name;
                  const match = ('' + type).match(/^function\s*([^\s(]+)/);
                  return null === match ? '' : match[1];
                })(type);
                return (
                  console.warn(
                    `DEPRECATED: DI is instantiating a token "${typeName}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${typeName}" class.`
                  ),
                  def
                );
              }
              return null;
            })(token);
            return null !== inheritedInjectableDef
              ? () => inheritedInjectableDef.factory(token)
              : () => new token();
          })(token);
        throw new Error('unreachable');
      }
      function providerToFactory(provider, ngModuleType, providers) {
        let factory = void 0;
        if (isTypeProvider(provider)) {
          const unwrappedProvider = resolveForwardRef(provider);
          return (
            getFactoryDef(unwrappedProvider) ||
            injectableDefOrInjectorDefFactory(unwrappedProvider)
          );
        }
        if (isValueProvider(provider))
          factory = () => resolveForwardRef(provider.useValue);
        else if ((value = provider) && value.useFactory)
          factory = () =>
            provider.useFactory(...injectArgs(provider.deps || []));
        else if (
          (function(value) {
            return !(!value || !value.useExisting);
          })(provider)
        )
          factory = () => ɵɵinject(resolveForwardRef(provider.useExisting));
        else {
          const classRef = resolveForwardRef(
            provider && (provider.useClass || provider.provide)
          );
          if (
            (classRef ||
              (function(ngModuleType, providers, provider) {
                let ngModuleDetail = '';
                throw (ngModuleType &&
                  providers &&
                  (ngModuleDetail = ` - only instances of Provider and Type are allowed, got: [${providers
                    .map(v => (v == provider ? '?' + provider + '?' : '...'))
                    .join(', ')}]`),
                new Error(
                  `Invalid provider for the NgModule '${stringify(
                    ngModuleType
                  )}'` + ngModuleDetail
                ));
              })(ngModuleType, providers, provider),
            !(function(value) {
              return !!value.deps;
            })(provider))
          )
            return (
              getFactoryDef(classRef) ||
              injectableDefOrInjectorDefFactory(classRef)
            );
          factory = () => new classRef(...injectArgs(provider.deps));
        }
        var value;
        return factory;
      }
      function makeRecord(factory, value, multi = !1) {
        return { factory: factory, value: value, multi: multi ? [] : void 0 };
      }
      function isValueProvider(value) {
        return null !== value && 'object' == typeof value && USE_VALUE in value;
      }
      function isTypeProvider(value) {
        return 'function' == typeof value;
      }
      const INJECTOR_IMPL = function(providers, parent, name) {
        return (function(
          defType,
          parent = null,
          additionalProviders = null,
          name
        ) {
          const injector = createInjectorWithoutInjectorInstances(
            defType,
            parent,
            additionalProviders,
            name
          );
          return injector._resolveInjectorDefTypes(), injector;
        })({ name: name }, parent, providers, name);
      };
      let Injector = (() => {
        class Injector {
          static create(options, parent) {
            return Array.isArray(options)
              ? INJECTOR_IMPL(options, parent, '')
              : INJECTOR_IMPL(
                  options.providers,
                  options.parent,
                  options.name || ''
                );
          }
        }
        return (
          (Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND),
          (Injector.NULL = new NullInjector()),
          (Injector.ɵprov = ɵɵdefineInjectable({
            token: Injector,
            providedIn: 'any',
            factory: () => ɵɵinject(INJECTOR)
          })),
          (Injector.__NG_ELEMENT_ID__ = -1),
          Injector
        );
      })();
      const ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken(
        'AnalyzeForEntryComponents'
      );
      function computeStaticStyling(tNode, attrs, writeToHost) {
        let styles = writeToHost ? tNode.styles : null,
          classes = writeToHost ? tNode.classes : null,
          mode = 0;
        if (null !== attrs)
          for (let i = 0; i < attrs.length; i++) {
            const value = attrs[i];
            'number' == typeof value
              ? (mode = value)
              : 1 == mode
              ? (classes = concatStringsWithSpace(classes, value))
              : 2 == mode &&
                (styles = concatStringsWithSpace(
                  styles,
                  value + ': ' + attrs[++i] + ';'
                ));
          }
        writeToHost
          ? (tNode.styles = styles)
          : (tNode.stylesWithoutHost = styles),
          writeToHost
            ? (tNode.classes = classes)
            : (tNode.classesWithoutHost = classes);
      }
      let _symbolIterator = null;
      function getSymbolIterator() {
        if (!_symbolIterator) {
          const Symbol = _global.Symbol;
          if (Symbol && Symbol.iterator) _symbolIterator = Symbol.iterator;
          else {
            const keys = Object.getOwnPropertyNames(Map.prototype);
            for (let i = 0; i < keys.length; ++i) {
              const key = keys[i];
              'entries' !== key &&
                'size' !== key &&
                Map.prototype[key] === Map.prototype.entries &&
                (_symbolIterator = key);
            }
          }
        }
        return _symbolIterator;
      }
      class WrappedValue {
        constructor(value) {
          this.wrapped = value;
        }
        static wrap(value) {
          return new WrappedValue(value);
        }
        static unwrap(value) {
          return WrappedValue.isWrapped(value) ? value.wrapped : value;
        }
        static isWrapped(value) {
          return value instanceof WrappedValue;
        }
      }
      function isListLikeIterable(obj) {
        return (
          !!isJsObject(obj) &&
          (Array.isArray(obj) ||
            (!(obj instanceof Map) && getSymbolIterator() in obj))
        );
      }
      function isJsObject(o) {
        return null !== o && ('function' == typeof o || 'object' == typeof o);
      }
      function updateBinding(lView, bindingIndex, value) {
        return (lView[bindingIndex] = value);
      }
      function bindingUpdated(lView, bindingIndex, value) {
        return (
          !Object.is(lView[bindingIndex], value) &&
          ((lView[bindingIndex] = value), !0)
        );
      }
      function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
        const different = bindingUpdated(lView, bindingIndex, exp1);
        return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
      }
      function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
        const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
        return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
      }
      function ɵɵattribute(name, value, sanitizer, namespace) {
        const lView = getLView();
        return (
          bindingUpdated(lView, nextBindingIndex(), value) &&
            (getTView(),
            elementAttributeInternal(
              getSelectedTNode(),
              lView,
              name,
              value,
              sanitizer,
              namespace
            )),
          ɵɵattribute
        );
      }
      function interpolation1(lView, prefix, v0, suffix) {
        return bindingUpdated(lView, nextBindingIndex(), v0)
          ? prefix + renderStringify(v0) + suffix
          : NO_CHANGE;
      }
      function interpolation2(lView, prefix, v0, i0, v1, suffix) {
        const different = bindingUpdated2(lView, getBindingIndex(), v0, v1);
        return (
          incrementBindingIndex(2),
          different
            ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix
            : NO_CHANGE
        );
      }
      function ɵɵtemplate(
        index,
        templateFn,
        decls,
        vars,
        tagName,
        attrsIndex,
        localRefsIndex,
        localRefExtractor
      ) {
        const lView = getLView(),
          tView = getTView(),
          adjustedIndex = index + 20,
          tNode = tView.firstCreatePass
            ? (function(
                index,
                tView,
                lView,
                templateFn,
                decls,
                vars,
                tagName,
                attrsIndex,
                localRefsIndex
              ) {
                const tViewConsts = tView.consts,
                  tNode = getOrCreateTNode(
                    tView,
                    lView[6],
                    index,
                    0,
                    tagName || null,
                    getConstant(tViewConsts, attrsIndex)
                  );
                resolveDirectives(
                  tView,
                  lView,
                  tNode,
                  getConstant(tViewConsts, localRefsIndex)
                ),
                  registerPostOrderHooks(tView, tNode);
                const embeddedTView = (tNode.tViews = createTView(
                    2,
                    -1,
                    templateFn,
                    decls,
                    vars,
                    tView.directiveRegistry,
                    tView.pipeRegistry,
                    null,
                    tView.schemas,
                    tViewConsts
                  )),
                  embeddedTViewNode = createTNode(0, null, 2, -1, null, null);
                return (
                  (embeddedTViewNode.injectorIndex = tNode.injectorIndex),
                  (embeddedTView.node = embeddedTViewNode),
                  null !== tView.queries &&
                    (tView.queries.template(tView, tNode),
                    (embeddedTView.queries = tView.queries.embeddedTView(
                      tNode
                    ))),
                  tNode
                );
              })(
                index,
                tView,
                lView,
                templateFn,
                decls,
                vars,
                tagName,
                attrsIndex,
                localRefsIndex
              )
            : tView.data[adjustedIndex];
        setPreviousOrParentTNode(tNode, !1);
        const comment = lView[11].createComment('');
        appendChild(tView, lView, comment, tNode),
          attachPatchData(comment, lView),
          addToViewTree(
            lView,
            (lView[adjustedIndex] = createLContainer(
              comment,
              lView,
              comment,
              tNode
            ))
          ),
          isDirectiveHost(tNode) &&
            createDirectivesInstances(tView, lView, tNode),
          null != localRefsIndex &&
            saveResolvedLocalsInData(lView, tNode, localRefExtractor);
      }
      function ɵɵreference(index) {
        return load(instructionState.lFrame.contextLView, index);
      }
      function ɵɵdirectiveInject(token, flags = InjectFlags.Default) {
        const lView = getLView();
        return null == lView
          ? ɵɵinject(token, flags)
          : getOrCreateInjectable(
              getPreviousOrParentTNode(),
              lView,
              resolveForwardRef(token),
              flags
            );
      }
      function ɵɵinjectAttribute(attrNameToInject) {
        return (function(tNode, attrNameToInject) {
          if ('class' === attrNameToInject) return tNode.classes;
          if ('style' === attrNameToInject) return tNode.styles;
          const attrs = tNode.attrs;
          if (attrs) {
            const attrsLength = attrs.length;
            let i = 0;
            for (; i < attrsLength; ) {
              const value = attrs[i];
              if (isNameOnlyAttributeMarker(value)) break;
              if (0 === value) i += 2;
              else if ('number' == typeof value)
                for (i++; i < attrsLength && 'string' == typeof attrs[i]; ) i++;
              else {
                if (value === attrNameToInject) return attrs[i + 1];
                i += 2;
              }
            }
          }
          return null;
        })(getPreviousOrParentTNode(), attrNameToInject);
      }
      function ɵɵproperty(propName, value, sanitizer) {
        const lView = getLView();
        return (
          bindingUpdated(lView, nextBindingIndex(), value) &&
            elementPropertyInternal(
              getTView(),
              getSelectedTNode(),
              lView,
              propName,
              value,
              lView[11],
              sanitizer,
              !1
            ),
          ɵɵproperty
        );
      }
      function setDirectiveInputsWhichShadowsStyling(
        tView,
        tNode,
        lView,
        value,
        isClassBased
      ) {
        const property = isClassBased ? 'class' : 'style';
        setInputsForProperty(
          tView,
          lView,
          tNode.inputs[property],
          property,
          value
        );
      }
      function ɵɵelementStart(index, name, attrsIndex, localRefsIndex) {
        const lView = getLView(),
          tView = getTView(),
          adjustedIndex = 20 + index,
          renderer = lView[11],
          native = (lView[adjustedIndex] = elementCreate(
            name,
            renderer,
            instructionState.lFrame.currentNamespace
          )),
          tNode = tView.firstCreatePass
            ? (function(
                index,
                tView,
                lView,
                native,
                name,
                attrsIndex,
                localRefsIndex
              ) {
                const tViewConsts = tView.consts,
                  attrs = getConstant(tViewConsts, attrsIndex),
                  tNode = getOrCreateTNode(
                    tView,
                    lView[6],
                    index,
                    3,
                    name,
                    attrs
                  );
                return (
                  resolveDirectives(
                    tView,
                    lView,
                    tNode,
                    getConstant(tViewConsts, localRefsIndex)
                  ),
                  null !== tNode.attrs &&
                    computeStaticStyling(tNode, tNode.attrs, !1),
                  null !== tNode.mergedAttrs &&
                    computeStaticStyling(tNode, tNode.mergedAttrs, !0),
                  null !== tView.queries &&
                    tView.queries.elementStart(tView, tNode),
                  tNode
                );
              })(index, tView, lView, 0, name, attrsIndex, localRefsIndex)
            : tView.data[adjustedIndex];
        setPreviousOrParentTNode(tNode, !0);
        const mergedAttrs = tNode.mergedAttrs;
        null !== mergedAttrs && setUpAttributes(renderer, native, mergedAttrs);
        const classes = tNode.classes;
        null !== classes && writeDirectClass(renderer, native, classes);
        const styles = tNode.styles;
        null !== styles && writeDirectStyle(renderer, native, styles),
          appendChild(tView, lView, native, tNode),
          0 === instructionState.lFrame.elementDepthCount &&
            attachPatchData(native, lView),
          instructionState.lFrame.elementDepthCount++,
          isDirectiveHost(tNode) &&
            (createDirectivesInstances(tView, lView, tNode),
            executeContentQueries(tView, tNode, lView)),
          null !== localRefsIndex && saveResolvedLocalsInData(lView, tNode);
      }
      function ɵɵelementEnd() {
        let previousOrParentTNode = getPreviousOrParentTNode();
        getIsParent()
          ? setIsNotParent()
          : ((previousOrParentTNode = previousOrParentTNode.parent),
            setPreviousOrParentTNode(previousOrParentTNode, !1));
        const tNode = previousOrParentTNode;
        instructionState.lFrame.elementDepthCount--;
        const tView = getTView();
        tView.firstCreatePass &&
          (registerPostOrderHooks(tView, previousOrParentTNode),
          isContentQueryHost(previousOrParentTNode) &&
            tView.queries.elementEnd(previousOrParentTNode)),
          null != tNode.classesWithoutHost &&
            (function(tNode) {
              return 0 != (16 & tNode.flags);
            })(tNode) &&
            setDirectiveInputsWhichShadowsStyling(
              tView,
              tNode,
              getLView(),
              tNode.classesWithoutHost,
              !0
            ),
          null != tNode.stylesWithoutHost &&
            (function(tNode) {
              return 0 != (32 & tNode.flags);
            })(tNode) &&
            setDirectiveInputsWhichShadowsStyling(
              tView,
              tNode,
              getLView(),
              tNode.stylesWithoutHost,
              !1
            );
      }
      function ɵɵelement(index, name, attrsIndex, localRefsIndex) {
        ɵɵelementStart(index, name, attrsIndex, localRefsIndex), ɵɵelementEnd();
      }
      function ɵɵelementContainerStart(index, attrsIndex, localRefsIndex) {
        const lView = getLView(),
          tView = getTView(),
          adjustedIndex = index + 20,
          tNode = tView.firstCreatePass
            ? (function(index, tView, lView, attrsIndex, localRefsIndex) {
                const tViewConsts = tView.consts,
                  attrs = getConstant(tViewConsts, attrsIndex),
                  tNode = getOrCreateTNode(
                    tView,
                    lView[6],
                    index,
                    4,
                    'ng-container',
                    attrs
                  );
                return (
                  null !== attrs && computeStaticStyling(tNode, attrs, !0),
                  resolveDirectives(
                    tView,
                    lView,
                    tNode,
                    getConstant(tViewConsts, localRefsIndex)
                  ),
                  null !== tView.queries &&
                    tView.queries.elementStart(tView, tNode),
                  tNode
                );
              })(index, tView, lView, attrsIndex, localRefsIndex)
            : tView.data[adjustedIndex];
        setPreviousOrParentTNode(tNode, !0);
        const native = (lView[adjustedIndex] = lView[11].createComment(''));
        appendChild(tView, lView, native, tNode),
          attachPatchData(native, lView),
          isDirectiveHost(tNode) &&
            (createDirectivesInstances(tView, lView, tNode),
            executeContentQueries(tView, tNode, lView)),
          null != localRefsIndex && saveResolvedLocalsInData(lView, tNode);
      }
      function ɵɵelementContainerEnd() {
        let previousOrParentTNode = getPreviousOrParentTNode();
        const tView = getTView();
        getIsParent()
          ? setIsNotParent()
          : ((previousOrParentTNode = previousOrParentTNode.parent),
            setPreviousOrParentTNode(previousOrParentTNode, !1)),
          tView.firstCreatePass &&
            (registerPostOrderHooks(tView, previousOrParentTNode),
            isContentQueryHost(previousOrParentTNode) &&
              tView.queries.elementEnd(previousOrParentTNode));
      }
      function ɵɵgetCurrentView() {
        return getLView();
      }
      function isPromise(obj) {
        return !!obj && 'function' == typeof obj.then;
      }
      function isObservable(obj) {
        return !!obj && 'function' == typeof obj.subscribe;
      }
      function ɵɵlistener(
        eventName,
        listenerFn,
        useCapture = !1,
        eventTargetResolver
      ) {
        const lView = getLView(),
          tView = getTView(),
          tNode = getPreviousOrParentTNode();
        return (
          (function(
            tView,
            lView,
            renderer,
            tNode,
            eventName,
            listenerFn,
            useCapture = !1,
            eventTargetResolver
          ) {
            const isTNodeDirectiveHost = isDirectiveHost(tNode),
              tCleanup =
                tView.firstCreatePass &&
                (tView.cleanup || (tView.cleanup = [])),
              lCleanup = getLCleanup(lView);
            let processOutputs = !0;
            if (3 === tNode.type) {
              const native = getNativeByTNode(tNode, lView),
                resolved = eventTargetResolver
                  ? eventTargetResolver(native)
                  : EMPTY_OBJ,
                target = resolved.target || native,
                lCleanupIndex = lCleanup.length,
                idxOrTargetGetter = eventTargetResolver
                  ? _lView =>
                      eventTargetResolver(unwrapRNode(_lView[tNode.index]))
                        .target
                  : tNode.index;
              if (isProceduralRenderer(renderer)) {
                let existingListener = null;
                if (
                  (!eventTargetResolver &&
                    isTNodeDirectiveHost &&
                    (existingListener = (function(
                      tView,
                      lView,
                      eventName,
                      tNodeIdx
                    ) {
                      const tCleanup = tView.cleanup;
                      if (null != tCleanup)
                        for (let i = 0; i < tCleanup.length - 1; i += 2) {
                          const cleanupEventName = tCleanup[i];
                          if (
                            cleanupEventName === eventName &&
                            tCleanup[i + 1] === tNodeIdx
                          ) {
                            const lCleanup = lView[7],
                              listenerIdxInLCleanup = tCleanup[i + 2];
                            return lCleanup.length > listenerIdxInLCleanup
                              ? lCleanup[listenerIdxInLCleanup]
                              : null;
                          }
                          'string' == typeof cleanupEventName && (i += 2);
                        }
                      return null;
                    })(tView, lView, eventName, tNode.index)),
                  null !== existingListener)
                )
                  ((
                    existingListener.__ngLastListenerFn__ || existingListener
                  ).__ngNextListenerFn__ = listenerFn),
                    (existingListener.__ngLastListenerFn__ = listenerFn),
                    (processOutputs = !1);
                else {
                  listenerFn = wrapListener(tNode, lView, listenerFn, !1);
                  const cleanupFn = renderer.listen(
                    resolved.name || target,
                    eventName,
                    listenerFn
                  );
                  lCleanup.push(listenerFn, cleanupFn),
                    tCleanup &&
                      tCleanup.push(
                        eventName,
                        idxOrTargetGetter,
                        lCleanupIndex,
                        lCleanupIndex + 1
                      );
                }
              } else
                (listenerFn = wrapListener(tNode, lView, listenerFn, !0)),
                  target.addEventListener(eventName, listenerFn, useCapture),
                  lCleanup.push(listenerFn),
                  tCleanup &&
                    tCleanup.push(
                      eventName,
                      idxOrTargetGetter,
                      lCleanupIndex,
                      useCapture
                    );
            }
            const outputs = tNode.outputs;
            let props;
            if (
              processOutputs &&
              null !== outputs &&
              (props = outputs[eventName])
            ) {
              const propsLength = props.length;
              if (propsLength)
                for (let i = 0; i < propsLength; i += 2) {
                  const subscription = lView[props[i]][props[i + 1]].subscribe(
                      listenerFn
                    ),
                    idx = lCleanup.length;
                  lCleanup.push(listenerFn, subscription),
                    tCleanup &&
                      tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
                }
            }
          })(
            tView,
            lView,
            lView[11],
            tNode,
            eventName,
            listenerFn,
            useCapture,
            eventTargetResolver
          ),
          ɵɵlistener
        );
      }
      function executeListenerWithErrorHandling(lView, listenerFn, e) {
        try {
          return !1 !== listenerFn(e);
        } catch (error) {
          return handleError(lView, error), !1;
        }
      }
      function wrapListener(tNode, lView, listenerFn, wrapWithPreventDefault) {
        return function wrapListenerIn_markDirtyAndPreventDefault(e) {
          if (e === Function) return listenerFn;
          const startView =
            2 & tNode.flags
              ? getComponentLViewByIndex(tNode.index, lView)
              : lView;
          0 == (32 & lView[2]) && markViewDirty(startView);
          let result = executeListenerWithErrorHandling(lView, listenerFn, e),
            nextListenerFn =
              wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
          for (; nextListenerFn; )
            (result =
              executeListenerWithErrorHandling(lView, nextListenerFn, e) &&
              result),
              (nextListenerFn = nextListenerFn.__ngNextListenerFn__);
          return (
            wrapWithPreventDefault &&
              !1 === result &&
              (e.preventDefault(), (e.returnValue = !1)),
            result
          );
        };
      }
      function ɵɵnextContext(level = 1) {
        return (function(level) {
          return (instructionState.lFrame.contextLView = (function(
            nestingLevel,
            currentView
          ) {
            for (; nestingLevel > 0; )
              (currentView = currentView[15]), nestingLevel--;
            return currentView;
          })(level, instructionState.lFrame.contextLView))[8];
        })(level);
      }
      function matchingProjectionSlotIndex(tNode, projectionSlots) {
        let wildcardNgContentIndex = null;
        const ngProjectAsAttrVal = (function(tNode) {
          const nodeAttrs = tNode.attrs;
          if (null != nodeAttrs) {
            const ngProjectAsAttrIdx = nodeAttrs.indexOf(5);
            if (0 == (1 & ngProjectAsAttrIdx))
              return nodeAttrs[ngProjectAsAttrIdx + 1];
          }
          return null;
        })(tNode);
        for (let i = 0; i < projectionSlots.length; i++) {
          const slotValue = projectionSlots[i];
          if ('*' !== slotValue) {
            if (
              null === ngProjectAsAttrVal
                ? isNodeMatchingSelectorList(tNode, slotValue, !0)
                : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)
            )
              return i;
          } else wildcardNgContentIndex = i;
        }
        return wildcardNgContentIndex;
      }
      function ɵɵprojectionDef(projectionSlots) {
        const componentNode = getLView()[16][6];
        if (!componentNode.projection) {
          const projectionHeads = (componentNode.projection = newArray(
              projectionSlots ? projectionSlots.length : 1,
              null
            )),
            tails = projectionHeads.slice();
          let componentChild = componentNode.child;
          for (; null !== componentChild; ) {
            const slotIndex = projectionSlots
              ? matchingProjectionSlotIndex(componentChild, projectionSlots)
              : 0;
            null !== slotIndex &&
              (tails[slotIndex]
                ? (tails[slotIndex].projectionNext = componentChild)
                : (projectionHeads[slotIndex] = componentChild),
              (tails[slotIndex] = componentChild)),
              (componentChild = componentChild.next);
          }
        }
      }
      let delayProjection = !1;
      function setDelayProjection(value) {
        delayProjection = value;
      }
      function ɵɵprojection(nodeIndex, selectorIndex = 0, attrs) {
        const lView = getLView(),
          tView = getTView(),
          tProjectionNode = getOrCreateTNode(
            tView,
            lView[6],
            nodeIndex,
            1,
            null,
            attrs || null
          );
        null === tProjectionNode.projection &&
          (tProjectionNode.projection = selectorIndex),
          setIsNotParent(),
          delayProjection || applyProjection(tView, lView, tProjectionNode);
      }
      function ɵɵpropertyInterpolate(propName, v0, sanitizer) {
        return (
          ɵɵpropertyInterpolate1(propName, '', v0, '', sanitizer),
          ɵɵpropertyInterpolate
        );
      }
      function ɵɵpropertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
        const lView = getLView(),
          interpolatedValue = interpolation1(lView, prefix, v0, suffix);
        return (
          interpolatedValue !== NO_CHANGE &&
            elementPropertyInternal(
              getTView(),
              getSelectedTNode(),
              lView,
              propName,
              interpolatedValue,
              lView[11],
              sanitizer,
              !1
            ),
          ɵɵpropertyInterpolate1
        );
      }
      const EMPTY_ARRAY$3 = [];
      function markDuplicates(
        tData,
        tStylingKey,
        index,
        isPrevDir,
        isClassBinding
      ) {
        const tStylingAtIndex = tData[index + 1],
          isMap = null === tStylingKey;
        let cursor = isPrevDir
            ? getTStylingRangePrev(tStylingAtIndex)
            : getTStylingRangeNext(tStylingAtIndex),
          foundDuplicate = !1;
        for (; 0 !== cursor && (!1 === foundDuplicate || isMap); ) {
          const tStyleRangeAtCursor = tData[cursor + 1];
          isStylingMatch(tData[cursor], tStylingKey) &&
            ((foundDuplicate = !0),
            (tData[cursor + 1] = isPrevDir
              ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor)
              : setTStylingRangePrevDuplicate(tStyleRangeAtCursor))),
            (cursor = isPrevDir
              ? getTStylingRangePrev(tStyleRangeAtCursor)
              : getTStylingRangeNext(tStyleRangeAtCursor));
        }
        foundDuplicate &&
          (tData[index + 1] = isPrevDir
            ? setTStylingRangePrevDuplicate(tStylingAtIndex)
            : setTStylingRangeNextDuplicate(tStylingAtIndex));
      }
      function isStylingMatch(tStylingKeyCursor, tStylingKey) {
        return (
          null === tStylingKeyCursor ||
          null == tStylingKey ||
          (Array.isArray(tStylingKeyCursor)
            ? tStylingKeyCursor[1]
            : tStylingKeyCursor) === tStylingKey ||
          (!(
            !Array.isArray(tStylingKeyCursor) || 'string' != typeof tStylingKey
          ) &&
            keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0)
        );
      }
      const parserState = {
        textEnd: 0,
        key: 0,
        keyEnd: 0,
        value: 0,
        valueEnd: 0
      };
      function getLastParsedKey(text) {
        return text.substring(parserState.key, parserState.keyEnd);
      }
      function parseClassNameNext(text, index) {
        const end = parserState.textEnd;
        return end === index
          ? -1
          : ((index = parserState.keyEnd = (function(
              text,
              startIndex,
              endIndex
            ) {
              for (
                ;
                startIndex < endIndex && text.charCodeAt(startIndex) > 32;

              )
                startIndex++;
              return startIndex;
            })(text, (parserState.key = index), end)),
            consumeWhitespace(text, index, end));
      }
      function consumeWhitespace(text, startIndex, endIndex) {
        for (; startIndex < endIndex && text.charCodeAt(startIndex) <= 32; )
          startIndex++;
        return startIndex;
      }
      function ɵɵstyleProp(prop, value, suffix) {
        return checkStylingProperty(prop, value, suffix, !1), ɵɵstyleProp;
      }
      function ɵɵclassProp(className, value) {
        return checkStylingProperty(className, value, null, !0), ɵɵclassProp;
      }
      function ɵɵclassMap(classes) {
        checkStylingMap(keyValueArraySet, classStringParser, classes, !0);
      }
      function classStringParser(keyValueArray, text) {
        for (
          let i = (function(text) {
            return (
              (function(text) {
                (parserState.key = 0),
                  (parserState.keyEnd = 0),
                  (parserState.value = 0),
                  (parserState.valueEnd = 0),
                  (parserState.textEnd = text.length);
              })(text),
              parseClassNameNext(
                text,
                consumeWhitespace(text, 0, parserState.textEnd)
              )
            );
          })(text);
          i >= 0;
          i = parseClassNameNext(text, i)
        )
          keyValueArraySet(keyValueArray, getLastParsedKey(text), !0);
      }
      function checkStylingProperty(prop, value, suffix, isClassBased) {
        const lView = getLView(),
          tView = getTView(),
          bindingIndex = incrementBindingIndex(2);
        tView.firstUpdatePass &&
          stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased),
          value !== NO_CHANGE &&
            bindingUpdated(lView, bindingIndex, value) &&
            updateStyling(
              tView,
              tView.data[getSelectedIndex() + 20],
              lView,
              lView[11],
              prop,
              (lView[bindingIndex + 1] = (function(value, suffix) {
                return (
                  null == value ||
                    ('string' == typeof suffix
                      ? (value += suffix)
                      : 'object' == typeof value &&
                        (value = stringify(unwrapSafeValue(value)))),
                  value
                );
              })(value, suffix)),
              isClassBased,
              bindingIndex
            );
      }
      function checkStylingMap(
        keyValueArraySet,
        stringParser,
        value,
        isClassBased
      ) {
        const tView = getTView(),
          bindingIndex = incrementBindingIndex(2);
        tView.firstUpdatePass &&
          stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
        const lView = getLView();
        if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
          const tNode = tView.data[getSelectedIndex() + 20];
          if (
            hasStylingInputShadow(tNode, isClassBased) &&
            !isInHostBindings(tView, bindingIndex)
          ) {
            let staticPrefix = isClassBased
              ? tNode.classesWithoutHost
              : tNode.stylesWithoutHost;
            null !== staticPrefix &&
              (value = concatStringsWithSpace(staticPrefix, value || '')),
              setDirectiveInputsWhichShadowsStyling(
                tView,
                tNode,
                lView,
                value,
                isClassBased
              );
          } else
            !(function(
              tView,
              tNode,
              lView,
              renderer,
              oldKeyValueArray,
              newKeyValueArray,
              isClassBased,
              bindingIndex
            ) {
              oldKeyValueArray === NO_CHANGE &&
                (oldKeyValueArray = EMPTY_ARRAY$3);
              let oldIndex = 0,
                newIndex = 0,
                oldKey =
                  0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null,
                newKey =
                  0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
              for (; null !== oldKey || null !== newKey; ) {
                const oldValue =
                    oldIndex < oldKeyValueArray.length
                      ? oldKeyValueArray[oldIndex + 1]
                      : void 0,
                  newValue =
                    newIndex < newKeyValueArray.length
                      ? newKeyValueArray[newIndex + 1]
                      : void 0;
                let setKey = null,
                  setValue = void 0;
                oldKey === newKey
                  ? ((oldIndex += 2),
                    (newIndex += 2),
                    oldValue !== newValue &&
                      ((setKey = newKey), (setValue = newValue)))
                  : null === newKey || (null !== oldKey && oldKey < newKey)
                  ? ((oldIndex += 2), (setKey = oldKey))
                  : ((newIndex += 2), (setKey = newKey), (setValue = newValue)),
                  null !== setKey &&
                    updateStyling(
                      tView,
                      tNode,
                      lView,
                      renderer,
                      setKey,
                      setValue,
                      isClassBased,
                      bindingIndex
                    ),
                  (oldKey =
                    oldIndex < oldKeyValueArray.length
                      ? oldKeyValueArray[oldIndex]
                      : null),
                  (newKey =
                    newIndex < newKeyValueArray.length
                      ? newKeyValueArray[newIndex]
                      : null);
              }
            })(
              tView,
              tNode,
              lView,
              lView[11],
              lView[bindingIndex + 1],
              (lView[bindingIndex + 1] = (function(
                keyValueArraySet,
                stringParser,
                value
              ) {
                if (null == value || '' === value) return EMPTY_ARRAY$3;
                const styleKeyValueArray = [],
                  unwrappedValue = unwrapSafeValue(value);
                if (Array.isArray(unwrappedValue))
                  for (let i = 0; i < unwrappedValue.length; i++)
                    keyValueArraySet(styleKeyValueArray, unwrappedValue[i], !0);
                else if ('object' == typeof unwrappedValue)
                  for (const key in unwrappedValue)
                    unwrappedValue.hasOwnProperty(key) &&
                      keyValueArraySet(
                        styleKeyValueArray,
                        key,
                        unwrappedValue[key]
                      );
                else
                  'string' == typeof unwrappedValue &&
                    stringParser(styleKeyValueArray, unwrappedValue);
                return styleKeyValueArray;
              })(keyValueArraySet, stringParser, value)),
              isClassBased,
              bindingIndex
            );
        }
      }
      function isInHostBindings(tView, bindingIndex) {
        return bindingIndex >= tView.expandoStartIndex;
      }
      function stylingFirstUpdatePass(
        tView,
        tStylingKey,
        bindingIndex,
        isClassBased
      ) {
        const tData = tView.data;
        if (null === tData[bindingIndex + 1]) {
          const tNode = tData[getSelectedIndex() + 20],
            isHostBindings = isInHostBindings(tView, bindingIndex);
          hasStylingInputShadow(tNode, isClassBased) &&
            null === tStylingKey &&
            !isHostBindings &&
            (tStylingKey = !1),
            (tStylingKey = (function(tData, tNode, stylingKey, isClassBased) {
              const hostDirectiveDef = (function(tData) {
                const currentDirectiveIndex =
                  instructionState.lFrame.currentDirectiveIndex;
                return -1 === currentDirectiveIndex
                  ? null
                  : tData[currentDirectiveIndex];
              })(tData);
              let residual = isClassBased
                ? tNode.residualClasses
                : tNode.residualStyles;
              if (null === hostDirectiveDef)
                0 ===
                  (isClassBased ? tNode.classBindings : tNode.styleBindings) &&
                  ((stylingKey = collectStylingFromTAttrs(
                    (stylingKey = collectStylingFromDirectives(
                      null,
                      tData,
                      tNode,
                      stylingKey,
                      isClassBased
                    )),
                    tNode.attrs,
                    isClassBased
                  )),
                  (residual = null));
              else {
                const directiveStylingLast = tNode.directiveStylingLast;
                if (
                  -1 === directiveStylingLast ||
                  tData[directiveStylingLast] !== hostDirectiveDef
                )
                  if (
                    ((stylingKey = collectStylingFromDirectives(
                      hostDirectiveDef,
                      tData,
                      tNode,
                      stylingKey,
                      isClassBased
                    )),
                    null === residual)
                  ) {
                    let templateStylingKey = (function(
                      tData,
                      tNode,
                      isClassBased
                    ) {
                      const bindings = isClassBased
                        ? tNode.classBindings
                        : tNode.styleBindings;
                      if (0 !== getTStylingRangeNext(bindings))
                        return tData[getTStylingRangePrev(bindings)];
                    })(tData, tNode, isClassBased);
                    void 0 !== templateStylingKey &&
                      Array.isArray(templateStylingKey) &&
                      ((templateStylingKey = collectStylingFromDirectives(
                        null,
                        tData,
                        tNode,
                        templateStylingKey[1],
                        isClassBased
                      )),
                      (templateStylingKey = collectStylingFromTAttrs(
                        templateStylingKey,
                        tNode.attrs,
                        isClassBased
                      )),
                      (function(tData, tNode, isClassBased, tStylingKey) {
                        tData[
                          getTStylingRangePrev(
                            isClassBased
                              ? tNode.classBindings
                              : tNode.styleBindings
                          )
                        ] = tStylingKey;
                      })(tData, tNode, isClassBased, templateStylingKey));
                  } else
                    residual = (function(tData, tNode, isClassBased) {
                      let residual = void 0;
                      const directiveEnd = tNode.directiveEnd;
                      for (
                        let i = 1 + tNode.directiveStylingLast;
                        i < directiveEnd;
                        i++
                      )
                        residual = collectStylingFromTAttrs(
                          residual,
                          tData[i].hostAttrs,
                          isClassBased
                        );
                      return collectStylingFromTAttrs(
                        residual,
                        tNode.attrs,
                        isClassBased
                      );
                    })(tData, tNode, isClassBased);
              }
              return (
                void 0 !== residual &&
                  (isClassBased
                    ? (tNode.residualClasses = residual)
                    : (tNode.residualStyles = residual)),
                stylingKey
              );
            })(tData, tNode, tStylingKey, isClassBased)),
            (function(
              tData,
              tNode,
              tStylingKeyWithStatic,
              index,
              isHostBinding,
              isClassBinding
            ) {
              let tBindings = isClassBinding
                  ? tNode.classBindings
                  : tNode.styleBindings,
                tmplHead = getTStylingRangePrev(tBindings),
                tmplTail = getTStylingRangeNext(tBindings);
              tData[index] = tStylingKeyWithStatic;
              let tStylingKey,
                isKeyDuplicateOfStatic = !1;
              if (Array.isArray(tStylingKeyWithStatic)) {
                const staticKeyValueArray = tStylingKeyWithStatic;
                (tStylingKey = staticKeyValueArray[1]),
                  (null === tStylingKey ||
                    keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) >
                      0) &&
                    (isKeyDuplicateOfStatic = !0);
              } else tStylingKey = tStylingKeyWithStatic;
              if (isHostBinding)
                if (0 !== tmplTail) {
                  const previousNode = getTStylingRangePrev(
                    tData[tmplHead + 1]
                  );
                  (tData[index + 1] = toTStylingRange(previousNode, tmplHead)),
                    0 !== previousNode &&
                      (tData[previousNode + 1] = setTStylingRangeNext(
                        tData[previousNode + 1],
                        index
                      )),
                    (tData[tmplHead + 1] =
                      (131071 & tData[tmplHead + 1]) | (index << 17));
                } else
                  (tData[index + 1] = toTStylingRange(tmplHead, 0)),
                    0 !== tmplHead &&
                      (tData[tmplHead + 1] = setTStylingRangeNext(
                        tData[tmplHead + 1],
                        index
                      )),
                    (tmplHead = index);
              else
                (tData[index + 1] = toTStylingRange(tmplTail, 0)),
                  0 === tmplHead
                    ? (tmplHead = index)
                    : (tData[tmplTail + 1] = setTStylingRangeNext(
                        tData[tmplTail + 1],
                        index
                      )),
                  (tmplTail = index);
              isKeyDuplicateOfStatic &&
                (tData[index + 1] = setTStylingRangePrevDuplicate(
                  tData[index + 1]
                )),
                markDuplicates(tData, tStylingKey, index, !0),
                markDuplicates(tData, tStylingKey, index, !1),
                (function(tNode, tStylingKey, tData, index, isClassBinding) {
                  const residual = isClassBinding
                    ? tNode.residualClasses
                    : tNode.residualStyles;
                  null != residual &&
                    'string' == typeof tStylingKey &&
                    keyValueArrayIndexOf(residual, tStylingKey) >= 0 &&
                    (tData[index + 1] = setTStylingRangeNextDuplicate(
                      tData[index + 1]
                    ));
                })(tNode, tStylingKey, tData, index, isClassBinding),
                (tBindings = toTStylingRange(tmplHead, tmplTail)),
                isClassBinding
                  ? (tNode.classBindings = tBindings)
                  : (tNode.styleBindings = tBindings);
            })(
              tData,
              tNode,
              tStylingKey,
              bindingIndex,
              isHostBindings,
              isClassBased
            );
        }
      }
      function collectStylingFromDirectives(
        hostDirectiveDef,
        tData,
        tNode,
        stylingKey,
        isClassBased
      ) {
        let currentDirective = null;
        const directiveEnd = tNode.directiveEnd;
        let directiveStylingLast = tNode.directiveStylingLast;
        for (
          -1 === directiveStylingLast
            ? (directiveStylingLast = tNode.directiveStart)
            : directiveStylingLast++;
          directiveStylingLast < directiveEnd &&
          ((currentDirective = tData[directiveStylingLast]),
          (stylingKey = collectStylingFromTAttrs(
            stylingKey,
            currentDirective.hostAttrs,
            isClassBased
          )),
          currentDirective !== hostDirectiveDef);

        )
          directiveStylingLast++;
        return (
          null !== hostDirectiveDef &&
            (tNode.directiveStylingLast = directiveStylingLast),
          stylingKey
        );
      }
      function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
        const desiredMarker = isClassBased ? 1 : 2;
        let currentMarker = -1;
        if (null !== attrs)
          for (let i = 0; i < attrs.length; i++) {
            const item = attrs[i];
            'number' == typeof item
              ? (currentMarker = item)
              : currentMarker === desiredMarker &&
                (Array.isArray(stylingKey) ||
                  (stylingKey = void 0 === stylingKey ? [] : ['', stylingKey]),
                keyValueArraySet(
                  stylingKey,
                  item,
                  !!isClassBased || attrs[++i]
                ));
          }
        return void 0 === stylingKey ? null : stylingKey;
      }
      function updateStyling(
        tView,
        tNode,
        lView,
        renderer,
        prop,
        value,
        isClassBased,
        bindingIndex
      ) {
        if (3 !== tNode.type) return;
        const tData = tView.data,
          tRange = tData[bindingIndex + 1];
        isStylingValuePresent(
          1 == (1 & tRange)
            ? findStylingValue(
                tData,
                tNode,
                lView,
                prop,
                getTStylingRangeNext(tRange),
                isClassBased
              )
            : void 0
        ) ||
          (isStylingValuePresent(value) ||
            ((function(tStylingRange) {
              return 2 == (2 & tStylingRange);
            })(tRange) &&
              (value = findStylingValue(
                tData,
                null,
                lView,
                prop,
                bindingIndex,
                isClassBased
              ))),
          (function(renderer, isClassBased, rNode, prop, value) {
            const isProcedural = isProceduralRenderer(renderer);
            if (isClassBased)
              value
                ? isProcedural
                  ? renderer.addClass(rNode, prop)
                  : rNode.classList.add(prop)
                : isProcedural
                ? renderer.removeClass(rNode, prop)
                : rNode.classList.remove(prop);
            else {
              const flags = -1 == prop.indexOf('-') ? void 0 : 2;
              null == value
                ? isProcedural
                  ? renderer.removeStyle(rNode, prop, flags)
                  : rNode.style.removeProperty(prop)
                : isProcedural
                ? renderer.setStyle(rNode, prop, value, flags)
                : rNode.style.setProperty(prop, value);
            }
          })(
            renderer,
            isClassBased,
            getNativeByIndex(getSelectedIndex(), lView),
            prop,
            value
          ));
      }
      function findStylingValue(
        tData,
        tNode,
        lView,
        prop,
        index,
        isClassBased
      ) {
        const isPrevDirection = null === tNode;
        let value = void 0;
        for (; index > 0; ) {
          const rawKey = tData[index],
            containsStatics = Array.isArray(rawKey),
            key = containsStatics ? rawKey[1] : rawKey,
            isStylingMap = null === key;
          let valueAtLViewIndex = lView[index + 1];
          valueAtLViewIndex === NO_CHANGE &&
            (valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY$3 : void 0);
          let currentValue = isStylingMap
            ? keyValueArrayGet(valueAtLViewIndex, prop)
            : key === prop
            ? valueAtLViewIndex
            : void 0;
          if (
            (containsStatics &&
              !isStylingValuePresent(currentValue) &&
              (currentValue = keyValueArrayGet(rawKey, prop)),
            isStylingValuePresent(currentValue) &&
              ((value = currentValue), isPrevDirection))
          )
            return value;
          const tRange = tData[index + 1];
          index = isPrevDirection
            ? getTStylingRangePrev(tRange)
            : getTStylingRangeNext(tRange);
        }
        if (null !== tNode) {
          let residual = isClassBased
            ? tNode.residualClasses
            : tNode.residualStyles;
          null != residual && (value = keyValueArrayGet(residual, prop));
        }
        return value;
      }
      function isStylingValuePresent(value) {
        return void 0 !== value;
      }
      function hasStylingInputShadow(tNode, isClassBased) {
        return 0 != (tNode.flags & (isClassBased ? 16 : 32));
      }
      function ɵɵtext(index, value = '') {
        const lView = getLView(),
          tView = getTView(),
          adjustedIndex = index + 20,
          tNode = tView.firstCreatePass
            ? getOrCreateTNode(tView, lView[6], index, 3, null, null)
            : tView.data[adjustedIndex],
          textNative = (lView[adjustedIndex] = createTextNode(
            value,
            lView[11]
          ));
        appendChild(tView, lView, textNative, tNode),
          setPreviousOrParentTNode(tNode, !1);
      }
      function ɵɵtextInterpolate(v0) {
        return ɵɵtextInterpolate1('', v0, ''), ɵɵtextInterpolate;
      }
      function ɵɵtextInterpolate1(prefix, v0, suffix) {
        const lView = getLView(),
          interpolated = interpolation1(lView, prefix, v0, suffix);
        return (
          interpolated !== NO_CHANGE &&
            textBindingInternal(lView, getSelectedIndex(), interpolated),
          ɵɵtextInterpolate1
        );
      }
      function ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {
        const lView = getLView(),
          interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
        return (
          interpolated !== NO_CHANGE &&
            textBindingInternal(lView, getSelectedIndex(), interpolated),
          ɵɵtextInterpolate2
        );
      }
      function ɵɵclassMapInterpolate1(prefix, v0, suffix) {
        checkStylingMap(
          keyValueArraySet,
          classStringParser,
          interpolation1(getLView(), prefix, v0, suffix),
          !0
        );
      }
      function ɵɵclassMapInterpolate2(prefix, v0, i0, v1, suffix) {
        checkStylingMap(
          keyValueArraySet,
          classStringParser,
          interpolation2(getLView(), prefix, v0, i0, v1, suffix),
          !0
        );
      }
      function ɵɵclassMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
        checkStylingMap(
          keyValueArraySet,
          classStringParser,
          (function(lView, prefix, v0, i0, v1, i1, v2, suffix) {
            const different = bindingUpdated3(
              lView,
              getBindingIndex(),
              v0,
              v1,
              v2
            );
            return (
              incrementBindingIndex(3),
              different
                ? prefix +
                  renderStringify(v0) +
                  i0 +
                  renderStringify(v1) +
                  i1 +
                  renderStringify(v2) +
                  suffix
                : NO_CHANGE
            );
          })(getLView(), prefix, v0, i0, v1, i1, v2, suffix),
          !0
        );
      }
      function ɵɵhostProperty(propName, value, sanitizer) {
        const lView = getLView();
        return (
          bindingUpdated(lView, nextBindingIndex(), value) &&
            elementPropertyInternal(
              getTView(),
              getSelectedTNode(),
              lView,
              propName,
              value,
              lView[11],
              sanitizer,
              !0
            ),
          ɵɵhostProperty
        );
      }
      function LifecycleHooksFeature(component, def) {
        const rootTView = readPatchedLView(component)[1],
          dirIndex = rootTView.data.length - 1;
        registerPostOrderHooks(rootTView, {
          directiveStart: dirIndex,
          directiveEnd: dirIndex + 1
        });
      }
      function ɵɵInheritDefinitionFeature(definition) {
        let superType = Object.getPrototypeOf(definition.type.prototype)
            .constructor,
          shouldInheritFields = !0;
        const inheritanceChain = [definition];
        for (; superType; ) {
          let superDef = void 0;
          if (isComponentDef(definition))
            superDef = superType.ɵcmp || superType.ɵdir;
          else {
            if (superType.ɵcmp)
              throw new Error('Directives cannot inherit Components');
            superDef = superType.ɵdir;
          }
          if (superDef) {
            if (shouldInheritFields) {
              inheritanceChain.push(superDef);
              const writeableDef = definition;
              (writeableDef.inputs = maybeUnwrapEmpty(definition.inputs)),
                (writeableDef.declaredInputs = maybeUnwrapEmpty(
                  definition.declaredInputs
                )),
                (writeableDef.outputs = maybeUnwrapEmpty(definition.outputs));
              const superHostBindings = superDef.hostBindings;
              superHostBindings &&
                inheritHostBindings(definition, superHostBindings);
              const superViewQuery = superDef.viewQuery,
                superContentQueries = superDef.contentQueries;
              if (
                (superViewQuery && inheritViewQuery(definition, superViewQuery),
                superContentQueries &&
                  inheritContentQueries(definition, superContentQueries),
                fillProperties(definition.inputs, superDef.inputs),
                fillProperties(
                  definition.declaredInputs,
                  superDef.declaredInputs
                ),
                fillProperties(definition.outputs, superDef.outputs),
                isComponentDef(superDef) && superDef.data.animation)
              ) {
                const defData = definition.data;
                defData.animation = (defData.animation || []).concat(
                  superDef.data.animation
                );
              }
              (writeableDef.afterContentChecked =
                writeableDef.afterContentChecked ||
                superDef.afterContentChecked),
                (writeableDef.afterContentInit =
                  definition.afterContentInit || superDef.afterContentInit),
                (writeableDef.afterViewChecked =
                  definition.afterViewChecked || superDef.afterViewChecked),
                (writeableDef.afterViewInit =
                  definition.afterViewInit || superDef.afterViewInit),
                (writeableDef.doCheck = definition.doCheck || superDef.doCheck),
                (writeableDef.onDestroy =
                  definition.onDestroy || superDef.onDestroy),
                (writeableDef.onInit = definition.onInit || superDef.onInit);
            }
            const features = superDef.features;
            if (features)
              for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                feature && feature.ngInherit && feature(definition),
                  feature === ɵɵInheritDefinitionFeature &&
                    (shouldInheritFields = !1);
              }
          }
          superType = Object.getPrototypeOf(superType);
        }
        !(function(inheritanceChain) {
          let hostVars = 0,
            hostAttrs = null;
          for (let i = inheritanceChain.length - 1; i >= 0; i--) {
            const def = inheritanceChain[i];
            (def.hostVars = hostVars += def.hostVars),
              (def.hostAttrs = mergeHostAttrs(
                def.hostAttrs,
                (hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs))
              ));
          }
        })(inheritanceChain);
      }
      function maybeUnwrapEmpty(value) {
        return value === EMPTY_OBJ ? {} : value === EMPTY_ARRAY ? [] : value;
      }
      function inheritViewQuery(definition, superViewQuery) {
        const prevViewQuery = definition.viewQuery;
        definition.viewQuery = prevViewQuery
          ? (rf, ctx) => {
              superViewQuery(rf, ctx), prevViewQuery(rf, ctx);
            }
          : superViewQuery;
      }
      function inheritContentQueries(definition, superContentQueries) {
        const prevContentQueries = definition.contentQueries;
        definition.contentQueries = prevContentQueries
          ? (rf, ctx, directiveIndex) => {
              superContentQueries(rf, ctx, directiveIndex),
                prevContentQueries(rf, ctx, directiveIndex);
            }
          : superContentQueries;
      }
      function inheritHostBindings(definition, superHostBindings) {
        const prevHostBindings = definition.hostBindings;
        definition.hostBindings = prevHostBindings
          ? (rf, ctx) => {
              superHostBindings(rf, ctx), prevHostBindings(rf, ctx);
            }
          : superHostBindings;
      }
      class SimpleChange {
        constructor(previousValue, currentValue, firstChange) {
          (this.previousValue = previousValue),
            (this.currentValue = currentValue),
            (this.firstChange = firstChange);
        }
        isFirstChange() {
          return this.firstChange;
        }
      }
      function ɵɵNgOnChangesFeature(definition) {
        definition.type.prototype.ngOnChanges &&
          ((definition.setInput = ngOnChangesSetInput),
          (definition.onChanges = function() {
            const simpleChangesStore = getSimpleChangesStore(this),
              current = simpleChangesStore && simpleChangesStore.current;
            if (current) {
              const previous = simpleChangesStore.previous;
              if (previous === EMPTY_OBJ) simpleChangesStore.previous = current;
              else for (let key in current) previous[key] = current[key];
              (simpleChangesStore.current = null), this.ngOnChanges(current);
            }
          }));
      }
      function ngOnChangesSetInput(instance, value, publicName, privateName) {
        const simpleChangesStore =
            getSimpleChangesStore(instance) ||
            (function(instance, store) {
              return (instance.__ngSimpleChanges__ = store);
            })(instance, { previous: EMPTY_OBJ, current: null }),
          current =
            simpleChangesStore.current || (simpleChangesStore.current = {}),
          previous = simpleChangesStore.previous,
          declaredName = this.declaredInputs[publicName],
          previousChange = previous[declaredName];
        (current[declaredName] = new SimpleChange(
          previousChange && previousChange.currentValue,
          value,
          previous === EMPTY_OBJ
        )),
          (instance[privateName] = value);
      }
      function getSimpleChangesStore(instance) {
        return instance.__ngSimpleChanges__ || null;
      }
      function resolveProvider$1(
        provider,
        tInjectables,
        lInjectablesBlueprint,
        isComponent,
        isViewProvider
      ) {
        if (((provider = resolveForwardRef(provider)), Array.isArray(provider)))
          for (let i = 0; i < provider.length; i++)
            resolveProvider$1(
              provider[i],
              tInjectables,
              lInjectablesBlueprint,
              isComponent,
              isViewProvider
            );
        else {
          const tView = getTView(),
            lView = getLView();
          let token = isTypeProvider(provider)
              ? provider
              : resolveForwardRef(provider.provide),
            providerFactory = providerToFactory(provider);
          const tNode = getPreviousOrParentTNode(),
            beginIndex = 65535 & tNode.providerIndexes,
            endIndex = tNode.directiveStart,
            cptViewProvidersCount = tNode.providerIndexes >> 16;
          if (isTypeProvider(provider) || !provider.multi) {
            const factory = new NodeInjectorFactory(
                providerFactory,
                isViewProvider,
                ɵɵdirectiveInject
              ),
              existingFactoryIndex = indexOf(
                token,
                tInjectables,
                isViewProvider
                  ? beginIndex
                  : beginIndex + cptViewProvidersCount,
                endIndex
              );
            -1 === existingFactoryIndex
              ? (diPublicInInjector(
                  getOrCreateNodeInjectorForNode(tNode, lView),
                  tView,
                  token
                ),
                registerDestroyHooksIfSupported(
                  tView,
                  provider,
                  tInjectables.length
                ),
                tInjectables.push(token),
                tNode.directiveStart++,
                tNode.directiveEnd++,
                isViewProvider && (tNode.providerIndexes += 65536),
                lInjectablesBlueprint.push(factory),
                lView.push(factory))
              : ((lInjectablesBlueprint[existingFactoryIndex] = factory),
                (lView[existingFactoryIndex] = factory));
          } else {
            const existingProvidersFactoryIndex = indexOf(
                token,
                tInjectables,
                beginIndex + cptViewProvidersCount,
                endIndex
              ),
              existingViewProvidersFactoryIndex = indexOf(
                token,
                tInjectables,
                beginIndex,
                beginIndex + cptViewProvidersCount
              ),
              doesProvidersFactoryExist =
                existingProvidersFactoryIndex >= 0 &&
                lInjectablesBlueprint[existingProvidersFactoryIndex],
              doesViewProvidersFactoryExist =
                existingViewProvidersFactoryIndex >= 0 &&
                lInjectablesBlueprint[existingViewProvidersFactoryIndex];
            if (
              (isViewProvider && !doesViewProvidersFactoryExist) ||
              (!isViewProvider && !doesProvidersFactoryExist)
            ) {
              diPublicInInjector(
                getOrCreateNodeInjectorForNode(tNode, lView),
                tView,
                token
              );
              const factory = (function(
                factoryFn,
                index,
                isViewProvider,
                isComponent,
                f
              ) {
                const factory = new NodeInjectorFactory(
                  factoryFn,
                  isViewProvider,
                  ɵɵdirectiveInject
                );
                return (
                  (factory.multi = []),
                  (factory.index = index),
                  (factory.componentProviders = 0),
                  multiFactoryAdd(factory, f, isComponent && !isViewProvider),
                  factory
                );
              })(
                isViewProvider
                  ? multiViewProvidersFactoryResolver
                  : multiProvidersFactoryResolver,
                lInjectablesBlueprint.length,
                isViewProvider,
                isComponent,
                providerFactory
              );
              !isViewProvider &&
                doesViewProvidersFactoryExist &&
                (lInjectablesBlueprint[
                  existingViewProvidersFactoryIndex
                ].providerFactory = factory),
                registerDestroyHooksIfSupported(
                  tView,
                  provider,
                  tInjectables.length,
                  0
                ),
                tInjectables.push(token),
                tNode.directiveStart++,
                tNode.directiveEnd++,
                isViewProvider && (tNode.providerIndexes += 65536),
                lInjectablesBlueprint.push(factory),
                lView.push(factory);
            } else
              registerDestroyHooksIfSupported(
                tView,
                provider,
                existingProvidersFactoryIndex > -1
                  ? existingProvidersFactoryIndex
                  : existingViewProvidersFactoryIndex,
                multiFactoryAdd(
                  lInjectablesBlueprint[
                    isViewProvider
                      ? existingViewProvidersFactoryIndex
                      : existingProvidersFactoryIndex
                  ],
                  providerFactory,
                  !isViewProvider && isComponent
                )
              );
            !isViewProvider &&
              isComponent &&
              doesViewProvidersFactoryExist &&
              lInjectablesBlueprint[existingViewProvidersFactoryIndex]
                .componentProviders++;
          }
        }
      }
      function registerDestroyHooksIfSupported(
        tView,
        provider,
        contextIndex,
        indexInFactory
      ) {
        const providerIsTypeProvider = isTypeProvider(provider);
        if (providerIsTypeProvider || provider.useClass) {
          const ngOnDestroy = (provider.useClass || provider).prototype
            .ngOnDestroy;
          if (ngOnDestroy) {
            const hooks = tView.destroyHooks || (tView.destroyHooks = []);
            if (!providerIsTypeProvider && provider.multi) {
              const existingCallbacksIndex = hooks.indexOf(contextIndex);
              -1 === existingCallbacksIndex
                ? hooks.push(contextIndex, [indexInFactory, ngOnDestroy])
                : hooks[existingCallbacksIndex + 1].push(
                    indexInFactory,
                    ngOnDestroy
                  );
            } else hooks.push(contextIndex, ngOnDestroy);
          }
        }
      }
      function multiFactoryAdd(multiFactory, factory, isComponentProvider) {
        return (
          isComponentProvider && multiFactory.componentProviders++,
          multiFactory.multi.push(factory) - 1
        );
      }
      function indexOf(item, arr, begin, end) {
        for (let i = begin; i < end; i++) if (arr[i] === item) return i;
        return -1;
      }
      function multiProvidersFactoryResolver(_, tData, lData, tNode) {
        return multiResolve(this.multi, []);
      }
      function multiViewProvidersFactoryResolver(_, tData, lView, tNode) {
        const factories = this.multi;
        let result;
        if (this.providerFactory) {
          const componentCount = this.providerFactory.componentProviders,
            multiProviders = getNodeInjectable(
              lView,
              lView[1],
              this.providerFactory.index,
              tNode
            );
          (result = multiProviders.slice(0, componentCount)),
            multiResolve(factories, result);
          for (let i = componentCount; i < multiProviders.length; i++)
            result.push(multiProviders[i]);
        } else (result = []), multiResolve(factories, result);
        return result;
      }
      function multiResolve(factories, result) {
        for (let i = 0; i < factories.length; i++)
          result.push((0, factories[i])());
        return result;
      }
      function ɵɵProvidersFeature(providers, viewProviders = []) {
        return definition => {
          definition.providersResolver = (def, processProvidersFn) =>
            (function(def, providers, viewProviders) {
              const tView = getTView();
              if (tView.firstCreatePass) {
                const isComponent = isComponentDef(def);
                resolveProvider$1(
                  viewProviders,
                  tView.data,
                  tView.blueprint,
                  isComponent,
                  !0
                ),
                  resolveProvider$1(
                    providers,
                    tView.data,
                    tView.blueprint,
                    isComponent,
                    !1
                  );
              }
            })(
              def,
              processProvidersFn ? processProvidersFn(providers) : providers,
              viewProviders
            );
        };
      }
      ɵɵNgOnChangesFeature.ngInherit = !0;
      class ComponentFactory {}
      class _NullComponentFactoryResolver {
        resolveComponentFactory(component) {
          throw (function(component) {
            const error = Error(
              `No component factory found for ${stringify(
                component
              )}. Did you add it to @NgModule.entryComponents?`
            );
            return (error.ngComponent = component), error;
          })(component);
        }
      }
      let ComponentFactoryResolver = (() => {
          class ComponentFactoryResolver {}
          return (
            (ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver()),
            ComponentFactoryResolver
          );
        })(),
        ElementRef = (() => {
          class ElementRef {
            constructor(nativeElement) {
              this.nativeElement = nativeElement;
            }
          }
          return (
            (ElementRef.__NG_ELEMENT_ID__ = () =>
              SWITCH_ELEMENT_REF_FACTORY(ElementRef)),
            ElementRef
          );
        })();
      const SWITCH_ELEMENT_REF_FACTORY = function(ElementRefToken) {
        return createElementRef(
          ElementRefToken,
          getPreviousOrParentTNode(),
          getLView()
        );
      };
      class RendererFactory2 {}
      var RendererStyleFlags2 = (function(RendererStyleFlags2) {
        return (
          (RendererStyleFlags2[(RendererStyleFlags2.Important = 1)] =
            'Important'),
          (RendererStyleFlags2[(RendererStyleFlags2.DashCase = 2)] =
            'DashCase'),
          RendererStyleFlags2
        );
      })({});
      let Renderer2 = (() => {
        class Renderer2 {}
        return (
          (Renderer2.__NG_ELEMENT_ID__ = () => SWITCH_RENDERER2_FACTORY()),
          Renderer2
        );
      })();
      const SWITCH_RENDERER2_FACTORY = function() {
        const lView = getLView(),
          nodeAtIndex = getComponentLViewByIndex(
            getPreviousOrParentTNode().index,
            lView
          );
        return (function(view) {
          const renderer = view[11];
          if (isProceduralRenderer(renderer)) return renderer;
          throw new Error(
            'Cannot inject Renderer2 when the application uses Renderer3!'
          );
        })(isLView(nodeAtIndex) ? nodeAtIndex : lView);
      };
      let Sanitizer = (() => {
        class Sanitizer {}
        return (
          (Sanitizer.ɵprov = ɵɵdefineInjectable({
            token: Sanitizer,
            providedIn: 'root',
            factory: () => null
          })),
          Sanitizer
        );
      })();
      class Version {
        constructor(full) {
          (this.full = full),
            (this.major = full.split('.')[0]),
            (this.minor = full.split('.')[1]),
            (this.patch = full
              .split('.')
              .slice(2)
              .join('.'));
        }
      }
      const VERSION = new Version('10.0.4');
      class DefaultIterableDifferFactory {
        constructor() {}
        supports(obj) {
          return isListLikeIterable(obj);
        }
        create(trackByFn) {
          return new DefaultIterableDiffer(trackByFn);
        }
      }
      const trackByIdentity = (index, item) => item;
      class DefaultIterableDiffer {
        constructor(trackByFn) {
          (this.length = 0),
            (this._linkedRecords = null),
            (this._unlinkedRecords = null),
            (this._previousItHead = null),
            (this._itHead = null),
            (this._itTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._movesHead = null),
            (this._movesTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null),
            (this._identityChangesHead = null),
            (this._identityChangesTail = null),
            (this._trackByFn = trackByFn || trackByIdentity);
        }
        forEachItem(fn) {
          let record;
          for (record = this._itHead; null !== record; record = record._next)
            fn(record);
        }
        forEachOperation(fn) {
          let nextIt = this._itHead,
            nextRemove = this._removalsHead,
            addRemoveOffset = 0,
            moveOffsets = null;
          for (; nextIt || nextRemove; ) {
            const record =
                !nextRemove ||
                (nextIt &&
                  nextIt.currentIndex <
                    getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets))
                  ? nextIt
                  : nextRemove,
              adjPreviousIndex = getPreviousIndex(
                record,
                addRemoveOffset,
                moveOffsets
              ),
              currentIndex = record.currentIndex;
            if (record === nextRemove)
              addRemoveOffset--, (nextRemove = nextRemove._nextRemoved);
            else if (((nextIt = nextIt._next), null == record.previousIndex))
              addRemoveOffset++;
            else {
              moveOffsets || (moveOffsets = []);
              const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset,
                localCurrentIndex = currentIndex - addRemoveOffset;
              if (localMovePreviousIndex != localCurrentIndex) {
                for (let i = 0; i < localMovePreviousIndex; i++) {
                  const offset =
                      i < moveOffsets.length
                        ? moveOffsets[i]
                        : (moveOffsets[i] = 0),
                    index = offset + i;
                  localCurrentIndex <= index &&
                    index < localMovePreviousIndex &&
                    (moveOffsets[i] = offset + 1);
                }
                moveOffsets[record.previousIndex] =
                  localCurrentIndex - localMovePreviousIndex;
              }
            }
            adjPreviousIndex !== currentIndex &&
              fn(record, adjPreviousIndex, currentIndex);
          }
        }
        forEachPreviousItem(fn) {
          let record;
          for (
            record = this._previousItHead;
            null !== record;
            record = record._nextPrevious
          )
            fn(record);
        }
        forEachAddedItem(fn) {
          let record;
          for (
            record = this._additionsHead;
            null !== record;
            record = record._nextAdded
          )
            fn(record);
        }
        forEachMovedItem(fn) {
          let record;
          for (
            record = this._movesHead;
            null !== record;
            record = record._nextMoved
          )
            fn(record);
        }
        forEachRemovedItem(fn) {
          let record;
          for (
            record = this._removalsHead;
            null !== record;
            record = record._nextRemoved
          )
            fn(record);
        }
        forEachIdentityChange(fn) {
          let record;
          for (
            record = this._identityChangesHead;
            null !== record;
            record = record._nextIdentityChange
          )
            fn(record);
        }
        diff(collection) {
          if (
            (null == collection && (collection = []),
            !isListLikeIterable(collection))
          )
            throw new Error(
              `Error trying to diff '${stringify(
                collection
              )}'. Only arrays and iterables are allowed`
            );
          return this.check(collection) ? this : null;
        }
        onDestroy() {}
        check(collection) {
          this._reset();
          let index,
            item,
            itemTrackBy,
            record = this._itHead,
            mayBeDirty = !1;
          if (Array.isArray(collection)) {
            this.length = collection.length;
            for (let index = 0; index < this.length; index++)
              (item = collection[index]),
                (itemTrackBy = this._trackByFn(index, item)),
                null !== record && Object.is(record.trackById, itemTrackBy)
                  ? (mayBeDirty &&
                      (record = this._verifyReinsertion(
                        record,
                        item,
                        itemTrackBy,
                        index
                      )),
                    Object.is(record.item, item) ||
                      this._addIdentityChange(record, item))
                  : ((record = this._mismatch(
                      record,
                      item,
                      itemTrackBy,
                      index
                    )),
                    (mayBeDirty = !0)),
                (record = record._next);
          } else
            (index = 0),
              (function(obj, fn) {
                if (Array.isArray(obj))
                  for (let i = 0; i < obj.length; i++) fn(obj[i]);
                else {
                  const iterator = obj[getSymbolIterator()]();
                  let item;
                  for (; !(item = iterator.next()).done; ) fn(item.value);
                }
              })(collection, item => {
                (itemTrackBy = this._trackByFn(index, item)),
                  null !== record && Object.is(record.trackById, itemTrackBy)
                    ? (mayBeDirty &&
                        (record = this._verifyReinsertion(
                          record,
                          item,
                          itemTrackBy,
                          index
                        )),
                      Object.is(record.item, item) ||
                        this._addIdentityChange(record, item))
                    : ((record = this._mismatch(
                        record,
                        item,
                        itemTrackBy,
                        index
                      )),
                      (mayBeDirty = !0)),
                  (record = record._next),
                  index++;
              }),
              (this.length = index);
          return (
            this._truncate(record), (this.collection = collection), this.isDirty
          );
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._movesHead ||
            null !== this._removalsHead ||
            null !== this._identityChangesHead
          );
        }
        _reset() {
          if (this.isDirty) {
            let record, nextRecord;
            for (
              record = this._previousItHead = this._itHead;
              null !== record;
              record = record._next
            )
              record._nextPrevious = record._next;
            for (
              record = this._additionsHead;
              null !== record;
              record = record._nextAdded
            )
              record.previousIndex = record.currentIndex;
            for (
              this._additionsHead = this._additionsTail = null,
                record = this._movesHead;
              null !== record;
              record = nextRecord
            )
              (record.previousIndex = record.currentIndex),
                (nextRecord = record._nextMoved);
            (this._movesHead = this._movesTail = null),
              (this._removalsHead = this._removalsTail = null),
              (this._identityChangesHead = this._identityChangesTail = null);
          }
        }
        _mismatch(record, item, itemTrackBy, index) {
          let previousRecord;
          return (
            null === record
              ? (previousRecord = this._itTail)
              : ((previousRecord = record._prev), this._remove(record)),
            null !==
            (record =
              null === this._linkedRecords
                ? null
                : this._linkedRecords.get(itemTrackBy, index))
              ? (Object.is(record.item, item) ||
                  this._addIdentityChange(record, item),
                this._moveAfter(record, previousRecord, index))
              : null !==
                (record =
                  null === this._unlinkedRecords
                    ? null
                    : this._unlinkedRecords.get(itemTrackBy, null))
              ? (Object.is(record.item, item) ||
                  this._addIdentityChange(record, item),
                this._reinsertAfter(record, previousRecord, index))
              : (record = this._addAfter(
                  new IterableChangeRecord_(item, itemTrackBy),
                  previousRecord,
                  index
                )),
            record
          );
        }
        _verifyReinsertion(record, item, itemTrackBy, index) {
          let reinsertRecord =
            null === this._unlinkedRecords
              ? null
              : this._unlinkedRecords.get(itemTrackBy, null);
          return (
            null !== reinsertRecord
              ? (record = this._reinsertAfter(
                  reinsertRecord,
                  record._prev,
                  index
                ))
              : record.currentIndex != index &&
                ((record.currentIndex = index),
                this._addToMoves(record, index)),
            record
          );
        }
        _truncate(record) {
          for (; null !== record; ) {
            const nextRecord = record._next;
            this._addToRemovals(this._unlink(record)), (record = nextRecord);
          }
          null !== this._unlinkedRecords && this._unlinkedRecords.clear(),
            null !== this._additionsTail &&
              (this._additionsTail._nextAdded = null),
            null !== this._movesTail && (this._movesTail._nextMoved = null),
            null !== this._itTail && (this._itTail._next = null),
            null !== this._removalsTail &&
              (this._removalsTail._nextRemoved = null),
            null !== this._identityChangesTail &&
              (this._identityChangesTail._nextIdentityChange = null);
        }
        _reinsertAfter(record, prevRecord, index) {
          null !== this._unlinkedRecords &&
            this._unlinkedRecords.remove(record);
          const prev = record._prevRemoved,
            next = record._nextRemoved;
          return (
            null === prev
              ? (this._removalsHead = next)
              : (prev._nextRemoved = next),
            null === next
              ? (this._removalsTail = prev)
              : (next._prevRemoved = prev),
            this._insertAfter(record, prevRecord, index),
            this._addToMoves(record, index),
            record
          );
        }
        _moveAfter(record, prevRecord, index) {
          return (
            this._unlink(record),
            this._insertAfter(record, prevRecord, index),
            this._addToMoves(record, index),
            record
          );
        }
        _addAfter(record, prevRecord, index) {
          return (
            this._insertAfter(record, prevRecord, index),
            (this._additionsTail =
              null === this._additionsTail
                ? (this._additionsHead = record)
                : (this._additionsTail._nextAdded = record)),
            record
          );
        }
        _insertAfter(record, prevRecord, index) {
          const next = null === prevRecord ? this._itHead : prevRecord._next;
          return (
            (record._next = next),
            (record._prev = prevRecord),
            null === next ? (this._itTail = record) : (next._prev = record),
            null === prevRecord
              ? (this._itHead = record)
              : (prevRecord._next = record),
            null === this._linkedRecords &&
              (this._linkedRecords = new _DuplicateMap()),
            this._linkedRecords.put(record),
            (record.currentIndex = index),
            record
          );
        }
        _remove(record) {
          return this._addToRemovals(this._unlink(record));
        }
        _unlink(record) {
          null !== this._linkedRecords && this._linkedRecords.remove(record);
          const prev = record._prev,
            next = record._next;
          return (
            null === prev ? (this._itHead = next) : (prev._next = next),
            null === next ? (this._itTail = prev) : (next._prev = prev),
            record
          );
        }
        _addToMoves(record, toIndex) {
          return (
            record.previousIndex === toIndex ||
              (this._movesTail =
                null === this._movesTail
                  ? (this._movesHead = record)
                  : (this._movesTail._nextMoved = record)),
            record
          );
        }
        _addToRemovals(record) {
          return (
            null === this._unlinkedRecords &&
              (this._unlinkedRecords = new _DuplicateMap()),
            this._unlinkedRecords.put(record),
            (record.currentIndex = null),
            (record._nextRemoved = null),
            null === this._removalsTail
              ? ((this._removalsTail = this._removalsHead = record),
                (record._prevRemoved = null))
              : ((record._prevRemoved = this._removalsTail),
                (this._removalsTail = this._removalsTail._nextRemoved = record)),
            record
          );
        }
        _addIdentityChange(record, item) {
          return (
            (record.item = item),
            (this._identityChangesTail =
              null === this._identityChangesTail
                ? (this._identityChangesHead = record)
                : (this._identityChangesTail._nextIdentityChange = record)),
            record
          );
        }
      }
      class IterableChangeRecord_ {
        constructor(item, trackById) {
          (this.item = item),
            (this.trackById = trackById),
            (this.currentIndex = null),
            (this.previousIndex = null),
            (this._nextPrevious = null),
            (this._prev = null),
            (this._next = null),
            (this._prevDup = null),
            (this._nextDup = null),
            (this._prevRemoved = null),
            (this._nextRemoved = null),
            (this._nextAdded = null),
            (this._nextMoved = null),
            (this._nextIdentityChange = null);
        }
      }
      class _DuplicateItemRecordList {
        constructor() {
          (this._head = null), (this._tail = null);
        }
        add(record) {
          null === this._head
            ? ((this._head = this._tail = record),
              (record._nextDup = null),
              (record._prevDup = null))
            : ((this._tail._nextDup = record),
              (record._prevDup = this._tail),
              (record._nextDup = null),
              (this._tail = record));
        }
        get(trackById, atOrAfterIndex) {
          let record;
          for (record = this._head; null !== record; record = record._nextDup)
            if (
              (null === atOrAfterIndex ||
                atOrAfterIndex <= record.currentIndex) &&
              Object.is(record.trackById, trackById)
            )
              return record;
          return null;
        }
        remove(record) {
          const prev = record._prevDup,
            next = record._nextDup;
          return (
            null === prev ? (this._head = next) : (prev._nextDup = next),
            null === next ? (this._tail = prev) : (next._prevDup = prev),
            null === this._head
          );
        }
      }
      class _DuplicateMap {
        constructor() {
          this.map = new Map();
        }
        put(record) {
          const key = record.trackById;
          let duplicates = this.map.get(key);
          duplicates ||
            ((duplicates = new _DuplicateItemRecordList()),
            this.map.set(key, duplicates)),
            duplicates.add(record);
        }
        get(trackById, atOrAfterIndex) {
          const recordList = this.map.get(trackById);
          return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
        }
        remove(record) {
          const key = record.trackById;
          return (
            this.map.get(key).remove(record) && this.map.delete(key), record
          );
        }
        get isEmpty() {
          return 0 === this.map.size;
        }
        clear() {
          this.map.clear();
        }
      }
      function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
        const previousIndex = item.previousIndex;
        if (null === previousIndex) return previousIndex;
        let moveOffset = 0;
        return (
          moveOffsets &&
            previousIndex < moveOffsets.length &&
            (moveOffset = moveOffsets[previousIndex]),
          previousIndex + addRemoveOffset + moveOffset
        );
      }
      class DefaultKeyValueDifferFactory {
        constructor() {}
        supports(obj) {
          return obj instanceof Map || isJsObject(obj);
        }
        create() {
          return new DefaultKeyValueDiffer();
        }
      }
      class DefaultKeyValueDiffer {
        constructor() {
          (this._records = new Map()),
            (this._mapHead = null),
            (this._appendAfter = null),
            (this._previousMapHead = null),
            (this._changesHead = null),
            (this._changesTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null);
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._changesHead ||
            null !== this._removalsHead
          );
        }
        forEachItem(fn) {
          let record;
          for (record = this._mapHead; null !== record; record = record._next)
            fn(record);
        }
        forEachPreviousItem(fn) {
          let record;
          for (
            record = this._previousMapHead;
            null !== record;
            record = record._nextPrevious
          )
            fn(record);
        }
        forEachChangedItem(fn) {
          let record;
          for (
            record = this._changesHead;
            null !== record;
            record = record._nextChanged
          )
            fn(record);
        }
        forEachAddedItem(fn) {
          let record;
          for (
            record = this._additionsHead;
            null !== record;
            record = record._nextAdded
          )
            fn(record);
        }
        forEachRemovedItem(fn) {
          let record;
          for (
            record = this._removalsHead;
            null !== record;
            record = record._nextRemoved
          )
            fn(record);
        }
        diff(map) {
          if (map) {
            if (!(map instanceof Map || isJsObject(map)))
              throw new Error(
                `Error trying to diff '${stringify(
                  map
                )}'. Only maps and objects are allowed`
              );
          } else map = new Map();
          return this.check(map) ? this : null;
        }
        onDestroy() {}
        check(map) {
          this._reset();
          let insertBefore = this._mapHead;
          if (
            ((this._appendAfter = null),
            this._forEach(map, (value, key) => {
              if (insertBefore && insertBefore.key === key)
                this._maybeAddToChanges(insertBefore, value),
                  (this._appendAfter = insertBefore),
                  (insertBefore = insertBefore._next);
              else {
                const record = this._getOrCreateRecordForKey(key, value);
                insertBefore = this._insertBeforeOrAppend(insertBefore, record);
              }
            }),
            insertBefore)
          ) {
            insertBefore._prev && (insertBefore._prev._next = null),
              (this._removalsHead = insertBefore);
            for (
              let record = insertBefore;
              null !== record;
              record = record._nextRemoved
            )
              record === this._mapHead && (this._mapHead = null),
                this._records.delete(record.key),
                (record._nextRemoved = record._next),
                (record.previousValue = record.currentValue),
                (record.currentValue = null),
                (record._prev = null),
                (record._next = null);
          }
          return (
            this._changesTail && (this._changesTail._nextChanged = null),
            this._additionsTail && (this._additionsTail._nextAdded = null),
            this.isDirty
          );
        }
        _insertBeforeOrAppend(before, record) {
          if (before) {
            const prev = before._prev;
            return (
              (record._next = before),
              (record._prev = prev),
              (before._prev = record),
              prev && (prev._next = record),
              before === this._mapHead && (this._mapHead = record),
              (this._appendAfter = before),
              before
            );
          }
          return (
            this._appendAfter
              ? ((this._appendAfter._next = record),
                (record._prev = this._appendAfter))
              : (this._mapHead = record),
            (this._appendAfter = record),
            null
          );
        }
        _getOrCreateRecordForKey(key, value) {
          if (this._records.has(key)) {
            const record = this._records.get(key);
            this._maybeAddToChanges(record, value);
            const prev = record._prev,
              next = record._next;
            return (
              prev && (prev._next = next),
              next && (next._prev = prev),
              (record._next = null),
              (record._prev = null),
              record
            );
          }
          const record = new KeyValueChangeRecord_(key);
          return (
            this._records.set(key, record),
            (record.currentValue = value),
            this._addToAdditions(record),
            record
          );
        }
        _reset() {
          if (this.isDirty) {
            let record;
            for (
              this._previousMapHead = this._mapHead,
                record = this._previousMapHead;
              null !== record;
              record = record._next
            )
              record._nextPrevious = record._next;
            for (
              record = this._changesHead;
              null !== record;
              record = record._nextChanged
            )
              record.previousValue = record.currentValue;
            for (
              record = this._additionsHead;
              null != record;
              record = record._nextAdded
            )
              record.previousValue = record.currentValue;
            (this._changesHead = this._changesTail = null),
              (this._additionsHead = this._additionsTail = null),
              (this._removalsHead = null);
          }
        }
        _maybeAddToChanges(record, newValue) {
          Object.is(newValue, record.currentValue) ||
            ((record.previousValue = record.currentValue),
            (record.currentValue = newValue),
            this._addToChanges(record));
        }
        _addToAdditions(record) {
          null === this._additionsHead
            ? (this._additionsHead = this._additionsTail = record)
            : ((this._additionsTail._nextAdded = record),
              (this._additionsTail = record));
        }
        _addToChanges(record) {
          null === this._changesHead
            ? (this._changesHead = this._changesTail = record)
            : ((this._changesTail._nextChanged = record),
              (this._changesTail = record));
        }
        _forEach(obj, fn) {
          obj instanceof Map
            ? obj.forEach(fn)
            : Object.keys(obj).forEach(k => fn(obj[k], k));
        }
      }
      class KeyValueChangeRecord_ {
        constructor(key) {
          (this.key = key),
            (this.previousValue = null),
            (this.currentValue = null),
            (this._nextPrevious = null),
            (this._next = null),
            (this._prev = null),
            (this._nextAdded = null),
            (this._nextRemoved = null),
            (this._nextChanged = null);
        }
      }
      let IterableDiffers = (() => {
          class IterableDiffers {
            constructor(factories) {
              this.factories = factories;
            }
            static create(factories, parent) {
              if (null != parent) {
                const copied = parent.factories.slice();
                factories = factories.concat(copied);
              }
              return new IterableDiffers(factories);
            }
            static extend(factories) {
              return {
                provide: IterableDiffers,
                useFactory: parent => {
                  if (!parent)
                    throw new Error(
                      'Cannot extend IterableDiffers without a parent injector'
                    );
                  return IterableDiffers.create(factories, parent);
                },
                deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
              };
            }
            find(iterable) {
              const factory = this.factories.find(f => f.supports(iterable));
              if (null != factory) return factory;
              throw new Error(
                `Cannot find a differ supporting object '${iterable}' of type '${((type = iterable),
                type.name || typeof type)}'`
              );
              var type;
            }
          }
          return (
            (IterableDiffers.ɵprov = ɵɵdefineInjectable({
              token: IterableDiffers,
              providedIn: 'root',
              factory: () =>
                new IterableDiffers([new DefaultIterableDifferFactory()])
            })),
            IterableDiffers
          );
        })(),
        KeyValueDiffers = (() => {
          class KeyValueDiffers {
            constructor(factories) {
              this.factories = factories;
            }
            static create(factories, parent) {
              if (parent) {
                const copied = parent.factories.slice();
                factories = factories.concat(copied);
              }
              return new KeyValueDiffers(factories);
            }
            static extend(factories) {
              return {
                provide: KeyValueDiffers,
                useFactory: parent => {
                  if (!parent)
                    throw new Error(
                      'Cannot extend KeyValueDiffers without a parent injector'
                    );
                  return KeyValueDiffers.create(factories, parent);
                },
                deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
              };
            }
            find(kv) {
              const factory = this.factories.find(f => f.supports(kv));
              if (factory) return factory;
              throw new Error(`Cannot find a differ supporting object '${kv}'`);
            }
          }
          return (
            (KeyValueDiffers.ɵprov = ɵɵdefineInjectable({
              token: KeyValueDiffers,
              providedIn: 'root',
              factory: () =>
                new KeyValueDiffers([new DefaultKeyValueDifferFactory()])
            })),
            KeyValueDiffers
          );
        })();
      const keyValDiff = [new DefaultKeyValueDifferFactory()],
        defaultIterableDiffers = new IterableDiffers([
          new DefaultIterableDifferFactory()
        ]),
        defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
      let TemplateRef = (() => {
        class TemplateRef {}
        return (
          (TemplateRef.__NG_ELEMENT_ID__ = () =>
            SWITCH_TEMPLATE_REF_FACTORY(TemplateRef, ElementRef)),
          TemplateRef
        );
      })();
      const SWITCH_TEMPLATE_REF_FACTORY = function(
        TemplateRefToken,
        ElementRefToken
      ) {
        return createTemplateRef(
          TemplateRefToken,
          ElementRefToken,
          getPreviousOrParentTNode(),
          getLView()
        );
      };
      let ViewContainerRef = (() => {
        class ViewContainerRef {}
        return (
          (ViewContainerRef.__NG_ELEMENT_ID__ = () =>
            SWITCH_VIEW_CONTAINER_REF_FACTORY(ViewContainerRef, ElementRef)),
          ViewContainerRef
        );
      })();
      const SWITCH_VIEW_CONTAINER_REF_FACTORY = function(
          ViewContainerRefToken,
          ElementRefToken
        ) {
          return createContainerRef(
            ViewContainerRefToken,
            ElementRefToken,
            getPreviousOrParentTNode(),
            getLView()
          );
        },
        NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
      class ComponentFactoryResolver$1 extends ComponentFactoryResolver {
        constructor(ngModule) {
          super(), (this.ngModule = ngModule);
        }
        resolveComponentFactory(component) {
          const componentDef = getComponentDef(component);
          return new ComponentFactory$1(componentDef, this.ngModule);
        }
      }
      function toRefArray(map) {
        const array = [];
        for (let nonMinified in map)
          map.hasOwnProperty(nonMinified) &&
            array.push({
              propName: map[nonMinified],
              templateName: nonMinified
            });
        return array;
      }
      const SCHEDULER = new InjectionToken('SCHEDULER_TOKEN', {
        providedIn: 'root',
        factory: () => defaultScheduler
      });
      class ComponentFactory$1 extends ComponentFactory {
        constructor(componentDef, ngModule) {
          super(),
            (this.componentDef = componentDef),
            (this.ngModule = ngModule),
            (this.componentType = componentDef.type),
            (this.selector = componentDef.selectors
              .map(stringifyCSSSelector)
              .join(',')),
            (this.ngContentSelectors = componentDef.ngContentSelectors
              ? componentDef.ngContentSelectors
              : []),
            (this.isBoundToModule = !!ngModule);
        }
        get inputs() {
          return toRefArray(this.componentDef.inputs);
        }
        get outputs() {
          return toRefArray(this.componentDef.outputs);
        }
        create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
          const rootViewInjector = (ngModule = ngModule || this.ngModule)
              ? (function(rootViewInjector, moduleInjector) {
                  return {
                    get: (token, notFoundValue, flags) => {
                      const value = rootViewInjector.get(
                        token,
                        NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,
                        flags
                      );
                      return value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||
                        notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR
                        ? value
                        : moduleInjector.get(token, notFoundValue, flags);
                    }
                  };
                })(injector, ngModule.injector)
              : injector,
            rendererFactory = rootViewInjector.get(
              RendererFactory2,
              domRendererFactory3
            ),
            sanitizer = rootViewInjector.get(Sanitizer, null),
            hostRenderer = rendererFactory.createRenderer(
              null,
              this.componentDef
            ),
            elementName = this.componentDef.selectors[0][0] || 'div',
            hostRNode = rootSelectorOrNode
              ? (function(renderer, elementOrSelector, encapsulation) {
                  if (isProceduralRenderer(renderer))
                    return renderer.selectRootElement(
                      elementOrSelector,
                      encapsulation === ViewEncapsulation$1.ShadowDom
                    );
                  let rElement =
                    'string' == typeof elementOrSelector
                      ? renderer.querySelector(elementOrSelector)
                      : elementOrSelector;
                  return (rElement.textContent = ''), rElement;
                })(
                  hostRenderer,
                  rootSelectorOrNode,
                  this.componentDef.encapsulation
                )
              : elementCreate(
                  elementName,
                  rendererFactory.createRenderer(null, this.componentDef),
                  (function(elementName) {
                    const name = elementName.toLowerCase();
                    return 'svg' === name
                      ? 'http://www.w3.org/2000/svg'
                      : 'math' === name
                      ? 'http://www.w3.org/1998/MathML/'
                      : null;
                  })(elementName)
                ),
            rootFlags = this.componentDef.onPush ? 576 : 528,
            rootContext = {
              components: [],
              scheduler: defaultScheduler,
              clean: CLEAN_PROMISE,
              playerHandler: null,
              flags: 0
            },
            rootTView = createTView(
              0,
              -1,
              null,
              1,
              0,
              null,
              null,
              null,
              null,
              null
            ),
            rootLView = createLView(
              null,
              rootTView,
              rootContext,
              rootFlags,
              null,
              null,
              rendererFactory,
              hostRenderer,
              sanitizer,
              rootViewInjector
            );
          let component, tElementNode;
          enterView(rootLView, null);
          try {
            const componentView = (function(
              rNode,
              def,
              rootView,
              rendererFactory,
              hostRenderer,
              sanitizer
            ) {
              const tView = rootView[1];
              rootView[20] = rNode;
              const tNode = getOrCreateTNode(tView, null, 0, 3, null, null),
                mergedAttrs = (tNode.mergedAttrs = def.hostAttrs);
              null !== mergedAttrs &&
                (computeStaticStyling(tNode, mergedAttrs, !0),
                null !== rNode &&
                  (setUpAttributes(hostRenderer, rNode, mergedAttrs),
                  null !== tNode.classes &&
                    writeDirectClass(hostRenderer, rNode, tNode.classes),
                  null !== tNode.styles &&
                    writeDirectStyle(hostRenderer, rNode, tNode.styles)));
              const viewRenderer = rendererFactory.createRenderer(rNode, def),
                componentView = createLView(
                  rootView,
                  getOrCreateTComponentView(def),
                  null,
                  def.onPush ? 64 : 16,
                  rootView[20],
                  tNode,
                  rendererFactory,
                  viewRenderer,
                  void 0
                );
              return (
                tView.firstCreatePass &&
                  (diPublicInInjector(
                    getOrCreateNodeInjectorForNode(tNode, rootView),
                    tView,
                    def.type
                  ),
                  markAsComponentHost(tView, tNode),
                  initTNodeFlags(tNode, rootView.length, 1)),
                addToViewTree(rootView, componentView),
                (rootView[20] = componentView)
              );
            })(
              hostRNode,
              this.componentDef,
              rootLView,
              rendererFactory,
              hostRenderer
            );
            if (hostRNode)
              if (rootSelectorOrNode)
                setUpAttributes(hostRenderer, hostRNode, [
                  'ng-version',
                  VERSION.full
                ]);
              else {
                const { attrs: attrs, classes: classes } = (function(selector) {
                  const attrs = [],
                    classes = [];
                  let i = 1,
                    mode = 2;
                  for (; i < selector.length; ) {
                    let valueOrMarker = selector[i];
                    if ('string' == typeof valueOrMarker)
                      2 === mode
                        ? '' !== valueOrMarker &&
                          attrs.push(valueOrMarker, selector[++i])
                        : 8 === mode && classes.push(valueOrMarker);
                    else {
                      if (!isPositive(mode)) break;
                      mode = valueOrMarker;
                    }
                    i++;
                  }
                  return { attrs: attrs, classes: classes };
                })(this.componentDef.selectors[0]);
                attrs && setUpAttributes(hostRenderer, hostRNode, attrs),
                  classes &&
                    classes.length > 0 &&
                    writeDirectClass(
                      hostRenderer,
                      hostRNode,
                      classes.join(' ')
                    );
              }
            if (
              ((tElementNode = getTNode(rootTView, 0)),
              void 0 !== projectableNodes)
            ) {
              const projection = (tElementNode.projection = []);
              for (let i = 0; i < this.ngContentSelectors.length; i++) {
                const nodesforSlot = projectableNodes[i];
                projection.push(
                  null != nodesforSlot ? Array.from(nodesforSlot) : null
                );
              }
            }
            (component = (function(
              componentView,
              componentDef,
              rootLView,
              rootContext,
              hostFeatures
            ) {
              const tView = rootLView[1],
                component = (function(tView, lView, def) {
                  const rootTNode = getPreviousOrParentTNode();
                  tView.firstCreatePass &&
                    (def.providersResolver && def.providersResolver(def),
                    generateExpandoInstructionBlock(tView, rootTNode, 1),
                    baseResolveDirective(tView, lView, def));
                  const directive = getNodeInjectable(
                    lView,
                    tView,
                    lView.length - 1,
                    rootTNode
                  );
                  attachPatchData(directive, lView);
                  const native = getNativeByTNode(rootTNode, lView);
                  return native && attachPatchData(native, lView), directive;
                })(tView, rootLView, componentDef);
              rootContext.components.push(component),
                (componentView[8] = component),
                hostFeatures &&
                  hostFeatures.forEach(feature =>
                    feature(component, componentDef)
                  ),
                componentDef.contentQueries &&
                  componentDef.contentQueries(
                    1,
                    component,
                    rootLView.length - 1
                  );
              const rootTNode = getPreviousOrParentTNode();
              if (
                tView.firstCreatePass &&
                (null !== componentDef.hostBindings ||
                  null !== componentDef.hostAttrs)
              ) {
                setSelectedIndex(rootTNode.index - 20);
                const rootTView = rootLView[1];
                addHostBindingsToExpandoInstructions(rootTView, componentDef),
                  growHostVarsSpace(
                    rootTView,
                    rootLView,
                    componentDef.hostVars
                  ),
                  invokeHostBindingsInCreationMode(componentDef, component);
              }
              return component;
            })(componentView, this.componentDef, rootLView, rootContext, [
              LifecycleHooksFeature
            ])),
              renderView(rootTView, rootLView, null);
          } finally {
            leaveView();
          }
          const componentRef = new ComponentRef$1(
            this.componentType,
            component,
            createElementRef(ElementRef, tElementNode, rootLView),
            rootLView,
            tElementNode
          );
          return (rootTView.node.child = tElementNode), componentRef;
        }
      }
      class ComponentRef$1 extends class {} {
        constructor(componentType, instance, location, _rootLView, _tNode) {
          super(),
            (this.location = location),
            (this._rootLView = _rootLView),
            (this._tNode = _tNode),
            (this.destroyCbs = []),
            (this.instance = instance),
            (this.hostView = this.changeDetectorRef = new RootViewRef(
              _rootLView
            )),
            (function(tView, tParentNode, index, lView) {
              let tNode = tView.node;
              null == tNode &&
                (tView.node = tNode = createTNode(0, null, 2, -1, null, null)),
                (lView[6] = tNode);
            })(_rootLView[1], 0, 0, _rootLView),
            (this.componentType = componentType);
        }
        get injector() {
          return new NodeInjector(this._tNode, this._rootLView);
        }
        destroy() {
          this.destroyCbs &&
            (this.destroyCbs.forEach(fn => fn()),
            (this.destroyCbs = null),
            !this.hostView.destroyed && this.hostView.destroy());
        }
        onDestroy(callback) {
          this.destroyCbs && this.destroyCbs.push(callback);
        }
      }
      const u = void 0;
      var localeEn = [
        'en',
        [['a', 'p'], ['AM', 'PM'], u],
        [['AM', 'PM'], u, u],
        [
          ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
          ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
          [
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday'
          ],
          ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']
        ],
        u,
        [
          ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
          [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec'
          ],
          [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December'
          ]
        ],
        u,
        [['B', 'A'], ['BC', 'AD'], ['Before Christ', 'Anno Domini']],
        0,
        [6, 0],
        ['M/d/yy', 'MMM d, y', 'MMMM d, y', 'EEEE, MMMM d, y'],
        ['h:mm a', 'h:mm:ss a', 'h:mm:ss a z', 'h:mm:ss a zzzz'],
        ['{1}, {0}', u, "{1} 'at' {0}", u],
        ['.', ',', ';', '%', '+', '-', 'E', '×', '‰', '∞', 'NaN', ':'],
        ['#,##0.###', '#,##0%', '¤#,##0.00', '#E0'],
        'USD',
        '$',
        'US Dollar',
        {},
        'ltr',
        function(n) {
          let i = Math.floor(Math.abs(n)),
            v = n.toString().replace(/^[^.]*\.?/, '').length;
          return 1 === i && 0 === v ? 1 : 5;
        }
      ];
      let LOCALE_DATA = {};
      function registerLocaleData(data, localeId, extraData) {
        'string' != typeof localeId &&
          ((extraData = localeId), (localeId = data[LocaleDataIndex.LocaleId])),
          (localeId = localeId.toLowerCase().replace(/_/g, '-')),
          (LOCALE_DATA[localeId] = data),
          extraData &&
            (LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData);
      }
      function findLocaleData(locale) {
        const normalizedLocale = (function(locale) {
          return locale.toLowerCase().replace(/_/g, '-');
        })(locale);
        let match = getLocaleData(normalizedLocale);
        if (match) return match;
        const parentLocale = normalizedLocale.split('-')[0];
        if (((match = getLocaleData(parentLocale)), match)) return match;
        if ('en' === parentLocale) return localeEn;
        throw new Error(`Missing locale data for the locale "${locale}".`);
      }
      function getLocaleCurrencyCode(locale) {
        return findLocaleData(locale)[LocaleDataIndex.CurrencyCode] || null;
      }
      function getLocalePluralCase(locale) {
        return findLocaleData(locale)[LocaleDataIndex.PluralCase];
      }
      function getLocaleData(normalizedLocale) {
        return (
          normalizedLocale in LOCALE_DATA ||
            (LOCALE_DATA[normalizedLocale] =
              _global.ng &&
              _global.ng.common &&
              _global.ng.common.locales &&
              _global.ng.common.locales[normalizedLocale]),
          LOCALE_DATA[normalizedLocale]
        );
      }
      var LocaleDataIndex = (function(LocaleDataIndex) {
        return (
          (LocaleDataIndex[(LocaleDataIndex.LocaleId = 0)] = 'LocaleId'),
          (LocaleDataIndex[(LocaleDataIndex.DayPeriodsFormat = 1)] =
            'DayPeriodsFormat'),
          (LocaleDataIndex[(LocaleDataIndex.DayPeriodsStandalone = 2)] =
            'DayPeriodsStandalone'),
          (LocaleDataIndex[(LocaleDataIndex.DaysFormat = 3)] = 'DaysFormat'),
          (LocaleDataIndex[(LocaleDataIndex.DaysStandalone = 4)] =
            'DaysStandalone'),
          (LocaleDataIndex[(LocaleDataIndex.MonthsFormat = 5)] =
            'MonthsFormat'),
          (LocaleDataIndex[(LocaleDataIndex.MonthsStandalone = 6)] =
            'MonthsStandalone'),
          (LocaleDataIndex[(LocaleDataIndex.Eras = 7)] = 'Eras'),
          (LocaleDataIndex[(LocaleDataIndex.FirstDayOfWeek = 8)] =
            'FirstDayOfWeek'),
          (LocaleDataIndex[(LocaleDataIndex.WeekendRange = 9)] =
            'WeekendRange'),
          (LocaleDataIndex[(LocaleDataIndex.DateFormat = 10)] = 'DateFormat'),
          (LocaleDataIndex[(LocaleDataIndex.TimeFormat = 11)] = 'TimeFormat'),
          (LocaleDataIndex[(LocaleDataIndex.DateTimeFormat = 12)] =
            'DateTimeFormat'),
          (LocaleDataIndex[(LocaleDataIndex.NumberSymbols = 13)] =
            'NumberSymbols'),
          (LocaleDataIndex[(LocaleDataIndex.NumberFormats = 14)] =
            'NumberFormats'),
          (LocaleDataIndex[(LocaleDataIndex.CurrencyCode = 15)] =
            'CurrencyCode'),
          (LocaleDataIndex[(LocaleDataIndex.CurrencySymbol = 16)] =
            'CurrencySymbol'),
          (LocaleDataIndex[(LocaleDataIndex.CurrencyName = 17)] =
            'CurrencyName'),
          (LocaleDataIndex[(LocaleDataIndex.Currencies = 18)] = 'Currencies'),
          (LocaleDataIndex[(LocaleDataIndex.Directionality = 19)] =
            'Directionality'),
          (LocaleDataIndex[(LocaleDataIndex.PluralCase = 20)] = 'PluralCase'),
          (LocaleDataIndex[(LocaleDataIndex.ExtraData = 21)] = 'ExtraData'),
          LocaleDataIndex
        );
      })({});
      const pluralMapping = ['zero', 'one', 'two', 'few', 'many'],
        ICU_BLOCK_REGEXP = /^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/,
        SUBTEMPLATE_REGEXP = /�\/?\*(\d+:\d+)�/gi,
        PH_REGEXP = /�(\/?[#*!]\d+):?\d*�/gi,
        BINDING_REGEXP = /�(\d+):?\d*�/gi,
        ICU_REGEXP = /({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi;
      function extractParts(pattern) {
        if (!pattern) return [];
        let prevPos = 0;
        const braceStack = [],
          results = [],
          braces = /[{}]/g;
        let match;
        for (braces.lastIndex = 0; (match = braces.exec(pattern)); ) {
          const pos = match.index;
          if ('}' == match[0]) {
            if ((braceStack.pop(), 0 == braceStack.length)) {
              const block = pattern.substring(prevPos, pos);
              ICU_BLOCK_REGEXP.test(block)
                ? results.push(parseICUBlock(block))
                : results.push(block),
                (prevPos = pos + 1);
            }
          } else {
            if (0 == braceStack.length) {
              const substring = pattern.substring(prevPos, pos);
              results.push(substring), (prevPos = pos + 1);
            }
            braceStack.push('{');
          }
        }
        const substring = pattern.substring(prevPos);
        return results.push(substring), results;
      }
      function parseICUBlock(pattern) {
        const cases = [],
          values = [];
        let icuType = 1,
          mainBinding = 0;
        const parts = extractParts(
          (pattern = pattern.replace(ICU_BLOCK_REGEXP, function(
            str,
            binding,
            type
          ) {
            return (
              (icuType = 'select' === type ? 0 : 1),
              (mainBinding = parseInt(binding.substr(1), 10)),
              ''
            );
          }))
        );
        for (let pos = 0; pos < parts.length; ) {
          let key = parts[pos++].trim();
          1 === icuType && (key = key.replace(/\s*(?:=)?(\w+)\s*/, '$1')),
            key.length && cases.push(key);
          const blocks = extractParts(parts[pos++]);
          cases.length > values.length && values.push(blocks);
        }
        return {
          type: icuType,
          mainBinding: mainBinding,
          cases: cases,
          values: values
        };
      }
      function removeInnerTemplateTranslation(message) {
        let match,
          tagMatched,
          res = '',
          index = 0,
          inTemplate = !1;
        for (; null !== (match = SUBTEMPLATE_REGEXP.exec(message)); )
          inTemplate
            ? match[0] === `�/*${tagMatched}�` &&
              ((index = match.index), (inTemplate = !1))
            : ((res += message.substring(index, match.index + match[0].length)),
              (tagMatched = match[1]),
              (inTemplate = !0));
        return (res += message.substr(index)), res;
      }
      function generateBindingUpdateOpCodes(
        str,
        destinationNode,
        attrName,
        sanitizeFn = null
      ) {
        const updateOpCodes = [null, null],
          textParts = str.split(BINDING_REGEXP);
        let mask = 0;
        for (let j = 0; j < textParts.length; j++) {
          const textValue = textParts[j];
          if (1 & j) {
            const bindingIndex = parseInt(textValue, 10);
            updateOpCodes.push(-1 - bindingIndex),
              (mask |= toMaskBit(bindingIndex));
          } else '' !== textValue && updateOpCodes.push(textValue);
        }
        return (
          updateOpCodes.push((destinationNode << 2) | (attrName ? 1 : 0)),
          attrName && updateOpCodes.push(attrName, sanitizeFn),
          (updateOpCodes[0] = mask),
          (updateOpCodes[1] = updateOpCodes.length - 2),
          updateOpCodes
        );
      }
      function getBindingMask(icuExpression, mask = 0) {
        let match;
        mask |= toMaskBit(icuExpression.mainBinding);
        for (let i = 0; i < icuExpression.values.length; i++) {
          const valueArr = icuExpression.values[i];
          for (let j = 0; j < valueArr.length; j++) {
            const value = valueArr[j];
            if ('string' == typeof value)
              for (; (match = BINDING_REGEXP.exec(value)); )
                mask |= toMaskBit(parseInt(match[1], 10));
            else mask = getBindingMask(value, mask);
          }
        }
        return mask;
      }
      const i18nIndexStack = [];
      let i18nIndexStackPointer = -1;
      function toMaskBit(bindingIndex) {
        return 1 << Math.min(bindingIndex, 31);
      }
      const parentIndexStack = [];
      let i18nVarsCount;
      function allocNodeIndex(startIndex) {
        return startIndex + i18nVarsCount++;
      }
      function appendI18nNode(tView, tNode, parentTNode, previousTNode, lView) {
        const nextNode = tNode.next;
        previousTNode || (previousTNode = parentTNode),
          previousTNode === parentTNode && tNode !== parentTNode.child
            ? ((tNode.next = parentTNode.child), (parentTNode.child = tNode))
            : previousTNode !== parentTNode && tNode !== previousTNode.next
            ? ((tNode.next = previousTNode.next), (previousTNode.next = tNode))
            : (tNode.next = null),
          parentTNode !== lView[6] && (tNode.parent = parentTNode);
        let cursor = tNode.next;
        for (; cursor; )
          cursor.next === tNode && (cursor.next = nextNode),
            (cursor = cursor.next);
        if (1 === tNode.type)
          return applyProjection(tView, lView, tNode), tNode;
        appendChild(tView, lView, getNativeByTNode(tNode, lView), tNode);
        const slotValue = lView[tNode.index];
        return (
          0 !== tNode.type &&
            isLContainer(slotValue) &&
            appendChild(tView, lView, slotValue[7], tNode),
          tNode
        );
      }
      function isRootTemplateMessage(subTemplateIndex) {
        return void 0 === subTemplateIndex;
      }
      function createDynamicNodeAtIndex(
        tView,
        lView,
        index,
        type,
        native,
        name
      ) {
        const previousOrParentTNode = getPreviousOrParentTNode();
        lView[index + 20] = native;
        const tNode = getOrCreateTNode(
          tView,
          lView[6],
          index,
          type,
          name,
          null
        );
        return (
          previousOrParentTNode &&
            previousOrParentTNode.next === tNode &&
            (previousOrParentTNode.next = null),
          tNode
        );
      }
      function readCreateOpCodes(index, createOpCodes, tView, lView) {
        const renderer = lView[11];
        let currentTNode = null,
          previousTNode = null;
        const visitedNodes = [];
        for (let i = 0; i < createOpCodes.length; i++) {
          const opCode = createOpCodes[i];
          if ('string' == typeof opCode) {
            const textRNode = createTextNode(opCode, renderer),
              textNodeIndex = createOpCodes[++i];
            (previousTNode = currentTNode),
              (currentTNode = createDynamicNodeAtIndex(
                tView,
                lView,
                textNodeIndex,
                3,
                textRNode,
                null
              )),
              visitedNodes.push(textNodeIndex),
              setIsNotParent();
          } else if ('number' == typeof opCode)
            switch (7 & opCode) {
              case 1:
                const destinationNodeIndex = opCode >>> 17;
                let destinationTNode;
                (destinationTNode =
                  destinationNodeIndex === index
                    ? lView[6]
                    : getTNode(tView, destinationNodeIndex)),
                  (previousTNode = appendI18nNode(
                    tView,
                    currentTNode,
                    destinationTNode,
                    previousTNode,
                    lView
                  ));
                break;
              case 0:
                const isParent = opCode >= 0,
                  nodeIndex = (isParent ? opCode : ~opCode) >>> 3;
                visitedNodes.push(nodeIndex),
                  (previousTNode = currentTNode),
                  (currentTNode = getTNode(tView, nodeIndex)),
                  currentTNode &&
                    setPreviousOrParentTNode(currentTNode, isParent);
                break;
              case 5:
                (previousTNode = currentTNode = getTNode(tView, opCode >>> 3)),
                  setPreviousOrParentTNode(currentTNode, !1);
                break;
              case 4:
                const attrName = createOpCodes[++i],
                  attrValue = createOpCodes[++i];
                elementAttributeInternal(
                  getTNode(tView, opCode >>> 3),
                  lView,
                  attrName,
                  attrValue,
                  null,
                  null
                );
                break;
              default:
                throw new Error(
                  `Unable to determine the type of mutate operation for "${opCode}"`
                );
            }
          else
            switch (opCode) {
              case COMMENT_MARKER:
                const commentValue = createOpCodes[++i],
                  commentNodeIndex = createOpCodes[++i],
                  commentRNode = renderer.createComment(commentValue);
                (previousTNode = currentTNode),
                  (currentTNode = createDynamicNodeAtIndex(
                    tView,
                    lView,
                    commentNodeIndex,
                    5,
                    commentRNode,
                    null
                  )),
                  visitedNodes.push(commentNodeIndex),
                  attachPatchData(commentRNode, lView),
                  (currentTNode.activeCaseIndex = null),
                  setIsNotParent();
                break;
              case ELEMENT_MARKER:
                const tagNameValue = createOpCodes[++i],
                  elementNodeIndex = createOpCodes[++i];
                (previousTNode = currentTNode),
                  (currentTNode = createDynamicNodeAtIndex(
                    tView,
                    lView,
                    elementNodeIndex,
                    3,
                    renderer.createElement(tagNameValue),
                    tagNameValue
                  )),
                  visitedNodes.push(elementNodeIndex);
                break;
              default:
                throw new Error(
                  `Unable to determine the type of mutate operation for "${opCode}"`
                );
            }
        }
        return setIsNotParent(), visitedNodes;
      }
      function removeNode(tView, lView, index, markAsDetached) {
        const removedPhTNode = getTNode(tView, index),
          removedPhRNode = getNativeByIndex(index, lView);
        removedPhRNode && nativeRemoveNode(lView[11], removedPhRNode);
        const slotValue = load(lView, index);
        if (isLContainer(slotValue)) {
          const lContainer = slotValue;
          0 !== removedPhTNode.type &&
            nativeRemoveNode(lView[11], lContainer[7]);
        }
        markAsDetached && (removedPhTNode.flags |= 64);
      }
      function ɵɵi18n(index, message, subTemplateIndex) {
        (function(index, message, subTemplateIndex) {
          const tView = getTView();
          (i18nIndexStack[++i18nIndexStackPointer] = index),
            setDelayProjection(!0),
            tView.firstCreatePass &&
              null === tView.data[index + 20] &&
              (function(lView, tView, index, message, subTemplateIndex) {
                const startIndex = tView.blueprint.length - 20;
                i18nVarsCount = 0;
                const previousOrParentTNode = getPreviousOrParentTNode(),
                  parentTNode = getIsParent()
                    ? previousOrParentTNode
                    : previousOrParentTNode && previousOrParentTNode.parent;
                let parentIndex =
                    parentTNode && parentTNode !== lView[6]
                      ? parentTNode.index - 20
                      : index,
                  parentIndexPointer = 0;
                parentIndexStack[parentIndexPointer] = parentIndex;
                const createOpCodes = [];
                if (index > 0 && previousOrParentTNode !== parentTNode) {
                  let previousTNodeIndex = previousOrParentTNode.index - 20;
                  getIsParent() || (previousTNodeIndex = ~previousTNodeIndex),
                    createOpCodes.push((previousTNodeIndex << 3) | 0);
                }
                const updateOpCodes = [],
                  icuExpressions = [];
                if ('' === message && isRootTemplateMessage(subTemplateIndex))
                  createOpCodes.push(
                    message,
                    allocNodeIndex(startIndex),
                    (parentIndex << 17) | 1
                  );
                else {
                  const templateTranslation = (function(
                      message,
                      subTemplateIndex
                    ) {
                      if (isRootTemplateMessage(subTemplateIndex))
                        return removeInnerTemplateTranslation(message);
                      {
                        const start =
                            message.indexOf(`:${subTemplateIndex}�`) +
                            2 +
                            subTemplateIndex.toString().length,
                          end = message.search(
                            new RegExp(`�\\/\\*\\d+:${subTemplateIndex}�`)
                          );
                        return removeInnerTemplateTranslation(
                          message.substring(start, end)
                        );
                      }
                    })(message, subTemplateIndex),
                    msgParts = ((value = templateTranslation),
                    value.replace(NGSP_UNICODE_REGEXP, ' ')).split(PH_REGEXP);
                  for (let i = 0; i < msgParts.length; i++) {
                    let value = msgParts[i];
                    if (1 & i)
                      if ('/' === value.charAt(0)) {
                        if ('#' === value.charAt(1)) {
                          const phIndex = parseInt(value.substr(2), 10);
                          (parentIndex =
                            parentIndexStack[--parentIndexPointer]),
                            createOpCodes.push((phIndex << 3) | 5);
                        }
                      } else {
                        const phIndex = parseInt(value.substr(1), 10),
                          isElement = '#' === value.charAt(0);
                        createOpCodes.push(
                          ((isElement ? phIndex : ~phIndex) << 3) | 0,
                          (parentIndex << 17) | 1
                        ),
                          isElement &&
                            (parentIndexStack[
                              ++parentIndexPointer
                            ] = parentIndex = phIndex);
                      }
                    else {
                      const parts = extractParts(value);
                      for (let j = 0; j < parts.length; j++)
                        if (1 & j) {
                          const icuExpression = parts[j];
                          if ('object' != typeof icuExpression)
                            throw new Error(
                              `Unable to parse ICU expression in "${templateTranslation}" message.`
                            );
                          const icuNodeIndex = allocNodeIndex(startIndex);
                          createOpCodes.push(
                            COMMENT_MARKER,
                            '',
                            icuNodeIndex,
                            (parentIndex << 17) | 1
                          );
                          const mask = getBindingMask(icuExpression);
                          icuStart(
                            icuExpressions,
                            icuExpression,
                            icuNodeIndex,
                            icuNodeIndex
                          );
                          const tIcuIndex = icuExpressions.length - 1;
                          updateOpCodes.push(
                            toMaskBit(icuExpression.mainBinding),
                            3,
                            -1 - icuExpression.mainBinding,
                            (icuNodeIndex << 2) | 2,
                            tIcuIndex,
                            mask,
                            2,
                            (icuNodeIndex << 2) | 3,
                            tIcuIndex
                          );
                        } else if ('' !== parts[j]) {
                          const text = parts[j],
                            hasBinding = text.match(BINDING_REGEXP),
                            textNodeIndex = allocNodeIndex(startIndex);
                          createOpCodes.push(
                            hasBinding ? '' : text,
                            textNodeIndex,
                            (parentIndex << 17) | 1
                          ),
                            hasBinding &&
                              addAllToArray(
                                generateBindingUpdateOpCodes(
                                  text,
                                  textNodeIndex
                                ),
                                updateOpCodes
                              );
                        }
                    }
                  }
                }
                var value;
                i18nVarsCount > 0 &&
                  (function(tView, lView, numSlotsToAlloc) {
                    if (numSlotsToAlloc > 0 && tView.firstCreatePass) {
                      for (let i = 0; i < numSlotsToAlloc; i++)
                        tView.blueprint.push(null),
                          tView.data.push(null),
                          lView.push(null);
                      tView.expandoInstructions
                        ? tView.expandoInstructions.push(numSlotsToAlloc)
                        : (tView.expandoStartIndex += numSlotsToAlloc);
                    }
                  })(tView, lView, i18nVarsCount),
                  (tView.data[index + 20] = {
                    vars: i18nVarsCount,
                    create: createOpCodes,
                    update: updateOpCodes,
                    icus: icuExpressions.length ? icuExpressions : null
                  });
              })(getLView(), tView, index, message, subTemplateIndex);
        })(index, message, subTemplateIndex),
          (function() {
            const lView = getLView();
            !(function(tView, lView) {
              const rootIndex = i18nIndexStack[i18nIndexStackPointer--],
                tI18n = tView.data[rootIndex + 20],
                lastCreatedNode = getPreviousOrParentTNode(),
                visitedNodes = readCreateOpCodes(
                  rootIndex,
                  tI18n.create,
                  tView,
                  lView
                );
              let index = rootIndex + 1;
              for (; index <= lastCreatedNode.index - 20; ) {
                -1 === visitedNodes.indexOf(index) &&
                  removeNode(tView, lView, index, !0);
                const tNode = getTNode(tView, index);
                !tNode ||
                  (0 !== tNode.type && 3 !== tNode.type && 4 !== tNode.type) ||
                  null === tNode.localNames ||
                  (index += tNode.localNames.length >> 1),
                  index++;
              }
            })(getTView(), lView),
              setDelayProjection(!1);
          })();
      }
      function ɵɵi18nAttributes(index, values) {
        !(function(lView, tView, index, values) {
          const previousElementIndex = getPreviousOrParentTNode().index - 20,
            updateOpCodes = [];
          for (let i = 0; i < values.length; i += 2) {
            const attrName = values[i],
              parts = values[i + 1].split(ICU_REGEXP);
            for (let j = 0; j < parts.length; j++) {
              const value = parts[j];
              if (1 & j)
                throw new Error(
                  'ICU expressions are not yet supported in attributes'
                );
              if ('' !== value)
                if (value.match(BINDING_REGEXP))
                  tView.firstCreatePass &&
                    null === tView.data[index + 20] &&
                    addAllToArray(
                      generateBindingUpdateOpCodes(
                        value,
                        previousElementIndex,
                        attrName
                      ),
                      updateOpCodes
                    );
                else {
                  const tNode = getTNode(tView, previousElementIndex);
                  3 === tNode.type &&
                    elementAttributeInternal(
                      tNode,
                      lView,
                      attrName,
                      value,
                      null,
                      null
                    );
                  const dataValue =
                    null !== tNode.inputs && tNode.inputs[attrName];
                  dataValue &&
                    setInputsForProperty(
                      tView,
                      lView,
                      dataValue,
                      attrName,
                      value
                    );
                }
            }
          }
          tView.firstCreatePass &&
            null === tView.data[index + 20] &&
            (tView.data[index + 20] = updateOpCodes);
        })(getLView(), getTView(), index, values);
      }
      let changeMask = 0,
        shiftsCounter = 0;
      function ɵɵi18nExp(value) {
        return (
          bindingUpdated(getLView(), nextBindingIndex(), value) &&
            (changeMask |= 1 << shiftsCounter),
          shiftsCounter++,
          ɵɵi18nExp
        );
      }
      function ɵɵi18nApply(index) {
        if (shiftsCounter) {
          const tView = getTView(),
            tI18n = tView.data[index + 20];
          let updateOpCodes,
            icus = null;
          Array.isArray(tI18n)
            ? (updateOpCodes = tI18n)
            : ((updateOpCodes = tI18n.update), (icus = tI18n.icus));
          const bindingsStartIndex = getBindingIndex() - shiftsCounter - 1,
            lView = getLView();
          !(function readUpdateOpCodes(
            updateOpCodes,
            icus,
            bindingsStartIndex,
            changeMask,
            tView,
            lView,
            bypassCheckBit = !1
          ) {
            let caseCreated = !1;
            for (let i = 0; i < updateOpCodes.length; i++) {
              const checkBit = updateOpCodes[i],
                skipCodes = updateOpCodes[++i];
              if (bypassCheckBit || checkBit & changeMask) {
                let value = '';
                for (let j = i + 1; j <= i + skipCodes; j++) {
                  const opCode = updateOpCodes[j];
                  if ('string' == typeof opCode) value += opCode;
                  else if ('number' == typeof opCode)
                    if (opCode < 0)
                      value += renderStringify(
                        lView[bindingsStartIndex - opCode]
                      );
                    else {
                      const nodeIndex = opCode >>> 2;
                      let tIcuIndex, tIcu, icuTNode;
                      switch (3 & opCode) {
                        case 1:
                          const propName = updateOpCodes[++j],
                            sanitizeFn = updateOpCodes[++j];
                          elementPropertyInternal(
                            tView,
                            getTNode(tView, nodeIndex),
                            lView,
                            propName,
                            value,
                            lView[11],
                            sanitizeFn,
                            !1
                          );
                          break;
                        case 0:
                          textBindingInternal(lView, nodeIndex, value);
                          break;
                        case 2:
                          if (
                            ((tIcuIndex = updateOpCodes[++j]),
                            (tIcu = icus[tIcuIndex]),
                            (icuTNode = getTNode(tView, nodeIndex)),
                            null !== icuTNode.activeCaseIndex)
                          ) {
                            const removeCodes =
                              tIcu.remove[icuTNode.activeCaseIndex];
                            for (let k = 0; k < removeCodes.length; k++) {
                              const removeOpCode = removeCodes[k];
                              switch (7 & removeOpCode) {
                                case 3:
                                  removeNode(
                                    tView,
                                    lView,
                                    removeOpCode >>> 3,
                                    !1
                                  );
                                  break;
                                case 6:
                                  const activeIndex = getTNode(
                                    tView,
                                    removeCodes[k + 1] >>> 3
                                  ).activeCaseIndex;
                                  null !== activeIndex &&
                                    addAllToArray(
                                      icus[removeOpCode >>> 3].remove[
                                        activeIndex
                                      ],
                                      removeCodes
                                    );
                              }
                            }
                          }
                          const caseIndex = getCaseIndex(tIcu, value);
                          (icuTNode.activeCaseIndex =
                            -1 !== caseIndex ? caseIndex : null),
                            caseIndex > -1 &&
                              (readCreateOpCodes(
                                -1,
                                tIcu.create[caseIndex],
                                tView,
                                lView
                              ),
                              (caseCreated = !0));
                          break;
                        case 3:
                          (tIcuIndex = updateOpCodes[++j]),
                            (tIcu = icus[tIcuIndex]),
                            (icuTNode = getTNode(tView, nodeIndex)),
                            null !== icuTNode.activeCaseIndex &&
                              readUpdateOpCodes(
                                tIcu.update[icuTNode.activeCaseIndex],
                                icus,
                                bindingsStartIndex,
                                changeMask,
                                tView,
                                lView,
                                caseCreated
                              );
                      }
                    }
                }
              }
              i += skipCodes;
            }
          })(updateOpCodes, icus, bindingsStartIndex, changeMask, tView, lView),
            (changeMask = 0),
            (shiftsCounter = 0);
        }
      }
      function getCaseIndex(icuExpression, bindingValue) {
        let index = icuExpression.cases.indexOf(bindingValue);
        if (-1 === index)
          switch (icuExpression.type) {
            case 1: {
              const resolvedCase = (function(value, locale) {
                const plural = getLocalePluralCase(locale)(parseInt(value, 10)),
                  result = pluralMapping[plural];
                return void 0 !== result ? result : 'other';
              })(bindingValue, LOCALE_ID);
              (index = icuExpression.cases.indexOf(resolvedCase)),
                -1 === index &&
                  'other' !== resolvedCase &&
                  (index = icuExpression.cases.indexOf('other'));
              break;
            }
            case 0:
              index = icuExpression.cases.indexOf('other');
          }
        return index;
      }
      function icuStart(tIcus, icuExpression, startIndex, expandoStartIndex) {
        const createCodes = [],
          removeCodes = [],
          updateCodes = [],
          vars = [],
          childIcus = [];
        for (let i = 0; i < icuExpression.values.length; i++) {
          const valueArr = icuExpression.values[i],
            nestedIcus = [];
          for (let j = 0; j < valueArr.length; j++) {
            const value = valueArr[j];
            if ('string' != typeof value) {
              const icuIndex = nestedIcus.push(value) - 1;
              valueArr[j] = `\x3c!--�${icuIndex}�--\x3e`;
            }
          }
          const icuCase = parseIcuCase(
            valueArr.join(''),
            startIndex,
            nestedIcus,
            tIcus,
            expandoStartIndex
          );
          createCodes.push(icuCase.create),
            removeCodes.push(icuCase.remove),
            updateCodes.push(icuCase.update),
            vars.push(icuCase.vars),
            childIcus.push(icuCase.childIcus);
        }
        tIcus.push({
          type: icuExpression.type,
          vars: vars,
          childIcus: childIcus,
          cases: icuExpression.cases,
          create: createCodes,
          remove: removeCodes,
          update: updateCodes
        }),
          (i18nVarsCount += Math.max(...vars));
      }
      function parseIcuCase(
        unsafeHtml,
        parentIndex,
        nestedIcus,
        tIcus,
        expandoStartIndex
      ) {
        const inertBodyElement = getInertBodyHelper(
          getDocument()
        ).getInertBodyElement(unsafeHtml);
        if (!inertBodyElement)
          throw new Error('Unable to generate inert body element');
        const opCodes = {
          vars: 0,
          childIcus: [],
          create: [],
          remove: [],
          update: []
        };
        return (
          (function parseNodes(
            currentNode,
            icuCase,
            parentIndex,
            nestedIcus,
            tIcus,
            expandoStartIndex
          ) {
            if (currentNode) {
              const nestedIcusToCreate = [];
              for (; currentNode; ) {
                const nextNode = currentNode.nextSibling,
                  newIndex = expandoStartIndex + ++icuCase.vars;
                switch (currentNode.nodeType) {
                  case Node.ELEMENT_NODE:
                    const element = currentNode,
                      tagName = element.tagName.toLowerCase();
                    if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
                      icuCase.create.push(
                        ELEMENT_MARKER,
                        tagName,
                        newIndex,
                        (parentIndex << 17) | 1
                      );
                      const elAttrs = element.attributes;
                      for (let i = 0; i < elAttrs.length; i++) {
                        const attr = elAttrs.item(i),
                          lowerAttrName = attr.name.toLowerCase();
                        attr.value.match(BINDING_REGEXP)
                          ? VALID_ATTRS.hasOwnProperty(lowerAttrName) &&
                            addAllToArray(
                              URI_ATTRS[lowerAttrName]
                                ? generateBindingUpdateOpCodes(
                                    attr.value,
                                    newIndex,
                                    attr.name,
                                    _sanitizeUrl
                                  )
                                : SRCSET_ATTRS[lowerAttrName]
                                ? generateBindingUpdateOpCodes(
                                    attr.value,
                                    newIndex,
                                    attr.name,
                                    sanitizeSrcset
                                  )
                                : generateBindingUpdateOpCodes(
                                    attr.value,
                                    newIndex,
                                    attr.name
                                  ),
                              icuCase.update
                            )
                          : icuCase.create.push(
                              (newIndex << 3) | 4,
                              attr.name,
                              attr.value
                            );
                      }
                      parseNodes(
                        currentNode.firstChild,
                        icuCase,
                        newIndex,
                        nestedIcus,
                        tIcus,
                        expandoStartIndex
                      ),
                        icuCase.remove.push((newIndex << 3) | 3);
                    } else icuCase.vars--;
                    break;
                  case Node.TEXT_NODE:
                    const value = currentNode.textContent || '',
                      hasBinding = value.match(BINDING_REGEXP);
                    icuCase.create.push(
                      hasBinding ? '' : value,
                      newIndex,
                      (parentIndex << 17) | 1
                    ),
                      icuCase.remove.push((newIndex << 3) | 3),
                      hasBinding &&
                        addAllToArray(
                          generateBindingUpdateOpCodes(value, newIndex),
                          icuCase.update
                        );
                    break;
                  case Node.COMMENT_NODE:
                    const match = NESTED_ICU.exec(
                      currentNode.textContent || ''
                    );
                    if (match) {
                      const nestedIcuIndex = parseInt(match[1], 10);
                      icuCase.create.push(
                        COMMENT_MARKER,
                        '',
                        newIndex,
                        (parentIndex << 17) | 1
                      ),
                        nestedIcusToCreate.push([
                          nestedIcus[nestedIcuIndex],
                          newIndex
                        ]);
                    } else icuCase.vars--;
                    break;
                  default:
                    icuCase.vars--;
                }
                currentNode = nextNode;
              }
              for (let i = 0; i < nestedIcusToCreate.length; i++) {
                const nestedIcu = nestedIcusToCreate[i][0],
                  nestedIcuNodeIndex = nestedIcusToCreate[i][1];
                icuStart(
                  tIcus,
                  nestedIcu,
                  nestedIcuNodeIndex,
                  expandoStartIndex + icuCase.vars
                );
                const nestTIcuIndex = tIcus.length - 1;
                (icuCase.vars += Math.max(...tIcus[nestTIcuIndex].vars)),
                  icuCase.childIcus.push(nestTIcuIndex);
                const mask = getBindingMask(nestedIcu);
                icuCase.update.push(
                  toMaskBit(nestedIcu.mainBinding),
                  3,
                  -1 - nestedIcu.mainBinding,
                  (nestedIcuNodeIndex << 2) | 2,
                  nestTIcuIndex,
                  mask,
                  2,
                  (nestedIcuNodeIndex << 2) | 3,
                  nestTIcuIndex
                ),
                  icuCase.remove.push(
                    (nestTIcuIndex << 3) | 6,
                    (nestedIcuNodeIndex << 3) | 3
                  );
              }
            }
          })(
            (getTemplateContent(inertBodyElement) || inertBodyElement)
              .firstChild,
            opCodes,
            parentIndex,
            nestedIcus,
            tIcus,
            expandoStartIndex
          ),
          opCodes
        );
      }
      const NESTED_ICU = /�(\d+)�/,
        NGSP_UNICODE_REGEXP = /\uE500/g;
      let LOCALE_ID = 'en-US';
      function setLocaleId(localeId) {
        var actual, msg;
        (msg = 'Expected localeId to be defined'),
          null == (actual = localeId) &&
            (function(msg, actual, expected, comparison) {
              throw new Error(
                'ASSERTION ERROR: ' +
                  msg +
                  ` [Expected=> null != ${actual} <=Actual]`
              );
            })(msg, actual),
          'string' == typeof localeId &&
            (LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-'));
      }
      const modules = new Map();
      class NgModuleRef$1 extends NgModuleRef {
        constructor(ngModuleType, _parent) {
          super(),
            (this._parent = _parent),
            (this._bootstrapComponents = []),
            (this.injector = this),
            (this.destroyCbs = []),
            (this.componentFactoryResolver = new ComponentFactoryResolver$1(
              this
            ));
          const ngModuleDef = getNgModuleDef(ngModuleType),
            ngLocaleIdDef = ngModuleType[NG_LOC_ID_DEF] || null;
          ngLocaleIdDef && setLocaleId(ngLocaleIdDef),
            (this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap)),
            (this._r3Injector = createInjectorWithoutInjectorInstances(
              ngModuleType,
              _parent,
              [
                { provide: NgModuleRef, useValue: this },
                {
                  provide: ComponentFactoryResolver,
                  useValue: this.componentFactoryResolver
                }
              ],
              stringify(ngModuleType)
            )),
            this._r3Injector._resolveInjectorDefTypes(),
            (this.instance = this.get(ngModuleType));
        }
        get(
          token,
          notFoundValue = Injector.THROW_IF_NOT_FOUND,
          injectFlags = InjectFlags.Default
        ) {
          return token === Injector ||
            token === NgModuleRef ||
            token === INJECTOR
            ? this
            : this._r3Injector.get(token, notFoundValue, injectFlags);
        }
        destroy() {
          const injector = this._r3Injector;
          !injector.destroyed && injector.destroy(),
            this.destroyCbs.forEach(fn => fn()),
            (this.destroyCbs = null);
        }
        onDestroy(callback) {
          this.destroyCbs.push(callback);
        }
      }
      class NgModuleFactory$1 extends NgModuleFactory {
        constructor(moduleType) {
          super(),
            (this.moduleType = moduleType),
            null !== getNgModuleDef(moduleType) &&
              (function registerNgModuleType(ngModuleType) {
                if (null !== ngModuleType.ɵmod.id) {
                  const id = ngModuleType.ɵmod.id;
                  (function(id, type, incoming) {
                    if (type && type !== incoming)
                      throw new Error(
                        `Duplicate module registered for ${id} - ${stringify(
                          type
                        )} vs ${stringify(type.name)}`
                      );
                  })(id, modules.get(id), ngModuleType),
                    modules.set(id, ngModuleType);
                }
                let imports = ngModuleType.ɵmod.imports;
                imports instanceof Function && (imports = imports()),
                  imports && imports.forEach(i => registerNgModuleType(i));
              })(moduleType);
        }
        create(parentInjector) {
          return new NgModuleRef$1(this.moduleType, parentInjector);
        }
      }
      function ɵɵpureFunction0(slotOffset, pureFn, thisArg) {
        const bindingIndex = getBindingRoot() + slotOffset,
          lView = getLView();
        return lView[bindingIndex] === NO_CHANGE
          ? updateBinding(
              lView,
              bindingIndex,
              thisArg ? pureFn.call(thisArg) : pureFn()
            )
          : (function(lView, bindingIndex) {
              return lView[bindingIndex];
            })(lView, bindingIndex);
      }
      function ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {
        return pureFunction1Internal(
          getLView(),
          getBindingRoot(),
          slotOffset,
          pureFn,
          exp,
          thisArg
        );
      }
      function ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
        return (function(
          lView,
          bindingRoot,
          slotOffset,
          pureFn,
          exp1,
          exp2,
          thisArg
        ) {
          const bindingIndex = bindingRoot + slotOffset;
          return bindingUpdated2(lView, bindingIndex, exp1, exp2)
            ? updateBinding(
                lView,
                bindingIndex + 2,
                thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)
              )
            : getPureFunctionReturnValue(lView, bindingIndex + 2);
        })(
          getLView(),
          getBindingRoot(),
          slotOffset,
          pureFn,
          exp1,
          exp2,
          thisArg
        );
      }
      function ɵɵpureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
        return (function(
          lView,
          bindingRoot,
          slotOffset,
          pureFn,
          exp1,
          exp2,
          exp3,
          thisArg
        ) {
          const bindingIndex = bindingRoot + slotOffset;
          return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3)
            ? updateBinding(
                lView,
                bindingIndex + 3,
                thisArg
                  ? pureFn.call(thisArg, exp1, exp2, exp3)
                  : pureFn(exp1, exp2, exp3)
              )
            : getPureFunctionReturnValue(lView, bindingIndex + 3);
        })(
          getLView(),
          getBindingRoot(),
          slotOffset,
          pureFn,
          exp1,
          exp2,
          exp3,
          thisArg
        );
      }
      function ɵɵpureFunction4(
        slotOffset,
        pureFn,
        exp1,
        exp2,
        exp3,
        exp4,
        thisArg
      ) {
        return (function(
          lView,
          bindingRoot,
          slotOffset,
          pureFn,
          exp1,
          exp2,
          exp3,
          exp4,
          thisArg
        ) {
          const bindingIndex = bindingRoot + slotOffset;
          return (function(lView, bindingIndex, exp1, exp2, exp3, exp4) {
            const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
            return (
              bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different
            );
          })(lView, bindingIndex, exp1, exp2, exp3, exp4)
            ? updateBinding(
                lView,
                bindingIndex + 4,
                thisArg
                  ? pureFn.call(thisArg, exp1, exp2, exp3, exp4)
                  : pureFn(exp1, exp2, exp3, exp4)
              )
            : getPureFunctionReturnValue(lView, bindingIndex + 4);
        })(
          getLView(),
          getBindingRoot(),
          slotOffset,
          pureFn,
          exp1,
          exp2,
          exp3,
          exp4,
          thisArg
        );
      }
      function getPureFunctionReturnValue(lView, returnValueIndex) {
        const lastReturnValue = lView[returnValueIndex];
        return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
      }
      function pureFunction1Internal(
        lView,
        bindingRoot,
        slotOffset,
        pureFn,
        exp,
        thisArg
      ) {
        const bindingIndex = bindingRoot + slotOffset;
        return bindingUpdated(lView, bindingIndex, exp)
          ? updateBinding(
              lView,
              bindingIndex + 1,
              thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)
            )
          : getPureFunctionReturnValue(lView, bindingIndex + 1);
      }
      function ɵɵpipe(index, pipeName) {
        const tView = getTView();
        let pipeDef;
        const adjustedIndex = index + 20;
        tView.firstCreatePass
          ? ((pipeDef = (function(name, registry) {
              if (registry)
                for (let i = registry.length - 1; i >= 0; i--) {
                  const pipeDef = registry[i];
                  if (name === pipeDef.name) return pipeDef;
                }
              throw new Error(`The pipe '${name}' could not be found!`);
            })(pipeName, tView.pipeRegistry)),
            (tView.data[adjustedIndex] = pipeDef),
            pipeDef.onDestroy &&
              (tView.destroyHooks || (tView.destroyHooks = [])).push(
                adjustedIndex,
                pipeDef.onDestroy
              ))
          : (pipeDef = tView.data[adjustedIndex]);
        const pipeFactory =
            pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type)),
          previousInjectImplementation = setInjectImplementation(
            ɵɵdirectiveInject
          ),
          previousIncludeViewProviders = setIncludeViewProviders(!1),
          pipeInstance = pipeFactory();
        return (
          setIncludeViewProviders(previousIncludeViewProviders),
          setInjectImplementation(previousInjectImplementation),
          (function(tView, lView, index, value) {
            const adjustedIndex = index + 20;
            adjustedIndex >= tView.data.length &&
              ((tView.data[adjustedIndex] = null),
              (tView.blueprint[adjustedIndex] = null)),
              (lView[adjustedIndex] = value);
          })(tView, getLView(), index, pipeInstance),
          pipeInstance
        );
      }
      function ɵɵpipeBind1(index, slotOffset, v1) {
        const lView = getLView(),
          pipeInstance = load(lView, index);
        return (function(lView, newValue) {
          return (
            WrappedValue.isWrapped(newValue) &&
              ((newValue = WrappedValue.unwrap(newValue)),
              (lView[getBindingIndex()] = NO_CHANGE)),
            newValue
          );
        })(
          lView,
          (function(lView, index) {
            return lView[1].data[index + 20].pure;
          })(lView, index)
            ? pureFunction1Internal(
                lView,
                getBindingRoot(),
                slotOffset,
                pipeInstance.transform,
                v1,
                pipeInstance
              )
            : pipeInstance.transform(v1)
        );
      }
      const EventEmitter = class extends rxjs__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(isAsync = !1) {
          super(), (this.__isAsync = isAsync);
        }
        emit(value) {
          super.next(value);
        }
        subscribe(generatorOrNext, error, complete) {
          let schedulerFn,
            errorFn = err => null,
            completeFn = () => null;
          generatorOrNext && 'object' == typeof generatorOrNext
            ? ((schedulerFn = this.__isAsync
                ? value => {
                    setTimeout(() => generatorOrNext.next(value));
                  }
                : value => {
                    generatorOrNext.next(value);
                  }),
              generatorOrNext.error &&
                (errorFn = this.__isAsync
                  ? err => {
                      setTimeout(() => generatorOrNext.error(err));
                    }
                  : err => {
                      generatorOrNext.error(err);
                    }),
              generatorOrNext.complete &&
                (completeFn = this.__isAsync
                  ? () => {
                      setTimeout(() => generatorOrNext.complete());
                    }
                  : () => {
                      generatorOrNext.complete();
                    }))
            : ((schedulerFn = this.__isAsync
                ? value => {
                    setTimeout(() => generatorOrNext(value));
                  }
                : value => {
                    generatorOrNext(value);
                  }),
              error &&
                (errorFn = this.__isAsync
                  ? err => {
                      setTimeout(() => error(err));
                    }
                  : err => {
                      error(err);
                    }),
              complete &&
                (completeFn = this.__isAsync
                  ? () => {
                      setTimeout(() => complete());
                    }
                  : () => {
                      complete();
                    }));
          const sink = super.subscribe(schedulerFn, errorFn, completeFn);
          return (
            generatorOrNext instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__.a &&
              generatorOrNext.add(sink),
            sink
          );
        }
      };
      function symbolIterator() {
        return this._results[getSymbolIterator()]();
      }
      class QueryList {
        constructor() {
          (this.dirty = !0),
            (this._results = []),
            (this.changes = new EventEmitter()),
            (this.length = 0);
          const symbol = getSymbolIterator(),
            proto = QueryList.prototype;
          proto[symbol] || (proto[symbol] = symbolIterator);
        }
        map(fn) {
          return this._results.map(fn);
        }
        filter(fn) {
          return this._results.filter(fn);
        }
        find(fn) {
          return this._results.find(fn);
        }
        reduce(fn, init) {
          return this._results.reduce(fn, init);
        }
        forEach(fn) {
          this._results.forEach(fn);
        }
        some(fn) {
          return this._results.some(fn);
        }
        toArray() {
          return this._results.slice();
        }
        toString() {
          return this._results.toString();
        }
        reset(resultsTree) {
          (this._results = (function flatten(list, dst) {
            void 0 === dst && (dst = list);
            for (let i = 0; i < list.length; i++) {
              let item = list[i];
              Array.isArray(item)
                ? (dst === list && (dst = list.slice(0, i)), flatten(item, dst))
                : dst !== list && dst.push(item);
            }
            return dst;
          })(resultsTree)),
            (this.dirty = !1),
            (this.length = this._results.length),
            (this.last = this._results[this.length - 1]),
            (this.first = this._results[0]);
        }
        notifyOnChanges() {
          this.changes.emit(this);
        }
        setDirty() {
          this.dirty = !0;
        }
        destroy() {
          this.changes.complete(), this.changes.unsubscribe();
        }
      }
      class LQuery_ {
        constructor(queryList) {
          (this.queryList = queryList), (this.matches = null);
        }
        clone() {
          return new LQuery_(this.queryList);
        }
        setDirty() {
          this.queryList.setDirty();
        }
      }
      class LQueries_ {
        constructor(queries = []) {
          this.queries = queries;
        }
        createEmbeddedView(tView) {
          const tQueries = tView.queries;
          if (null !== tQueries) {
            const noOfInheritedQueries =
                null !== tView.contentQueries
                  ? tView.contentQueries[0]
                  : tQueries.length,
              viewLQueries = [];
            for (let i = 0; i < noOfInheritedQueries; i++) {
              const tQuery = tQueries.getByIndex(i);
              viewLQueries.push(
                this.queries[tQuery.indexInDeclarationView].clone()
              );
            }
            return new LQueries_(viewLQueries);
          }
          return null;
        }
        insertView(tView) {
          this.dirtyQueriesWithMatches(tView);
        }
        detachView(tView) {
          this.dirtyQueriesWithMatches(tView);
        }
        dirtyQueriesWithMatches(tView) {
          for (let i = 0; i < this.queries.length; i++)
            null !== getTQuery(tView, i).matches && this.queries[i].setDirty();
        }
      }
      class TQueryMetadata_ {
        constructor(predicate, descendants, isStatic, read = null) {
          (this.predicate = predicate),
            (this.descendants = descendants),
            (this.isStatic = isStatic),
            (this.read = read);
        }
      }
      class TQueries_ {
        constructor(queries = []) {
          this.queries = queries;
        }
        elementStart(tView, tNode) {
          for (let i = 0; i < this.queries.length; i++)
            this.queries[i].elementStart(tView, tNode);
        }
        elementEnd(tNode) {
          for (let i = 0; i < this.queries.length; i++)
            this.queries[i].elementEnd(tNode);
        }
        embeddedTView(tNode) {
          let queriesForTemplateRef = null;
          for (let i = 0; i < this.length; i++) {
            const childQueryIndex =
                null !== queriesForTemplateRef
                  ? queriesForTemplateRef.length
                  : 0,
              tqueryClone = this.getByIndex(i).embeddedTView(
                tNode,
                childQueryIndex
              );
            tqueryClone &&
              ((tqueryClone.indexInDeclarationView = i),
              null !== queriesForTemplateRef
                ? queriesForTemplateRef.push(tqueryClone)
                : (queriesForTemplateRef = [tqueryClone]));
          }
          return null !== queriesForTemplateRef
            ? new TQueries_(queriesForTemplateRef)
            : null;
        }
        template(tView, tNode) {
          for (let i = 0; i < this.queries.length; i++)
            this.queries[i].template(tView, tNode);
        }
        getByIndex(index) {
          return this.queries[index];
        }
        get length() {
          return this.queries.length;
        }
        track(tquery) {
          this.queries.push(tquery);
        }
      }
      class TQuery_ {
        constructor(metadata, nodeIndex = -1) {
          (this.metadata = metadata),
            (this.matches = null),
            (this.indexInDeclarationView = -1),
            (this.crossesNgTemplate = !1),
            (this._appliesToNextNode = !0),
            (this._declarationNodeIndex = nodeIndex);
        }
        elementStart(tView, tNode) {
          this.isApplyingToNode(tNode) && this.matchTNode(tView, tNode);
        }
        elementEnd(tNode) {
          this._declarationNodeIndex === tNode.index &&
            (this._appliesToNextNode = !1);
        }
        template(tView, tNode) {
          this.elementStart(tView, tNode);
        }
        embeddedTView(tNode, childQueryIndex) {
          return this.isApplyingToNode(tNode)
            ? ((this.crossesNgTemplate = !0),
              this.addMatch(-tNode.index, childQueryIndex),
              new TQuery_(this.metadata))
            : null;
        }
        isApplyingToNode(tNode) {
          if (this._appliesToNextNode && !1 === this.metadata.descendants) {
            const declarationNodeIdx = this._declarationNodeIndex;
            let parent = tNode.parent;
            for (
              ;
              null !== parent &&
              4 === parent.type &&
              parent.index !== declarationNodeIdx;

            )
              parent = parent.parent;
            return declarationNodeIdx === (null !== parent ? parent.index : -1);
          }
          return this._appliesToNextNode;
        }
        matchTNode(tView, tNode) {
          if (Array.isArray(this.metadata.predicate)) {
            const localNames = this.metadata.predicate;
            for (let i = 0; i < localNames.length; i++)
              this.matchTNodeWithReadOption(
                tView,
                tNode,
                getIdxOfMatchingSelector(tNode, localNames[i])
              );
          } else {
            const typePredicate = this.metadata.predicate;
            typePredicate === TemplateRef
              ? 0 === tNode.type &&
                this.matchTNodeWithReadOption(tView, tNode, -1)
              : this.matchTNodeWithReadOption(
                  tView,
                  tNode,
                  locateDirectiveOrProvider(tNode, tView, typePredicate, !1, !1)
                );
          }
        }
        matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
          if (null !== nodeMatchIdx) {
            const read = this.metadata.read;
            if (null !== read)
              if (
                read === ElementRef ||
                read === ViewContainerRef ||
                (read === TemplateRef && 0 === tNode.type)
              )
                this.addMatch(tNode.index, -2);
              else {
                const directiveOrProviderIdx = locateDirectiveOrProvider(
                  tNode,
                  tView,
                  read,
                  !1,
                  !1
                );
                null !== directiveOrProviderIdx &&
                  this.addMatch(tNode.index, directiveOrProviderIdx);
              }
            else this.addMatch(tNode.index, nodeMatchIdx);
          }
        }
        addMatch(tNodeIdx, matchIdx) {
          null === this.matches
            ? (this.matches = [tNodeIdx, matchIdx])
            : this.matches.push(tNodeIdx, matchIdx);
        }
      }
      function getIdxOfMatchingSelector(tNode, selector) {
        const localNames = tNode.localNames;
        if (null !== localNames)
          for (let i = 0; i < localNames.length; i += 2)
            if (localNames[i] === selector) return localNames[i + 1];
        return null;
      }
      function createResultForNode(lView, tNode, matchingIdx, read) {
        return -1 === matchingIdx
          ? (function(tNode, currentView) {
              return 3 === tNode.type || 4 === tNode.type
                ? createElementRef(ElementRef, tNode, currentView)
                : 0 === tNode.type
                ? createTemplateRef(TemplateRef, ElementRef, tNode, currentView)
                : null;
            })(tNode, lView)
          : -2 === matchingIdx
          ? (function(lView, tNode, read) {
              return read === ElementRef
                ? createElementRef(ElementRef, tNode, lView)
                : read === TemplateRef
                ? createTemplateRef(TemplateRef, ElementRef, tNode, lView)
                : read === ViewContainerRef
                ? createContainerRef(ViewContainerRef, ElementRef, tNode, lView)
                : void 0;
            })(lView, tNode, read)
          : getNodeInjectable(lView, lView[1], matchingIdx, tNode);
      }
      function materializeViewResults(tView, lView, tQuery, queryIndex) {
        const lQuery = lView[19].queries[queryIndex];
        if (null === lQuery.matches) {
          const tViewData = tView.data,
            tQueryMatches = tQuery.matches,
            result = [];
          for (let i = 0; i < tQueryMatches.length; i += 2) {
            const matchedNodeIdx = tQueryMatches[i];
            result.push(
              matchedNodeIdx < 0
                ? null
                : createResultForNode(
                    lView,
                    tViewData[matchedNodeIdx],
                    tQueryMatches[i + 1],
                    tQuery.metadata.read
                  )
            );
          }
          lQuery.matches = result;
        }
        return lQuery.matches;
      }
      function ɵɵqueryRefresh(queryList) {
        const lView = getLView(),
          tView = getTView(),
          queryIndex = getCurrentQueryIndex();
        setCurrentQueryIndex(queryIndex + 1);
        const tQuery = getTQuery(tView, queryIndex);
        if (
          queryList.dirty &&
          isCreationMode(lView) === tQuery.metadata.isStatic
        ) {
          if (null === tQuery.matches) queryList.reset([]);
          else {
            const result = tQuery.crossesNgTemplate
              ? (function collectQueryResults(
                  tView,
                  lView,
                  queryIndex,
                  result
                ) {
                  const tQuery = tView.queries.getByIndex(queryIndex),
                    tQueryMatches = tQuery.matches;
                  if (null !== tQueryMatches) {
                    const lViewResults = materializeViewResults(
                      tView,
                      lView,
                      tQuery,
                      queryIndex
                    );
                    for (let i = 0; i < tQueryMatches.length; i += 2) {
                      const tNodeIdx = tQueryMatches[i];
                      if (tNodeIdx > 0) result.push(lViewResults[i / 2]);
                      else {
                        const childQueryIndex = tQueryMatches[i + 1],
                          declarationLContainer = lView[-tNodeIdx];
                        for (
                          let i = 10;
                          i < declarationLContainer.length;
                          i++
                        ) {
                          const embeddedLView = declarationLContainer[i];
                          embeddedLView[17] === embeddedLView[3] &&
                            collectQueryResults(
                              embeddedLView[1],
                              embeddedLView,
                              childQueryIndex,
                              result
                            );
                        }
                        if (null !== declarationLContainer[9]) {
                          const embeddedLViews = declarationLContainer[9];
                          for (let i = 0; i < embeddedLViews.length; i++) {
                            const embeddedLView = embeddedLViews[i];
                            collectQueryResults(
                              embeddedLView[1],
                              embeddedLView,
                              childQueryIndex,
                              result
                            );
                          }
                        }
                      }
                    }
                  }
                  return result;
                })(tView, lView, queryIndex, [])
              : materializeViewResults(tView, lView, tQuery, queryIndex);
            queryList.reset(result), queryList.notifyOnChanges();
          }
          return !0;
        }
        return !1;
      }
      function ɵɵstaticViewQuery(predicate, descend, read) {
        viewQueryInternal(getTView(), getLView(), predicate, descend, read, !0);
      }
      function ɵɵviewQuery(predicate, descend, read) {
        viewQueryInternal(getTView(), getLView(), predicate, descend, read, !1);
      }
      function viewQueryInternal(
        tView,
        lView,
        predicate,
        descend,
        read,
        isStatic
      ) {
        tView.firstCreatePass &&
          (createTQuery(
            tView,
            new TQueryMetadata_(predicate, descend, isStatic, read),
            -1
          ),
          isStatic && (tView.staticViewQueries = !0)),
          createLQuery(tView, lView);
      }
      function ɵɵcontentQuery(directiveIndex, predicate, descend, read) {
        contentQueryInternal(
          getTView(),
          getLView(),
          predicate,
          descend,
          read,
          !1,
          getPreviousOrParentTNode(),
          directiveIndex
        );
      }
      function ɵɵstaticContentQuery(directiveIndex, predicate, descend, read) {
        contentQueryInternal(
          getTView(),
          getLView(),
          predicate,
          descend,
          read,
          !0,
          getPreviousOrParentTNode(),
          directiveIndex
        );
      }
      function contentQueryInternal(
        tView,
        lView,
        predicate,
        descend,
        read,
        isStatic,
        tNode,
        directiveIndex
      ) {
        tView.firstCreatePass &&
          (createTQuery(
            tView,
            new TQueryMetadata_(predicate, descend, isStatic, read),
            tNode.index
          ),
          (function(tView, directiveIndex) {
            const tViewContentQueries =
              tView.contentQueries || (tView.contentQueries = []);
            directiveIndex !==
              (tView.contentQueries.length
                ? tViewContentQueries[tViewContentQueries.length - 1]
                : -1) &&
              tViewContentQueries.push(
                tView.queries.length - 1,
                directiveIndex
              );
          })(tView, directiveIndex),
          isStatic && (tView.staticContentQueries = !0)),
          createLQuery(tView, lView);
      }
      function ɵɵloadQuery() {
        return (
          (lView = getLView()),
          (queryIndex = getCurrentQueryIndex()),
          lView[19].queries[queryIndex].queryList
        );
        var lView, queryIndex;
      }
      function createLQuery(tView, lView) {
        const queryList = new QueryList();
        storeCleanupWithContext(tView, lView, queryList, queryList.destroy),
          null === lView[19] && (lView[19] = new LQueries_()),
          lView[19].queries.push(new LQuery_(queryList));
      }
      function createTQuery(tView, metadata, nodeIndex) {
        null === tView.queries && (tView.queries = new TQueries_()),
          tView.queries.track(new TQuery_(metadata, nodeIndex));
      }
      function getTQuery(tView, index) {
        return tView.queries.getByIndex(index);
      }
      function ɵɵtemplateRefExtractor(tNode, currentView) {
        return createTemplateRef(TemplateRef, ElementRef, tNode, currentView);
      }
      function ɵɵinjectPipeChangeDetectorRef(flags = InjectFlags.Default) {
        const value = injectChangeDetectorRef(!0);
        if (null != value || flags & InjectFlags.Optional) return value;
        throw new Error('No provider for ChangeDetectorRef!');
      }
      const APP_INITIALIZER = new InjectionToken('Application Initializer');
      let ApplicationInitStatus = (() => {
        class ApplicationInitStatus {
          constructor(appInits) {
            (this.appInits = appInits),
              (this.initialized = !1),
              (this.done = !1),
              (this.donePromise = new Promise((res, rej) => {
                (this.resolve = res), (this.reject = rej);
              }));
          }
          runInitializers() {
            if (this.initialized) return;
            const asyncInitPromises = [],
              complete = () => {
                (this.done = !0), this.resolve();
              };
            if (this.appInits)
              for (let i = 0; i < this.appInits.length; i++) {
                const initResult = this.appInits[i]();
                isPromise(initResult) && asyncInitPromises.push(initResult);
              }
            Promise.all(asyncInitPromises)
              .then(() => {
                complete();
              })
              .catch(e => {
                this.reject(e);
              }),
              0 === asyncInitPromises.length && complete(),
              (this.initialized = !0);
          }
        }
        return (
          (ApplicationInitStatus.ɵfac = function(t) {
            return new (t || ApplicationInitStatus)(
              ɵɵinject(APP_INITIALIZER, 8)
            );
          }),
          (ApplicationInitStatus.ɵprov = ɵɵdefineInjectable({
            token: ApplicationInitStatus,
            factory: ApplicationInitStatus.ɵfac
          })),
          ApplicationInitStatus
        );
      })();
      const APP_ID = new InjectionToken('AppId'),
        APP_ID_RANDOM_PROVIDER = {
          provide: APP_ID,
          useFactory: function() {
            return `${_randomChar()}${_randomChar()}${_randomChar()}`;
          },
          deps: []
        };
      function _randomChar() {
        return String.fromCharCode(97 + Math.floor(25 * Math.random()));
      }
      const PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer'),
        PLATFORM_ID = new InjectionToken('Platform ID'),
        APP_BOOTSTRAP_LISTENER = new InjectionToken('appBootstrapListener');
      let Console = (() => {
        class Console {
          log(message) {
            console.log(message);
          }
          warn(message) {
            console.warn(message);
          }
        }
        return (
          (Console.ɵfac = function(t) {
            return new (t || Console)();
          }),
          (Console.ɵprov = ɵɵdefineInjectable({
            token: Console,
            factory: Console.ɵfac
          })),
          Console
        );
      })();
      const LOCALE_ID$1 = new InjectionToken('LocaleId'),
        DEFAULT_CURRENCY_CODE = new InjectionToken('DefaultCurrencyCode');
      class ModuleWithComponentFactories {
        constructor(ngModuleFactory, componentFactories) {
          (this.ngModuleFactory = ngModuleFactory),
            (this.componentFactories = componentFactories);
        }
      }
      const Compiler_compileModuleSync__POST_R3__ = function(moduleType) {
          return new NgModuleFactory$1(moduleType);
        },
        Compiler_compileModuleSync = Compiler_compileModuleSync__POST_R3__,
        Compiler_compileModuleAsync = function(moduleType) {
          return Promise.resolve(
            Compiler_compileModuleSync__POST_R3__(moduleType)
          );
        },
        Compiler_compileModuleAndAllComponentsSync__POST_R3__ = function(
          moduleType
        ) {
          const ngModuleFactory = Compiler_compileModuleSync__POST_R3__(
              moduleType
            ),
            componentFactories = maybeUnwrapFn(
              getNgModuleDef(moduleType).declarations
            ).reduce((factories, declaration) => {
              const componentDef = getComponentDef(declaration);
              return (
                componentDef &&
                  factories.push(new ComponentFactory$1(componentDef)),
                factories
              );
            }, []);
          return new ModuleWithComponentFactories(
            ngModuleFactory,
            componentFactories
          );
        },
        Compiler_compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync__POST_R3__,
        Compiler_compileModuleAndAllComponentsAsync = function(moduleType) {
          return Promise.resolve(
            Compiler_compileModuleAndAllComponentsSync__POST_R3__(moduleType)
          );
        };
      let Compiler = (() => {
        class Compiler {
          constructor() {
            (this.compileModuleSync = Compiler_compileModuleSync),
              (this.compileModuleAsync = Compiler_compileModuleAsync),
              (this.compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync),
              (this.compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync);
          }
          clearCache() {}
          clearCacheFor(type) {}
          getModuleId(moduleType) {}
        }
        return (
          (Compiler.ɵfac = function(t) {
            return new (t || Compiler)();
          }),
          (Compiler.ɵprov = ɵɵdefineInjectable({
            token: Compiler,
            factory: Compiler.ɵfac
          })),
          Compiler
        );
      })();
      const promise = (() => Promise.resolve(0))();
      function scheduleMicroTask(fn) {
        'undefined' == typeof Zone
          ? promise.then(() => {
              fn && fn.apply(null, null);
            })
          : Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
      }
      class NgZone {
        constructor({
          enableLongStackTrace: enableLongStackTrace = !1,
          shouldCoalesceEventChangeDetection: shouldCoalesceEventChangeDetection = !1
        }) {
          if (
            ((this.hasPendingMacrotasks = !1),
            (this.hasPendingMicrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new EventEmitter(!1)),
            (this.onMicrotaskEmpty = new EventEmitter(!1)),
            (this.onStable = new EventEmitter(!1)),
            (this.onError = new EventEmitter(!1)),
            'undefined' == typeof Zone)
          )
            throw new Error('In this configuration Angular requires Zone.js');
          Zone.assertZonePatched(),
            (this._nesting = 0),
            (this._outer = this._inner = Zone.current),
            Zone.wtfZoneSpec &&
              (this._inner = this._inner.fork(Zone.wtfZoneSpec)),
            Zone.TaskTrackingZoneSpec &&
              (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec())),
            enableLongStackTrace &&
              Zone.longStackTraceZoneSpec &&
              (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)),
            (this.shouldCoalesceEventChangeDetection = shouldCoalesceEventChangeDetection),
            (this.lastRequestAnimationFrameId = -1),
            (this.nativeRequestAnimationFrame = (function() {
              let nativeRequestAnimationFrame = _global.requestAnimationFrame,
                nativeCancelAnimationFrame = _global.cancelAnimationFrame;
              if (
                'undefined' != typeof Zone &&
                nativeRequestAnimationFrame &&
                nativeCancelAnimationFrame
              ) {
                const unpatchedRequestAnimationFrame =
                  nativeRequestAnimationFrame[
                    Zone.__symbol__('OriginalDelegate')
                  ];
                unpatchedRequestAnimationFrame &&
                  (nativeRequestAnimationFrame = unpatchedRequestAnimationFrame);
                const unpatchedCancelAnimationFrame =
                  nativeCancelAnimationFrame[
                    Zone.__symbol__('OriginalDelegate')
                  ];
                unpatchedCancelAnimationFrame &&
                  (nativeCancelAnimationFrame = unpatchedCancelAnimationFrame);
              }
              return {
                nativeRequestAnimationFrame: nativeRequestAnimationFrame,
                nativeCancelAnimationFrame: nativeCancelAnimationFrame
              };
            })().nativeRequestAnimationFrame),
            (function(zone) {
              const maybeDelayChangeDetection =
                !!zone.shouldCoalesceEventChangeDetection &&
                zone.nativeRequestAnimationFrame &&
                (() => {
                  !(function(zone) {
                    -1 === zone.lastRequestAnimationFrameId &&
                      ((zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(
                        _global,
                        () => {
                          zone.fakeTopEventTask ||
                            (zone.fakeTopEventTask = Zone.root.scheduleEventTask(
                              'fakeTopEventTask',
                              () => {
                                (zone.lastRequestAnimationFrameId = -1),
                                  updateMicroTaskStatus(zone),
                                  checkStable(zone);
                              },
                              void 0,
                              () => {},
                              () => {}
                            )),
                            zone.fakeTopEventTask.invoke();
                        }
                      )),
                      updateMicroTaskStatus(zone));
                  })(zone);
                });
              zone._inner = zone._inner.fork({
                name: 'angular',
                properties: {
                  isAngularZone: !0,
                  maybeDelayChangeDetection: maybeDelayChangeDetection
                },
                onInvokeTask: (
                  delegate,
                  current,
                  target,
                  task,
                  applyThis,
                  applyArgs
                ) => {
                  try {
                    return (
                      onEnter(zone),
                      delegate.invokeTask(target, task, applyThis, applyArgs)
                    );
                  } finally {
                    maybeDelayChangeDetection &&
                      'eventTask' === task.type &&
                      maybeDelayChangeDetection(),
                      onLeave(zone);
                  }
                },
                onInvoke: (
                  delegate,
                  current,
                  target,
                  callback,
                  applyThis,
                  applyArgs,
                  source
                ) => {
                  try {
                    return (
                      onEnter(zone),
                      delegate.invoke(
                        target,
                        callback,
                        applyThis,
                        applyArgs,
                        source
                      )
                    );
                  } finally {
                    onLeave(zone);
                  }
                },
                onHasTask: (delegate, current, target, hasTaskState) => {
                  delegate.hasTask(target, hasTaskState),
                    current === target &&
                      ('microTask' == hasTaskState.change
                        ? ((zone._hasPendingMicrotasks =
                            hasTaskState.microTask),
                          updateMicroTaskStatus(zone),
                          checkStable(zone))
                        : 'macroTask' == hasTaskState.change &&
                          (zone.hasPendingMacrotasks = hasTaskState.macroTask));
                },
                onHandleError: (delegate, current, target, error) => (
                  delegate.handleError(target, error),
                  zone.runOutsideAngular(() => zone.onError.emit(error)),
                  !1
                )
              });
            })(this);
        }
        static isInAngularZone() {
          return !0 === Zone.current.get('isAngularZone');
        }
        static assertInAngularZone() {
          if (!NgZone.isInAngularZone())
            throw new Error('Expected to be in Angular Zone, but it is not!');
        }
        static assertNotInAngularZone() {
          if (NgZone.isInAngularZone())
            throw new Error('Expected to not be in Angular Zone, but it is!');
        }
        run(fn, applyThis, applyArgs) {
          return this._inner.run(fn, applyThis, applyArgs);
        }
        runTask(fn, applyThis, applyArgs, name) {
          const zone = this._inner,
            task = zone.scheduleEventTask(
              'NgZoneEvent: ' + name,
              fn,
              EMPTY_PAYLOAD,
              noop$1,
              noop$1
            );
          try {
            return zone.runTask(task, applyThis, applyArgs);
          } finally {
            zone.cancelTask(task);
          }
        }
        runGuarded(fn, applyThis, applyArgs) {
          return this._inner.runGuarded(fn, applyThis, applyArgs);
        }
        runOutsideAngular(fn) {
          return this._outer.run(fn);
        }
      }
      function noop$1() {}
      const EMPTY_PAYLOAD = {};
      function checkStable(zone) {
        if (0 == zone._nesting && !zone.hasPendingMicrotasks && !zone.isStable)
          try {
            zone._nesting++, zone.onMicrotaskEmpty.emit(null);
          } finally {
            if ((zone._nesting--, !zone.hasPendingMicrotasks))
              try {
                zone.runOutsideAngular(() => zone.onStable.emit(null));
              } finally {
                zone.isStable = !0;
              }
          }
      }
      function updateMicroTaskStatus(zone) {
        zone.hasPendingMicrotasks = !!(
          zone._hasPendingMicrotasks ||
          (zone.shouldCoalesceEventChangeDetection &&
            -1 !== zone.lastRequestAnimationFrameId)
        );
      }
      function onEnter(zone) {
        zone._nesting++,
          zone.isStable && ((zone.isStable = !1), zone.onUnstable.emit(null));
      }
      function onLeave(zone) {
        zone._nesting--, checkStable(zone);
      }
      class NoopNgZone {
        constructor() {
          (this.hasPendingMicrotasks = !1),
            (this.hasPendingMacrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new EventEmitter()),
            (this.onMicrotaskEmpty = new EventEmitter()),
            (this.onStable = new EventEmitter()),
            (this.onError = new EventEmitter());
        }
        run(fn, applyThis, applyArgs) {
          return fn.apply(applyThis, applyArgs);
        }
        runGuarded(fn, applyThis, applyArgs) {
          return fn.apply(applyThis, applyArgs);
        }
        runOutsideAngular(fn) {
          return fn();
        }
        runTask(fn, applyThis, applyArgs, name) {
          return fn.apply(applyThis, applyArgs);
        }
      }
      let Testability = (() => {
          class Testability {
            constructor(_ngZone) {
              (this._ngZone = _ngZone),
                (this._pendingCount = 0),
                (this._isZoneStable = !0),
                (this._didWork = !1),
                (this._callbacks = []),
                (this.taskTrackingZone = null),
                this._watchAngularEvents(),
                _ngZone.run(() => {
                  this.taskTrackingZone =
                    'undefined' == typeof Zone
                      ? null
                      : Zone.current.get('TaskTrackingZone');
                });
            }
            _watchAngularEvents() {
              this._ngZone.onUnstable.subscribe({
                next: () => {
                  (this._didWork = !0), (this._isZoneStable = !1);
                }
              }),
                this._ngZone.runOutsideAngular(() => {
                  this._ngZone.onStable.subscribe({
                    next: () => {
                      NgZone.assertNotInAngularZone(),
                        scheduleMicroTask(() => {
                          (this._isZoneStable = !0),
                            this._runCallbacksIfReady();
                        });
                    }
                  });
                });
            }
            increasePendingRequestCount() {
              return (
                (this._pendingCount += 1),
                (this._didWork = !0),
                this._pendingCount
              );
            }
            decreasePendingRequestCount() {
              if (((this._pendingCount -= 1), this._pendingCount < 0))
                throw new Error('pending async requests below zero');
              return this._runCallbacksIfReady(), this._pendingCount;
            }
            isStable() {
              return (
                this._isZoneStable &&
                0 === this._pendingCount &&
                !this._ngZone.hasPendingMacrotasks
              );
            }
            _runCallbacksIfReady() {
              if (this.isStable())
                scheduleMicroTask(() => {
                  for (; 0 !== this._callbacks.length; ) {
                    let cb = this._callbacks.pop();
                    clearTimeout(cb.timeoutId), cb.doneCb(this._didWork);
                  }
                  this._didWork = !1;
                });
              else {
                let pending = this.getPendingTasks();
                (this._callbacks = this._callbacks.filter(
                  cb =>
                    !cb.updateCb ||
                    !cb.updateCb(pending) ||
                    (clearTimeout(cb.timeoutId), !1)
                )),
                  (this._didWork = !0);
              }
            }
            getPendingTasks() {
              return this.taskTrackingZone
                ? this.taskTrackingZone.macroTasks.map(t => ({
                    source: t.source,
                    creationLocation: t.creationLocation,
                    data: t.data
                  }))
                : [];
            }
            addCallback(cb, timeout, updateCb) {
              let timeoutId = -1;
              timeout &&
                timeout > 0 &&
                (timeoutId = setTimeout(() => {
                  (this._callbacks = this._callbacks.filter(
                    cb => cb.timeoutId !== timeoutId
                  )),
                    cb(this._didWork, this.getPendingTasks());
                }, timeout)),
                this._callbacks.push({
                  doneCb: cb,
                  timeoutId: timeoutId,
                  updateCb: updateCb
                });
            }
            whenStable(doneCb, timeout, updateCb) {
              if (updateCb && !this.taskTrackingZone)
                throw new Error(
                  'Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?'
                );
              this.addCallback(doneCb, timeout, updateCb),
                this._runCallbacksIfReady();
            }
            getPendingRequestCount() {
              return this._pendingCount;
            }
            findProviders(using, provider, exactMatch) {
              return [];
            }
          }
          return (
            (Testability.ɵfac = function(t) {
              return new (t || Testability)(ɵɵinject(NgZone));
            }),
            (Testability.ɵprov = ɵɵdefineInjectable({
              token: Testability,
              factory: Testability.ɵfac
            })),
            Testability
          );
        })(),
        TestabilityRegistry = (() => {
          class TestabilityRegistry {
            constructor() {
              (this._applications = new Map()),
                _testabilityGetter.addToWindow(this);
            }
            registerApplication(token, testability) {
              this._applications.set(token, testability);
            }
            unregisterApplication(token) {
              this._applications.delete(token);
            }
            unregisterAllApplications() {
              this._applications.clear();
            }
            getTestability(elem) {
              return this._applications.get(elem) || null;
            }
            getAllTestabilities() {
              return Array.from(this._applications.values());
            }
            getAllRootElements() {
              return Array.from(this._applications.keys());
            }
            findTestabilityInTree(elem, findInAncestors = !0) {
              return _testabilityGetter.findTestabilityInTree(
                this,
                elem,
                findInAncestors
              );
            }
          }
          return (
            (TestabilityRegistry.ɵfac = function(t) {
              return new (t || TestabilityRegistry)();
            }),
            (TestabilityRegistry.ɵprov = ɵɵdefineInjectable({
              token: TestabilityRegistry,
              factory: TestabilityRegistry.ɵfac
            })),
            TestabilityRegistry
          );
        })();
      class _NoopGetTestability {
        addToWindow(registry) {}
        findTestabilityInTree(registry, elem, findInAncestors) {
          return null;
        }
      }
      function setTestabilityGetter(getter) {
        _testabilityGetter = getter;
      }
      let _platform,
        _testabilityGetter = new _NoopGetTestability();
      const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken('AllowMultipleToken');
      class NgProbeToken {
        constructor(name, token) {
          (this.name = name), (this.token = token);
        }
      }
      function createPlatformFactory(
        parentPlatformFactory,
        name,
        providers = []
      ) {
        const desc = 'Platform: ' + name,
          marker = new InjectionToken(desc);
        return (extraProviders = []) => {
          let platform = getPlatform();
          if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, !1))
            if (parentPlatformFactory)
              parentPlatformFactory(
                providers
                  .concat(extraProviders)
                  .concat({ provide: marker, useValue: !0 })
              );
            else {
              const injectedProviders = providers
                .concat(extraProviders)
                .concat(
                  { provide: marker, useValue: !0 },
                  { provide: INJECTOR_SCOPE, useValue: 'platform' }
                );
              !(function(injector) {
                if (
                  _platform &&
                  !_platform.destroyed &&
                  !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, !1)
                )
                  throw new Error(
                    'There can be only one platform. Destroy the previous one to create a new one.'
                  );
                _platform = injector.get(PlatformRef);
                const inits = injector.get(PLATFORM_INITIALIZER, null);
                inits && inits.forEach(init => init());
              })(Injector.create({ providers: injectedProviders, name: desc }));
            }
          return (function(requiredToken) {
            const platform = getPlatform();
            if (!platform) throw new Error('No platform exists!');
            if (!platform.injector.get(requiredToken, null))
              throw new Error(
                'A platform with a different configuration has been created. Please destroy it first.'
              );
            return platform;
          })(marker);
        };
      }
      function getPlatform() {
        return _platform && !_platform.destroyed ? _platform : null;
      }
      let PlatformRef = (() => {
        class PlatformRef {
          constructor(_injector) {
            (this._injector = _injector),
              (this._modules = []),
              (this._destroyListeners = []),
              (this._destroyed = !1);
          }
          bootstrapModuleFactory(moduleFactory, options) {
            const ngZone = (function(ngZoneOption, ngZoneEventCoalescing) {
                let ngZone;
                return (
                  (ngZone =
                    'noop' === ngZoneOption
                      ? new NoopNgZone()
                      : ('zone.js' === ngZoneOption ? void 0 : ngZoneOption) ||
                        new NgZone({
                          enableLongStackTrace: isDevMode(),
                          shouldCoalesceEventChangeDetection: ngZoneEventCoalescing
                        })),
                  ngZone
                );
              })(
                options ? options.ngZone : void 0,
                (options && options.ngZoneEventCoalescing) || !1
              ),
              providers = [{ provide: NgZone, useValue: ngZone }];
            return ngZone.run(() => {
              const ngZoneInjector = Injector.create({
                  providers: providers,
                  parent: this.injector,
                  name: moduleFactory.moduleType.name
                }),
                moduleRef = moduleFactory.create(ngZoneInjector),
                exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
              if (!exceptionHandler)
                throw new Error(
                  'No ErrorHandler. Is platform module (BrowserModule) included?'
                );
              return (
                moduleRef.onDestroy(() => remove(this._modules, moduleRef)),
                ngZone.runOutsideAngular(() =>
                  ngZone.onError.subscribe({
                    next: error => {
                      exceptionHandler.handleError(error);
                    }
                  })
                ),
                (function(errorHandler, ngZone, callback) {
                  try {
                    const result = callback();
                    return isPromise(result)
                      ? result.catch(e => {
                          throw (ngZone.runOutsideAngular(() =>
                            errorHandler.handleError(e)
                          ),
                          e);
                        })
                      : result;
                  } catch (e) {
                    throw (ngZone.runOutsideAngular(() =>
                      errorHandler.handleError(e)
                    ),
                    e);
                  }
                })(exceptionHandler, ngZone, () => {
                  const initStatus = moduleRef.injector.get(
                    ApplicationInitStatus
                  );
                  return (
                    initStatus.runInitializers(),
                    initStatus.donePromise.then(
                      () => (
                        setLocaleId(
                          moduleRef.injector.get(LOCALE_ID$1, 'en-US') ||
                            'en-US'
                        ),
                        this._moduleDoBootstrap(moduleRef),
                        moduleRef
                      )
                    )
                  );
                })
              );
            });
          }
          bootstrapModule(moduleType, compilerOptions = []) {
            const options = optionsReducer({}, compilerOptions);
            return (function(injector, options, moduleType) {
              const moduleFactory = new NgModuleFactory$1(moduleType);
              return Promise.resolve(moduleFactory);
            })(0, 0, moduleType).then(moduleFactory =>
              this.bootstrapModuleFactory(moduleFactory, options)
            );
          }
          _moduleDoBootstrap(moduleRef) {
            const appRef = moduleRef.injector.get(ApplicationRef);
            if (moduleRef._bootstrapComponents.length > 0)
              moduleRef._bootstrapComponents.forEach(f => appRef.bootstrap(f));
            else {
              if (!moduleRef.instance.ngDoBootstrap)
                throw new Error(
                  `The module ${stringify(
                    moduleRef.instance.constructor
                  )} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`
                );
              moduleRef.instance.ngDoBootstrap(appRef);
            }
            this._modules.push(moduleRef);
          }
          onDestroy(callback) {
            this._destroyListeners.push(callback);
          }
          get injector() {
            return this._injector;
          }
          destroy() {
            if (this._destroyed)
              throw new Error('The platform has already been destroyed!');
            this._modules.slice().forEach(module => module.destroy()),
              this._destroyListeners.forEach(listener => listener()),
              (this._destroyed = !0);
          }
          get destroyed() {
            return this._destroyed;
          }
        }
        return (
          (PlatformRef.ɵfac = function(t) {
            return new (t || PlatformRef)(ɵɵinject(Injector));
          }),
          (PlatformRef.ɵprov = ɵɵdefineInjectable({
            token: PlatformRef,
            factory: PlatformRef.ɵfac
          })),
          PlatformRef
        );
      })();
      function optionsReducer(dst, objs) {
        return Array.isArray(objs)
          ? objs.reduce(optionsReducer, dst)
          : Object.assign(Object.assign({}, dst), objs);
      }
      let ApplicationRef = (() => {
        class ApplicationRef {
          constructor(
            _zone,
            _console,
            _injector,
            _exceptionHandler,
            _componentFactoryResolver,
            _initStatus
          ) {
            (this._zone = _zone),
              (this._console = _console),
              (this._injector = _injector),
              (this._exceptionHandler = _exceptionHandler),
              (this._componentFactoryResolver = _componentFactoryResolver),
              (this._initStatus = _initStatus),
              (this._bootstrapListeners = []),
              (this._views = []),
              (this._runningTick = !1),
              (this._enforceNoNewChanges = !1),
              (this._stable = !0),
              (this.componentTypes = []),
              (this.components = []),
              (this._enforceNoNewChanges = isDevMode()),
              this._zone.onMicrotaskEmpty.subscribe({
                next: () => {
                  this._zone.run(() => {
                    this.tick();
                  });
                }
              });
            const isCurrentlyStable = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a(
                observer => {
                  (this._stable =
                    this._zone.isStable &&
                    !this._zone.hasPendingMacrotasks &&
                    !this._zone.hasPendingMicrotasks),
                    this._zone.runOutsideAngular(() => {
                      observer.next(this._stable), observer.complete();
                    });
                }
              ),
              isStable = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a(observer => {
                let stableSub;
                this._zone.runOutsideAngular(() => {
                  stableSub = this._zone.onStable.subscribe(() => {
                    NgZone.assertNotInAngularZone(),
                      scheduleMicroTask(() => {
                        this._stable ||
                          this._zone.hasPendingMacrotasks ||
                          this._zone.hasPendingMicrotasks ||
                          ((this._stable = !0), observer.next(!0));
                      });
                  });
                });
                const unstableSub = this._zone.onUnstable.subscribe(() => {
                  NgZone.assertInAngularZone(),
                    this._stable &&
                      ((this._stable = !1),
                      this._zone.runOutsideAngular(() => {
                        observer.next(!1);
                      }));
                });
                return () => {
                  stableSub.unsubscribe(), unstableSub.unsubscribe();
                };
              });
            this.isStable = Object(rxjs__WEBPACK_IMPORTED_MODULE_3__.a)(
              isCurrentlyStable,
              isStable.pipe(
                Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)()
              )
            );
          }
          bootstrap(componentOrFactory, rootSelectorOrNode) {
            if (!this._initStatus.done)
              throw new Error(
                'Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.'
              );
            let componentFactory;
            (componentFactory =
              componentOrFactory instanceof ComponentFactory
                ? componentOrFactory
                : this._componentFactoryResolver.resolveComponentFactory(
                    componentOrFactory
                  )),
              this.componentTypes.push(componentFactory.componentType);
            const ngModule = componentFactory.isBoundToModule
                ? void 0
                : this._injector.get(NgModuleRef),
              compRef = componentFactory.create(
                Injector.NULL,
                [],
                rootSelectorOrNode || componentFactory.selector,
                ngModule
              );
            compRef.onDestroy(() => {
              this._unloadComponent(compRef);
            });
            const testability = compRef.injector.get(Testability, null);
            return (
              testability &&
                compRef.injector
                  .get(TestabilityRegistry)
                  .registerApplication(
                    compRef.location.nativeElement,
                    testability
                  ),
              this._loadComponent(compRef),
              isDevMode() &&
                this._console.log(
                  'Angular is running in development mode. Call enableProdMode() to enable production mode.'
                ),
              compRef
            );
          }
          tick() {
            if (this._runningTick)
              throw new Error('ApplicationRef.tick is called recursively');
            try {
              this._runningTick = !0;
              for (let view of this._views) view.detectChanges();
              if (this._enforceNoNewChanges)
                for (let view of this._views) view.checkNoChanges();
            } catch (e) {
              this._zone.runOutsideAngular(() =>
                this._exceptionHandler.handleError(e)
              );
            } finally {
              this._runningTick = !1;
            }
          }
          attachView(viewRef) {
            const view = viewRef;
            this._views.push(view), view.attachToAppRef(this);
          }
          detachView(viewRef) {
            const view = viewRef;
            remove(this._views, view), view.detachFromAppRef();
          }
          _loadComponent(componentRef) {
            this.attachView(componentRef.hostView),
              this.tick(),
              this.components.push(componentRef),
              this._injector
                .get(APP_BOOTSTRAP_LISTENER, [])
                .concat(this._bootstrapListeners)
                .forEach(listener => listener(componentRef));
          }
          _unloadComponent(componentRef) {
            this.detachView(componentRef.hostView),
              remove(this.components, componentRef);
          }
          ngOnDestroy() {
            this._views.slice().forEach(view => view.destroy());
          }
          get viewCount() {
            return this._views.length;
          }
        }
        return (
          (ApplicationRef.ɵfac = function(t) {
            return new (t || ApplicationRef)(
              ɵɵinject(NgZone),
              ɵɵinject(Console),
              ɵɵinject(Injector),
              ɵɵinject(ErrorHandler),
              ɵɵinject(ComponentFactoryResolver),
              ɵɵinject(ApplicationInitStatus)
            );
          }),
          (ApplicationRef.ɵprov = ɵɵdefineInjectable({
            token: ApplicationRef,
            factory: ApplicationRef.ɵfac
          })),
          ApplicationRef
        );
      })();
      function remove(list, el) {
        const index = list.indexOf(el);
        index > -1 && list.splice(index, 1);
      }
      class NgModuleFactoryLoader {}
      class SystemJsNgModuleLoaderConfig {}
      const DEFAULT_CONFIG = {
        factoryPathPrefix: '',
        factoryPathSuffix: '.ngfactory'
      };
      let SystemJsNgModuleLoader = (() => {
        class SystemJsNgModuleLoader {
          constructor(_compiler, config) {
            (this._compiler = _compiler),
              (this._config = config || DEFAULT_CONFIG);
          }
          load(path) {
            return this.loadAndCompile(path);
          }
          loadAndCompile(path) {
            let [module, exportName] = path.split('#');
            return (
              void 0 === exportName && (exportName = 'default'),
              __webpack_require__('zn8P')(module)
                .then(module => module[exportName])
                .then(type => checkNotEmpty(type, module, exportName))
                .then(type => this._compiler.compileModuleAsync(type))
            );
          }
          loadFactory(path) {
            let [module, exportName] = path.split('#'),
              factoryClassSuffix = 'NgFactory';
            return (
              void 0 === exportName &&
                ((exportName = 'default'), (factoryClassSuffix = '')),
              __webpack_require__('zn8P')(
                this._config.factoryPathPrefix +
                  module +
                  this._config.factoryPathSuffix
              )
                .then(module => module[exportName + factoryClassSuffix])
                .then(factory => checkNotEmpty(factory, module, exportName))
            );
          }
        }
        return (
          (SystemJsNgModuleLoader.ɵfac = function(t) {
            return new (t || SystemJsNgModuleLoader)(
              ɵɵinject(Compiler),
              ɵɵinject(SystemJsNgModuleLoaderConfig, 8)
            );
          }),
          (SystemJsNgModuleLoader.ɵprov = ɵɵdefineInjectable({
            token: SystemJsNgModuleLoader,
            factory: SystemJsNgModuleLoader.ɵfac
          })),
          SystemJsNgModuleLoader
        );
      })();
      function checkNotEmpty(value, modulePath, exportName) {
        if (!value)
          throw new Error(`Cannot find '${exportName}' in '${modulePath}'`);
        return value;
      }
      const getDebugNodeR2 = function(_nativeNode) {
          return null;
        },
        platformCore = createPlatformFactory(null, 'core', [
          { provide: PLATFORM_ID, useValue: 'unknown' },
          { provide: PlatformRef, deps: [Injector] },
          { provide: TestabilityRegistry, deps: [] },
          { provide: Console, deps: [] }
        ]),
        APPLICATION_MODULE_PROVIDERS = [
          {
            provide: ApplicationRef,
            useClass: ApplicationRef,
            deps: [
              NgZone,
              Console,
              Injector,
              ErrorHandler,
              ComponentFactoryResolver,
              ApplicationInitStatus
            ]
          },
          {
            provide: SCHEDULER,
            deps: [NgZone],
            useFactory: function(ngZone) {
              let queue = [];
              return (
                ngZone.onStable.subscribe(() => {
                  for (; queue.length; ) queue.pop()();
                }),
                function(fn) {
                  queue.push(fn);
                }
              );
            }
          },
          {
            provide: ApplicationInitStatus,
            useClass: ApplicationInitStatus,
            deps: [[new Optional(), APP_INITIALIZER]]
          },
          { provide: Compiler, useClass: Compiler, deps: [] },
          APP_ID_RANDOM_PROVIDER,
          {
            provide: IterableDiffers,
            useFactory: function() {
              return defaultIterableDiffers;
            },
            deps: []
          },
          {
            provide: KeyValueDiffers,
            useFactory: function() {
              return defaultKeyValueDiffers;
            },
            deps: []
          },
          {
            provide: LOCALE_ID$1,
            useFactory: function(locale) {
              return (
                setLocaleId(
                  (locale =
                    locale ||
                    ('undefined' != typeof $localize && $localize.locale) ||
                    'en-US')
                ),
                locale
              );
            },
            deps: [[new Inject(LOCALE_ID$1), new Optional(), new SkipSelf()]]
          },
          { provide: DEFAULT_CURRENCY_CODE, useValue: 'USD' }
        ];
      let ApplicationModule = (() => {
        class ApplicationModule {
          constructor(appRef) {}
        }
        return (
          (ApplicationModule.ɵmod = ɵɵdefineNgModule({
            type: ApplicationModule
          })),
          (ApplicationModule.ɵinj = ɵɵdefineInjector({
            factory: function(t) {
              return new (t || ApplicationModule)(ɵɵinject(ApplicationRef));
            },
            providers: APPLICATION_MODULE_PROVIDERS
          })),
          ApplicationModule
        );
      })();
    },
    fdAy: function(module, exports, __webpack_require__) {
      'use strict';
      var $ = __webpack_require__('I+eb'),
        createIteratorConstructor = __webpack_require__('ntOU'),
        getPrototypeOf = __webpack_require__('4WOD'),
        setPrototypeOf = __webpack_require__('0rvr'),
        setToStringTag = __webpack_require__('1E5z'),
        hide = __webpack_require__('X2U+'),
        redefine = __webpack_require__('busE'),
        wellKnownSymbol = __webpack_require__('tiKp'),
        IS_PURE = __webpack_require__('xDBR'),
        Iterators = __webpack_require__('P4y1'),
        IteratorsCore = __webpack_require__('rpNk'),
        IteratorPrototype = IteratorsCore.IteratorPrototype,
        BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS,
        ITERATOR = wellKnownSymbol('iterator'),
        returnThis = function() {
          return this;
        };
      module.exports = function(
        Iterable,
        NAME,
        IteratorConstructor,
        next,
        DEFAULT,
        IS_SET,
        FORCED
      ) {
        createIteratorConstructor(IteratorConstructor, NAME, next);
        var CurrentIteratorPrototype,
          methods,
          KEY,
          getIterationMethod = function(KIND) {
            if (KIND === DEFAULT && defaultIterator) return defaultIterator;
            if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
              return IterablePrototype[KIND];
            switch (KIND) {
              case 'keys':
              case 'values':
              case 'entries':
                return function() {
                  return new IteratorConstructor(this, KIND);
                };
            }
            return function() {
              return new IteratorConstructor(this);
            };
          },
          TO_STRING_TAG = NAME + ' Iterator',
          INCORRECT_VALUES_NAME = !1,
          IterablePrototype = Iterable.prototype,
          nativeIterator =
            IterablePrototype[ITERATOR] ||
            IterablePrototype['@@iterator'] ||
            (DEFAULT && IterablePrototype[DEFAULT]),
          defaultIterator =
            (!BUGGY_SAFARI_ITERATORS && nativeIterator) ||
            getIterationMethod(DEFAULT),
          anyNativeIterator =
            ('Array' == NAME && IterablePrototype.entries) || nativeIterator;
        if (
          (anyNativeIterator &&
            ((CurrentIteratorPrototype = getPrototypeOf(
              anyNativeIterator.call(new Iterable())
            )),
            IteratorPrototype !== Object.prototype &&
              CurrentIteratorPrototype.next &&
              (IS_PURE ||
                getPrototypeOf(CurrentIteratorPrototype) ===
                  IteratorPrototype ||
                (setPrototypeOf
                  ? setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype)
                  : 'function' != typeof CurrentIteratorPrototype[ITERATOR] &&
                    hide(CurrentIteratorPrototype, ITERATOR, returnThis)),
              setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, !0, !0),
              IS_PURE && (Iterators[TO_STRING_TAG] = returnThis))),
          'values' == DEFAULT &&
            nativeIterator &&
            'values' !== nativeIterator.name &&
            ((INCORRECT_VALUES_NAME = !0),
            (defaultIterator = function() {
              return nativeIterator.call(this);
            })),
          (IS_PURE && !FORCED) ||
            IterablePrototype[ITERATOR] === defaultIterator ||
            hide(IterablePrototype, ITERATOR, defaultIterator),
          (Iterators[NAME] = defaultIterator),
          DEFAULT)
        )
          if (
            ((methods = {
              values: getIterationMethod('values'),
              keys: IS_SET ? defaultIterator : getIterationMethod('keys'),
              entries: getIterationMethod('entries')
            }),
            FORCED)
          )
            for (KEY in methods)
              (BUGGY_SAFARI_ITERATORS ||
                INCORRECT_VALUES_NAME ||
                !(KEY in IterablePrototype)) &&
                redefine(IterablePrototype, KEY, methods[KEY]);
          else
            $(
              {
                target: NAME,
                proto: !0,
                forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
              },
              methods
            );
        return methods;
      };
    },
    'g6v/': function(module, exports, __webpack_require__) {
      var fails = __webpack_require__('0Dky');
      module.exports = !fails(function() {
        return (
          7 !=
          Object.defineProperty({}, 'a', {
            get: function() {
              return 7;
            }
          }).a
        );
      });
    },
    gRHU: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return empty;
      });
      var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__('2fFW'),
        _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'NJ4a'
        );
      const empty = {
        closed: !0,
        next(value) {},
        error(err) {
          if (
            _config__WEBPACK_IMPORTED_MODULE_0__.a
              .useDeprecatedSynchronousErrorHandling
          )
            throw err;
          Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__.a)(err);
        },
        complete() {}
      };
    },
    glrk: function(module, exports, __webpack_require__) {
      var isObject = __webpack_require__('hh1v');
      module.exports = function(it) {
        if (!isObject(it)) throw TypeError(String(it) + ' is not an object');
        return it;
      };
    },
    'hKI/': function(module, exports) {
      var reTrim = /^\s+|\s+$/g,
        reIsBadHex = /^[-+]0x[0-9a-f]+$/i,
        reIsBinary = /^0b[01]+$/i,
        reIsOctal = /^0o[0-7]+$/i,
        freeParseInt = parseInt,
        freeGlobal =
          'object' == typeof global &&
          global &&
          global.Object === Object &&
          global,
        freeSelf =
          'object' == typeof self && self && self.Object === Object && self,
        root = freeGlobal || freeSelf || Function('return this')(),
        objectToString = Object.prototype.toString,
        nativeMax = Math.max,
        nativeMin = Math.min,
        now = function() {
          return root.Date.now();
        };
      function isObject(value) {
        var type = typeof value;
        return !!value && ('object' == type || 'function' == type);
      }
      function toNumber(value) {
        if ('number' == typeof value) return value;
        if (
          (function(value) {
            return (
              'symbol' == typeof value ||
              ((function(value) {
                return !!value && 'object' == typeof value;
              })(value) &&
                '[object Symbol]' == objectToString.call(value))
            );
          })(value)
        )
          return NaN;
        if (isObject(value)) {
          var other =
            'function' == typeof value.valueOf ? value.valueOf() : value;
          value = isObject(other) ? other + '' : other;
        }
        if ('string' != typeof value) return 0 === value ? value : +value;
        value = value.replace(reTrim, '');
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value)
          ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
          : reIsBadHex.test(value)
          ? NaN
          : +value;
      }
      module.exports = function(func, wait, options) {
        var leading = !0,
          trailing = !0;
        if ('function' != typeof func)
          throw new TypeError('Expected a function');
        return (
          isObject(options) &&
            ((leading = 'leading' in options ? !!options.leading : leading),
            (trailing = 'trailing' in options ? !!options.trailing : trailing)),
          (function(func, wait, options) {
            var lastArgs,
              lastThis,
              maxWait,
              result,
              timerId,
              lastCallTime,
              lastInvokeTime = 0,
              leading = !1,
              maxing = !1,
              trailing = !0;
            if ('function' != typeof func)
              throw new TypeError('Expected a function');
            function invokeFunc(time) {
              var args = lastArgs,
                thisArg = lastThis;
              return (
                (lastArgs = lastThis = void 0),
                (lastInvokeTime = time),
                (result = func.apply(thisArg, args))
              );
            }
            function leadingEdge(time) {
              return (
                (lastInvokeTime = time),
                (timerId = setTimeout(timerExpired, wait)),
                leading ? invokeFunc(time) : result
              );
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime;
              return (
                void 0 === lastCallTime ||
                timeSinceLastCall >= wait ||
                timeSinceLastCall < 0 ||
                (maxing && time - lastInvokeTime >= maxWait)
              );
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) return trailingEdge(time);
              timerId = setTimeout(
                timerExpired,
                (function(time) {
                  var result = wait - (time - lastCallTime);
                  return maxing
                    ? nativeMin(result, maxWait - (time - lastInvokeTime))
                    : result;
                })(time)
              );
            }
            function trailingEdge(time) {
              return (
                (timerId = void 0),
                trailing && lastArgs
                  ? invokeFunc(time)
                  : ((lastArgs = lastThis = void 0), result)
              );
            }
            function debounced() {
              var time = now(),
                isInvoking = shouldInvoke(time);
              if (
                ((lastArgs = arguments),
                (lastThis = this),
                (lastCallTime = time),
                isInvoking)
              ) {
                if (void 0 === timerId) return leadingEdge(lastCallTime);
                if (maxing)
                  return (
                    (timerId = setTimeout(timerExpired, wait)),
                    invokeFunc(lastCallTime)
                  );
              }
              return (
                void 0 === timerId &&
                  (timerId = setTimeout(timerExpired, wait)),
                result
              );
            }
            return (
              (wait = toNumber(wait) || 0),
              isObject(options) &&
                ((leading = !!options.leading),
                (maxWait = (maxing = 'maxWait' in options)
                  ? nativeMax(toNumber(options.maxWait) || 0, wait)
                  : maxWait),
                (trailing =
                  'trailing' in options ? !!options.trailing : trailing)),
              (debounced.cancel = function() {
                void 0 !== timerId && clearTimeout(timerId),
                  (lastInvokeTime = 0),
                  (lastArgs = lastCallTime = lastThis = timerId = void 0);
              }),
              (debounced.flush = function() {
                return void 0 === timerId ? result : trailingEdge(now());
              }),
              debounced
            );
          })(func, wait, {
            leading: leading,
            maxWait: wait,
            trailing: trailing
          })
        );
      };
    },
    hh1v: function(module, exports) {
      module.exports = function(it) {
        return 'object' == typeof it ? null !== it : 'function' == typeof it;
      };
    },
    iqWW: function(module, exports, __webpack_require__) {
      'use strict';
      var charAt = __webpack_require__('ZUd8').charAt;
      module.exports = function(S, index, unicode) {
        return index + (unicode ? charAt(S, index).length : 1);
      };
    },
    itXk: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return combineLatest;
      });
      var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'z+Ro'
        ),
        _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'DH7j'
        ),
        _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'l7GE'
        ),
        _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          'ZUHj'
        ),
        _fromArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__('yCtX');
      const NONE = {};
      function combineLatest(...observables) {
        let resultSelector = null,
          scheduler = null;
        return (
          Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.a)(
            observables[observables.length - 1]
          ) && (scheduler = observables.pop()),
          'function' == typeof observables[observables.length - 1] &&
            (resultSelector = observables.pop()),
          1 === observables.length &&
            Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__.a)(
              observables[0]
            ) &&
            (observables = observables[0]),
          Object(_fromArray__WEBPACK_IMPORTED_MODULE_4__.a)(
            observables,
            scheduler
          ).lift(new CombineLatestOperator(resultSelector))
        );
      }
      class CombineLatestOperator {
        constructor(resultSelector) {
          this.resultSelector = resultSelector;
        }
        call(subscriber, source) {
          return source.subscribe(
            new CombineLatestSubscriber(subscriber, this.resultSelector)
          );
        }
      }
      class CombineLatestSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__.a {
        constructor(destination, resultSelector) {
          super(destination),
            (this.resultSelector = resultSelector),
            (this.active = 0),
            (this.values = []),
            (this.observables = []);
        }
        _next(observable) {
          this.values.push(NONE), this.observables.push(observable);
        }
        _complete() {
          const observables = this.observables,
            len = observables.length;
          if (0 === len) this.destination.complete();
          else {
            (this.active = len), (this.toRespond = len);
            for (let i = 0; i < len; i++) {
              const observable = observables[i];
              this.add(
                Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__.a)(
                  this,
                  observable,
                  observable,
                  i
                )
              );
            }
          }
        }
        notifyComplete(unused) {
          0 == (this.active -= 1) && this.destination.complete();
        }
        notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          const values = this.values,
            toRespond = this.toRespond
              ? values[outerIndex] === NONE
                ? --this.toRespond
                : this.toRespond
              : 0;
          (values[outerIndex] = innerValue),
            0 === toRespond &&
              (this.resultSelector
                ? this._tryResultSelector(values)
                : this.destination.next(values.slice()));
        }
        _tryResultSelector(values) {
          let result;
          try {
            result = this.resultSelector.apply(this, values);
          } catch (err) {
            return void this.destination.error(err);
          }
          this.destination.next(result);
        }
      }
    },
    jZKg: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return scheduleArray;
      });
      var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'HDdC'
        ),
        _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'quSY'
        );
      function scheduleArray(input, scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(subscriber => {
          const sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.a();
          let i = 0;
          return (
            sub.add(
              scheduler.schedule(function() {
                i !== input.length
                  ? (subscriber.next(input[i++]),
                    subscriber.closed || sub.add(this.schedule()))
                  : subscriber.complete();
              })
            ),
            sub
          );
        });
      }
    },
    jhN1: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return BrowserModule;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return DomSanitizer;
        }),
        __webpack_require__.d(__webpack_exports__, 'c', function() {
          return Meta;
        }),
        __webpack_require__.d(__webpack_exports__, 'd', function() {
          return Title;
        }),
        __webpack_require__.d(__webpack_exports__, 'e', function() {
          return platformBrowser;
        });
      var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'ofXK'
        ),
        _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'fXoL'
        );
      class GenericBrowserDomAdapter extends _angular_common__WEBPACK_IMPORTED_MODULE_0__.w {
        constructor() {
          super();
        }
        supportsDOMEvents() {
          return !0;
        }
      }
      class BrowserDomAdapter extends GenericBrowserDomAdapter {
        static makeCurrent() {
          Object(_angular_common__WEBPACK_IMPORTED_MODULE_0__.A)(
            new BrowserDomAdapter()
          );
        }
        getProperty(el, name) {
          return el[name];
        }
        log(error) {
          window.console && window.console.log && window.console.log(error);
        }
        logGroup(error) {
          window.console && window.console.group && window.console.group(error);
        }
        logGroupEnd() {
          window.console &&
            window.console.groupEnd &&
            window.console.groupEnd();
        }
        onAndCancel(el, evt, listener) {
          return (
            el.addEventListener(evt, listener, !1),
            () => {
              el.removeEventListener(evt, listener, !1);
            }
          );
        }
        dispatchEvent(el, evt) {
          el.dispatchEvent(evt);
        }
        remove(node) {
          return node.parentNode && node.parentNode.removeChild(node), node;
        }
        getValue(el) {
          return el.value;
        }
        createElement(tagName, doc) {
          return (doc = doc || this.getDefaultDocument()).createElement(
            tagName
          );
        }
        createHtmlDocument() {
          return document.implementation.createHTMLDocument('fakeTitle');
        }
        getDefaultDocument() {
          return document;
        }
        isElementNode(node) {
          return node.nodeType === Node.ELEMENT_NODE;
        }
        isShadowRoot(node) {
          return node instanceof DocumentFragment;
        }
        getGlobalEventTarget(doc, target) {
          return 'window' === target
            ? window
            : 'document' === target
            ? doc
            : 'body' === target
            ? doc.body
            : null;
        }
        getHistory() {
          return window.history;
        }
        getLocation() {
          return window.location;
        }
        getBaseHref(doc) {
          const href =
            baseElement ||
            ((baseElement = document.querySelector('base')), baseElement)
              ? baseElement.getAttribute('href')
              : null;
          return null == href
            ? null
            : ((url = href),
              urlParsingNode || (urlParsingNode = document.createElement('a')),
              urlParsingNode.setAttribute('href', url),
              '/' === urlParsingNode.pathname.charAt(0)
                ? urlParsingNode.pathname
                : '/' + urlParsingNode.pathname);
          var url;
        }
        resetBaseElement() {
          baseElement = null;
        }
        getUserAgent() {
          return window.navigator.userAgent;
        }
        performanceNow() {
          return window.performance && window.performance.now
            ? window.performance.now()
            : new Date().getTime();
        }
        supportsCookies() {
          return !0;
        }
        getCookie(name) {
          return Object(_angular_common__WEBPACK_IMPORTED_MODULE_0__.z)(
            document.cookie,
            name
          );
        }
      }
      let urlParsingNode,
        baseElement = null;
      const TRANSITION_ID = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.q(
          'TRANSITION_ID'
        ),
        SERVER_TRANSITION_PROVIDERS = [
          {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.d,
            useFactory: function(transitionId, document, injector) {
              return () => {
                injector
                  .get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.e)
                  .donePromise.then(() => {
                    const dom = Object(
                      _angular_common__WEBPACK_IMPORTED_MODULE_0__.y
                    )();
                    Array.prototype.slice
                      .apply(document.querySelectorAll('style[ng-transition]'))
                      .filter(
                        el => el.getAttribute('ng-transition') === transitionId
                      )
                      .forEach(el => dom.remove(el));
                  });
              };
            },
            deps: [
              TRANSITION_ID,
              _angular_common__WEBPACK_IMPORTED_MODULE_0__.c,
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.r
            ],
            multi: !0
          }
        ];
      class BrowserGetTestability {
        static init() {
          Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.V)(
            new BrowserGetTestability()
          );
        }
        addToWindow(registry) {
          (_angular_core__WEBPACK_IMPORTED_MODULE_1__.mb.getAngularTestability = (
            elem,
            findInAncestors = !0
          ) => {
            const testability = registry.findTestabilityInTree(
              elem,
              findInAncestors
            );
            if (null == testability)
              throw new Error('Could not find testability for element.');
            return testability;
          }),
            (_angular_core__WEBPACK_IMPORTED_MODULE_1__.mb.getAllAngularTestabilities = () =>
              registry.getAllTestabilities()),
            (_angular_core__WEBPACK_IMPORTED_MODULE_1__.mb.getAllAngularRootElements = () =>
              registry.getAllRootElements()),
            _angular_core__WEBPACK_IMPORTED_MODULE_1__.mb
              .frameworkStabilizers ||
              (_angular_core__WEBPACK_IMPORTED_MODULE_1__.mb.frameworkStabilizers = []),
            _angular_core__WEBPACK_IMPORTED_MODULE_1__.mb.frameworkStabilizers.push(
              callback => {
                const testabilities = _angular_core__WEBPACK_IMPORTED_MODULE_1__.mb.getAllAngularTestabilities();
                let count = testabilities.length,
                  didWork = !1;
                const decrement = function(didWork_) {
                  (didWork = didWork || didWork_),
                    count--,
                    0 == count && callback(didWork);
                };
                testabilities.forEach(function(testability) {
                  testability.whenStable(decrement);
                });
              }
            );
        }
        findTestabilityInTree(registry, elem, findInAncestors) {
          if (null == elem) return null;
          const t = registry.getTestability(elem);
          return null != t
            ? t
            : findInAncestors
            ? Object(
                _angular_common__WEBPACK_IMPORTED_MODULE_0__.y
              )().isShadowRoot(elem)
              ? this.findTestabilityInTree(registry, elem.host, !0)
              : this.findTestabilityInTree(registry, elem.parentElement, !0)
            : null;
        }
      }
      const EVENT_MANAGER_PLUGINS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.q(
        'EventManagerPlugins'
      );
      let EventManager = (() => {
        class EventManager {
          constructor(plugins, _zone) {
            (this._zone = _zone),
              (this._eventNameToPlugin = new Map()),
              plugins.forEach(p => (p.manager = this)),
              (this._plugins = plugins.slice().reverse());
          }
          addEventListener(element, eventName, handler) {
            return this._findPluginFor(eventName).addEventListener(
              element,
              eventName,
              handler
            );
          }
          addGlobalEventListener(target, eventName, handler) {
            return this._findPluginFor(eventName).addGlobalEventListener(
              target,
              eventName,
              handler
            );
          }
          getZone() {
            return this._zone;
          }
          _findPluginFor(eventName) {
            const plugin = this._eventNameToPlugin.get(eventName);
            if (plugin) return plugin;
            const plugins = this._plugins;
            for (let i = 0; i < plugins.length; i++) {
              const plugin = plugins[i];
              if (plugin.supports(eventName))
                return this._eventNameToPlugin.set(eventName, plugin), plugin;
            }
            throw new Error(
              'No event manager plugin found for event ' + eventName
            );
          }
        }
        return (
          (EventManager.ɵfac = function(t) {
            return new (t || EventManager)(
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb(
                EVENT_MANAGER_PLUGINS
              ),
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb(
                _angular_core__WEBPACK_IMPORTED_MODULE_1__.z
              )
            );
          }),
          (EventManager.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Hb({
            token: EventManager,
            factory: EventManager.ɵfac
          })),
          EventManager
        );
      })();
      class EventManagerPlugin {
        constructor(_doc) {
          this._doc = _doc;
        }
        addGlobalEventListener(element, eventName, handler) {
          const target = Object(
            _angular_common__WEBPACK_IMPORTED_MODULE_0__.y
          )().getGlobalEventTarget(this._doc, element);
          if (!target)
            throw new Error(
              `Unsupported event target ${target} for event ${eventName}`
            );
          return this.addEventListener(target, eventName, handler);
        }
      }
      let SharedStylesHost = (() => {
          class SharedStylesHost {
            constructor() {
              this._stylesSet = new Set();
            }
            addStyles(styles) {
              const additions = new Set();
              styles.forEach(style => {
                this._stylesSet.has(style) ||
                  (this._stylesSet.add(style), additions.add(style));
              }),
                this.onStylesAdded(additions);
            }
            onStylesAdded(additions) {}
            getAllStyles() {
              return Array.from(this._stylesSet);
            }
          }
          return (
            (SharedStylesHost.ɵfac = function(t) {
              return new (t || SharedStylesHost)();
            }),
            (SharedStylesHost.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Hb(
              { token: SharedStylesHost, factory: SharedStylesHost.ɵfac }
            )),
            SharedStylesHost
          );
        })(),
        DomSharedStylesHost = (() => {
          class DomSharedStylesHost extends SharedStylesHost {
            constructor(_doc) {
              super(),
                (this._doc = _doc),
                (this._hostNodes = new Set()),
                (this._styleNodes = new Set()),
                this._hostNodes.add(_doc.head);
            }
            _addStylesToHost(styles, host) {
              styles.forEach(style => {
                const styleEl = this._doc.createElement('style');
                (styleEl.textContent = style),
                  this._styleNodes.add(host.appendChild(styleEl));
              });
            }
            addHost(hostNode) {
              this._addStylesToHost(this._stylesSet, hostNode),
                this._hostNodes.add(hostNode);
            }
            removeHost(hostNode) {
              this._hostNodes.delete(hostNode);
            }
            onStylesAdded(additions) {
              this._hostNodes.forEach(hostNode =>
                this._addStylesToHost(additions, hostNode)
              );
            }
            ngOnDestroy() {
              this._styleNodes.forEach(styleNode =>
                Object(_angular_common__WEBPACK_IMPORTED_MODULE_0__.y)().remove(
                  styleNode
                )
              );
            }
          }
          return (
            (DomSharedStylesHost.ɵfac = function(t) {
              return new (t || DomSharedStylesHost)(
                _angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb(
                  _angular_common__WEBPACK_IMPORTED_MODULE_0__.c
                )
              );
            }),
            (DomSharedStylesHost.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Hb(
              { token: DomSharedStylesHost, factory: DomSharedStylesHost.ɵfac }
            )),
            DomSharedStylesHost
          );
        })();
      const NAMESPACE_URIS = {
          svg: 'http://www.w3.org/2000/svg',
          xhtml: 'http://www.w3.org/1999/xhtml',
          xlink: 'http://www.w3.org/1999/xlink',
          xml: 'http://www.w3.org/XML/1998/namespace',
          xmlns: 'http://www.w3.org/2000/xmlns/'
        },
        COMPONENT_REGEX = /%COMP%/g;
      function flattenStyles(compId, styles, target) {
        for (let i = 0; i < styles.length; i++) {
          let style = styles[i];
          Array.isArray(style)
            ? flattenStyles(compId, style, target)
            : ((style = style.replace(COMPONENT_REGEX, compId)),
              target.push(style));
        }
        return target;
      }
      function decoratePreventDefault(eventHandler) {
        return event => {
          if ('__ngUnwrap__' === event) return eventHandler;
          !1 === eventHandler(event) &&
            (event.preventDefault(), (event.returnValue = !1));
        };
      }
      let DomRendererFactory2 = (() => {
        class DomRendererFactory2 {
          constructor(eventManager, sharedStylesHost, appId) {
            (this.eventManager = eventManager),
              (this.sharedStylesHost = sharedStylesHost),
              (this.appId = appId),
              (this.rendererByCompId = new Map()),
              (this.defaultRenderer = new DefaultDomRenderer2(eventManager));
          }
          createRenderer(element, type) {
            if (!element || !type) return this.defaultRenderer;
            switch (type.encapsulation) {
              case _angular_core__WEBPACK_IMPORTED_MODULE_1__.P.Emulated: {
                let renderer = this.rendererByCompId.get(type.id);
                return (
                  renderer ||
                    ((renderer = new EmulatedEncapsulationDomRenderer2(
                      this.eventManager,
                      this.sharedStylesHost,
                      type,
                      this.appId
                    )),
                    this.rendererByCompId.set(type.id, renderer)),
                  renderer.applyToHost(element),
                  renderer
                );
              }
              case _angular_core__WEBPACK_IMPORTED_MODULE_1__.P.Native:
              case _angular_core__WEBPACK_IMPORTED_MODULE_1__.P.ShadowDom:
                return new ShadowDomRenderer(
                  this.eventManager,
                  this.sharedStylesHost,
                  element,
                  type
                );
              default:
                if (!this.rendererByCompId.has(type.id)) {
                  const styles = flattenStyles(type.id, type.styles, []);
                  this.sharedStylesHost.addStyles(styles),
                    this.rendererByCompId.set(type.id, this.defaultRenderer);
                }
                return this.defaultRenderer;
            }
          }
          begin() {}
          end() {}
        }
        return (
          (DomRendererFactory2.ɵfac = function(t) {
            return new (t || DomRendererFactory2)(
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb(EventManager),
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb(
                DomSharedStylesHost
              ),
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb(
                _angular_core__WEBPACK_IMPORTED_MODULE_1__.c
              )
            );
          }),
          (DomRendererFactory2.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Hb(
            { token: DomRendererFactory2, factory: DomRendererFactory2.ɵfac }
          )),
          DomRendererFactory2
        );
      })();
      class DefaultDomRenderer2 {
        constructor(eventManager) {
          (this.eventManager = eventManager), (this.data = Object.create(null));
        }
        destroy() {}
        createElement(name, namespace) {
          return namespace
            ? document.createElementNS(
                NAMESPACE_URIS[namespace] || namespace,
                name
              )
            : document.createElement(name);
        }
        createComment(value) {
          return document.createComment(value);
        }
        createText(value) {
          return document.createTextNode(value);
        }
        appendChild(parent, newChild) {
          parent.appendChild(newChild);
        }
        insertBefore(parent, newChild, refChild) {
          parent && parent.insertBefore(newChild, refChild);
        }
        removeChild(parent, oldChild) {
          parent && parent.removeChild(oldChild);
        }
        selectRootElement(selectorOrNode, preserveContent) {
          let el =
            'string' == typeof selectorOrNode
              ? document.querySelector(selectorOrNode)
              : selectorOrNode;
          if (!el)
            throw new Error(
              `The selector "${selectorOrNode}" did not match any elements`
            );
          return preserveContent || (el.textContent = ''), el;
        }
        parentNode(node) {
          return node.parentNode;
        }
        nextSibling(node) {
          return node.nextSibling;
        }
        setAttribute(el, name, value, namespace) {
          if (namespace) {
            name = namespace + ':' + name;
            const namespaceUri = NAMESPACE_URIS[namespace];
            namespaceUri
              ? el.setAttributeNS(namespaceUri, name, value)
              : el.setAttribute(name, value);
          } else el.setAttribute(name, value);
        }
        removeAttribute(el, name, namespace) {
          if (namespace) {
            const namespaceUri = NAMESPACE_URIS[namespace];
            namespaceUri
              ? el.removeAttributeNS(namespaceUri, name)
              : el.removeAttribute(`${namespace}:${name}`);
          } else el.removeAttribute(name);
        }
        addClass(el, name) {
          el.classList.add(name);
        }
        removeClass(el, name) {
          el.classList.remove(name);
        }
        setStyle(el, style, value, flags) {
          flags & _angular_core__WEBPACK_IMPORTED_MODULE_1__.F.DashCase
            ? el.style.setProperty(
                style,
                value,
                flags & _angular_core__WEBPACK_IMPORTED_MODULE_1__.F.Important
                  ? 'important'
                  : ''
              )
            : (el.style[style] = value);
        }
        removeStyle(el, style, flags) {
          flags & _angular_core__WEBPACK_IMPORTED_MODULE_1__.F.DashCase
            ? el.style.removeProperty(style)
            : (el.style[style] = '');
        }
        setProperty(el, name, value) {
          el[name] = value;
        }
        setValue(node, value) {
          node.nodeValue = value;
        }
        listen(target, event, callback) {
          return 'string' == typeof target
            ? this.eventManager.addGlobalEventListener(
                target,
                event,
                decoratePreventDefault(callback)
              )
            : this.eventManager.addEventListener(
                target,
                event,
                decoratePreventDefault(callback)
              );
        }
      }
      class EmulatedEncapsulationDomRenderer2 extends DefaultDomRenderer2 {
        constructor(eventManager, sharedStylesHost, component, appId) {
          super(eventManager), (this.component = component);
          const styles = flattenStyles(
            appId + '-' + component.id,
            component.styles,
            []
          );
          sharedStylesHost.addStyles(styles),
            (this.contentAttr = '_ngcontent-%COMP%'.replace(
              COMPONENT_REGEX,
              appId + '-' + component.id
            )),
            (this.hostAttr = (function(componentShortId) {
              return '_nghost-%COMP%'.replace(
                COMPONENT_REGEX,
                componentShortId
              );
            })(appId + '-' + component.id));
        }
        applyToHost(element) {
          super.setAttribute(element, this.hostAttr, '');
        }
        createElement(parent, name) {
          const el = super.createElement(parent, name);
          return super.setAttribute(el, this.contentAttr, ''), el;
        }
      }
      class ShadowDomRenderer extends DefaultDomRenderer2 {
        constructor(eventManager, sharedStylesHost, hostEl, component) {
          super(eventManager),
            (this.sharedStylesHost = sharedStylesHost),
            (this.hostEl = hostEl),
            (this.component = component),
            (this.shadowRoot =
              component.encapsulation ===
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.P.ShadowDom
                ? hostEl.attachShadow({ mode: 'open' })
                : hostEl.createShadowRoot()),
            this.sharedStylesHost.addHost(this.shadowRoot);
          const styles = flattenStyles(component.id, component.styles, []);
          for (let i = 0; i < styles.length; i++) {
            const styleEl = document.createElement('style');
            (styleEl.textContent = styles[i]),
              this.shadowRoot.appendChild(styleEl);
          }
        }
        nodeOrShadowRoot(node) {
          return node === this.hostEl ? this.shadowRoot : node;
        }
        destroy() {
          this.sharedStylesHost.removeHost(this.shadowRoot);
        }
        appendChild(parent, newChild) {
          return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
        }
        insertBefore(parent, newChild, refChild) {
          return super.insertBefore(
            this.nodeOrShadowRoot(parent),
            newChild,
            refChild
          );
        }
        removeChild(parent, oldChild) {
          return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
        }
        parentNode(node) {
          return this.nodeOrShadowRoot(
            super.parentNode(this.nodeOrShadowRoot(node))
          );
        }
      }
      let DomEventsPlugin = (() => {
        class DomEventsPlugin extends EventManagerPlugin {
          constructor(doc) {
            super(doc);
          }
          supports(eventName) {
            return !0;
          }
          addEventListener(element, eventName, handler) {
            return (
              element.addEventListener(eventName, handler, !1),
              () => this.removeEventListener(element, eventName, handler)
            );
          }
          removeEventListener(target, eventName, callback) {
            return target.removeEventListener(eventName, callback);
          }
        }
        return (
          (DomEventsPlugin.ɵfac = function(t) {
            return new (t || DomEventsPlugin)(
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb(
                _angular_common__WEBPACK_IMPORTED_MODULE_0__.c
              )
            );
          }),
          (DomEventsPlugin.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Hb(
            { token: DomEventsPlugin, factory: DomEventsPlugin.ɵfac }
          )),
          DomEventsPlugin
        );
      })();
      const MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'],
        _keyMap = {
          '\b': 'Backspace',
          '\t': 'Tab',
          '': 'Delete',
          '': 'Escape',
          Del: 'Delete',
          Esc: 'Escape',
          Left: 'ArrowLeft',
          Right: 'ArrowRight',
          Up: 'ArrowUp',
          Down: 'ArrowDown',
          Menu: 'ContextMenu',
          Scroll: 'ScrollLock',
          Win: 'OS'
        },
        _chromeNumKeyPadMap = {
          A: '1',
          B: '2',
          C: '3',
          D: '4',
          E: '5',
          F: '6',
          G: '7',
          H: '8',
          I: '9',
          J: '*',
          K: '+',
          M: '-',
          N: '.',
          O: '/',
          '`': '0',
          '': 'NumLock'
        },
        MODIFIER_KEY_GETTERS = {
          alt: event => event.altKey,
          control: event => event.ctrlKey,
          meta: event => event.metaKey,
          shift: event => event.shiftKey
        };
      let KeyEventsPlugin = (() => {
          class KeyEventsPlugin extends EventManagerPlugin {
            constructor(doc) {
              super(doc);
            }
            supports(eventName) {
              return null != KeyEventsPlugin.parseEventName(eventName);
            }
            addEventListener(element, eventName, handler) {
              const parsedEvent = KeyEventsPlugin.parseEventName(eventName),
                outsideHandler = KeyEventsPlugin.eventCallback(
                  parsedEvent.fullKey,
                  handler,
                  this.manager.getZone()
                );
              return this.manager
                .getZone()
                .runOutsideAngular(() =>
                  Object(
                    _angular_common__WEBPACK_IMPORTED_MODULE_0__.y
                  )().onAndCancel(
                    element,
                    parsedEvent.domEventName,
                    outsideHandler
                  )
                );
            }
            static parseEventName(eventName) {
              const parts = eventName.toLowerCase().split('.'),
                domEventName = parts.shift();
              if (
                0 === parts.length ||
                ('keydown' !== domEventName && 'keyup' !== domEventName)
              )
                return null;
              const key = KeyEventsPlugin._normalizeKey(parts.pop());
              let fullKey = '';
              if (
                (MODIFIER_KEYS.forEach(modifierName => {
                  const index = parts.indexOf(modifierName);
                  index > -1 &&
                    (parts.splice(index, 1), (fullKey += modifierName + '.'));
                }),
                (fullKey += key),
                0 != parts.length || 0 === key.length)
              )
                return null;
              const result = {};
              return (
                (result.domEventName = domEventName),
                (result.fullKey = fullKey),
                result
              );
            }
            static getEventFullKey(event) {
              let fullKey = '',
                key = (function(event) {
                  let key = event.key;
                  if (null == key) {
                    if (((key = event.keyIdentifier), null == key))
                      return 'Unidentified';
                    key.startsWith('U+') &&
                      ((key = String.fromCharCode(
                        parseInt(key.substring(2), 16)
                      )),
                      3 === event.location &&
                        _chromeNumKeyPadMap.hasOwnProperty(key) &&
                        (key = _chromeNumKeyPadMap[key]));
                  }
                  return _keyMap[key] || key;
                })(event);
              return (
                (key = key.toLowerCase()),
                ' ' === key ? (key = 'space') : '.' === key && (key = 'dot'),
                MODIFIER_KEYS.forEach(modifierName => {
                  modifierName != key &&
                    (0, MODIFIER_KEY_GETTERS[modifierName])(event) &&
                    (fullKey += modifierName + '.');
                }),
                (fullKey += key),
                fullKey
              );
            }
            static eventCallback(fullKey, handler, zone) {
              return event => {
                KeyEventsPlugin.getEventFullKey(event) === fullKey &&
                  zone.runGuarded(() => handler(event));
              };
            }
            static _normalizeKey(keyName) {
              switch (keyName) {
                case 'esc':
                  return 'escape';
                default:
                  return keyName;
              }
            }
          }
          return (
            (KeyEventsPlugin.ɵfac = function(t) {
              return new (t || KeyEventsPlugin)(
                _angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb(
                  _angular_common__WEBPACK_IMPORTED_MODULE_0__.c
                )
              );
            }),
            (KeyEventsPlugin.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Hb(
              { token: KeyEventsPlugin, factory: KeyEventsPlugin.ɵfac }
            )),
            KeyEventsPlugin
          );
        })(),
        DomSanitizer = (() => {
          class DomSanitizer {}
          return (
            (DomSanitizer.ɵfac = function(t) {
              return new (t || DomSanitizer)();
            }),
            (DomSanitizer.ɵprov = Object(
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.Hb
            )({
              factory: function() {
                return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb)(
                  DomSanitizerImpl
                );
              },
              token: DomSanitizer,
              providedIn: 'root'
            })),
            DomSanitizer
          );
        })();
      function domSanitizerImplFactory(injector) {
        return new DomSanitizerImpl(
          injector.get(_angular_common__WEBPACK_IMPORTED_MODULE_0__.c)
        );
      }
      let DomSanitizerImpl = (() => {
        class DomSanitizerImpl extends DomSanitizer {
          constructor(_doc) {
            super(), (this._doc = _doc);
          }
          sanitize(ctx, value) {
            if (null == value) return null;
            switch (ctx) {
              case _angular_core__WEBPACK_IMPORTED_MODULE_1__.H.NONE:
                return value;
              case _angular_core__WEBPACK_IMPORTED_MODULE_1__.H.HTML:
                return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.bb)(
                  value,
                  'HTML'
                )
                  ? Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.tb)(value)
                  : Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Z)(
                      this._doc,
                      String(value)
                    );
              case _angular_core__WEBPACK_IMPORTED_MODULE_1__.H.STYLE:
                return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.bb)(
                  value,
                  'Style'
                )
                  ? Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.tb)(value)
                  : value;
              case _angular_core__WEBPACK_IMPORTED_MODULE_1__.H.SCRIPT:
                if (
                  Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.bb)(
                    value,
                    'Script'
                  )
                )
                  return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.tb)(
                    value
                  );
                throw new Error('unsafe value used in a script context');
              case _angular_core__WEBPACK_IMPORTED_MODULE_1__.H.URL:
                return (
                  Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.lb)(value),
                  Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.bb)(
                    value,
                    'URL'
                  )
                    ? Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.tb)(
                        value
                      )
                    : Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ab)(
                        String(value)
                      )
                );
              case _angular_core__WEBPACK_IMPORTED_MODULE_1__.H.RESOURCE_URL:
                if (
                  Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.bb)(
                    value,
                    'ResourceURL'
                  )
                )
                  return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.tb)(
                    value
                  );
                throw new Error(
                  'unsafe value used in a resource URL context (see http://g.co/ng/security#xss)'
                );
              default:
                throw new Error(
                  `Unexpected SecurityContext ${ctx} (see http://g.co/ng/security#xss)`
                );
            }
          }
          bypassSecurityTrustHtml(value) {
            return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.cb)(value);
          }
          bypassSecurityTrustStyle(value) {
            return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.fb)(value);
          }
          bypassSecurityTrustScript(value) {
            return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.eb)(value);
          }
          bypassSecurityTrustUrl(value) {
            return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.gb)(value);
          }
          bypassSecurityTrustResourceUrl(value) {
            return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.db)(value);
          }
        }
        return (
          (DomSanitizerImpl.ɵfac = function(t) {
            return new (t || DomSanitizerImpl)(
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb(
                _angular_common__WEBPACK_IMPORTED_MODULE_0__.c
              )
            );
          }),
          (DomSanitizerImpl.ɵprov = Object(
            _angular_core__WEBPACK_IMPORTED_MODULE_1__.Hb
          )({
            factory: function() {
              return domSanitizerImplFactory(
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb)(
                  _angular_core__WEBPACK_IMPORTED_MODULE_1__.o
                )
              );
            },
            token: DomSanitizerImpl,
            providedIn: 'root'
          })),
          DomSanitizerImpl
        );
      })();
      const INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
          {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.B,
            useValue: _angular_common__WEBPACK_IMPORTED_MODULE_0__.x
          },
          {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.C,
            useValue: function() {
              BrowserDomAdapter.makeCurrent(), BrowserGetTestability.init();
            },
            multi: !0
          },
          {
            provide: _angular_common__WEBPACK_IMPORTED_MODULE_0__.c,
            useFactory: function() {
              return (
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.rb)(document),
                document
              );
            },
            deps: []
          }
        ],
        platformBrowser = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Q)(
          _angular_core__WEBPACK_IMPORTED_MODULE_1__.U,
          'browser',
          INTERNAL_BROWSER_PLATFORM_PROVIDERS
        ),
        BROWSER_MODULE_PROVIDERS = [
          [],
          {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.X,
            useValue: 'root'
          },
          {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.m,
            useFactory: function() {
              return new _angular_core__WEBPACK_IMPORTED_MODULE_1__.m();
            },
            deps: []
          },
          {
            provide: EVENT_MANAGER_PLUGINS,
            useClass: DomEventsPlugin,
            multi: !0,
            deps: [
              _angular_common__WEBPACK_IMPORTED_MODULE_0__.c,
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.z,
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.B
            ]
          },
          {
            provide: EVENT_MANAGER_PLUGINS,
            useClass: KeyEventsPlugin,
            multi: !0,
            deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.c]
          },
          [],
          {
            provide: DomRendererFactory2,
            useClass: DomRendererFactory2,
            deps: [
              EventManager,
              DomSharedStylesHost,
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.c
            ]
          },
          {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.E,
            useExisting: DomRendererFactory2
          },
          { provide: SharedStylesHost, useExisting: DomSharedStylesHost },
          {
            provide: DomSharedStylesHost,
            useClass: DomSharedStylesHost,
            deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.c]
          },
          {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.L,
            useClass: _angular_core__WEBPACK_IMPORTED_MODULE_1__.L,
            deps: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.z]
          },
          {
            provide: EventManager,
            useClass: EventManager,
            deps: [
              EVENT_MANAGER_PLUGINS,
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.z
            ]
          },
          []
        ];
      let BrowserModule = (() => {
        class BrowserModule {
          constructor(parentModule) {
            if (parentModule)
              throw new Error(
                'BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.'
              );
          }
          static withServerTransition(params) {
            return {
              ngModule: BrowserModule,
              providers: [
                {
                  provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.c,
                  useValue: params.appId
                },
                {
                  provide: TRANSITION_ID,
                  useExisting: _angular_core__WEBPACK_IMPORTED_MODULE_1__.c
                },
                SERVER_TRANSITION_PROVIDERS
              ]
            };
          }
        }
        return (
          (BrowserModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Jb({
            type: BrowserModule
          })),
          (BrowserModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Ib({
            factory: function(t) {
              return new (t || BrowserModule)(
                _angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb(BrowserModule, 12)
              );
            },
            providers: BROWSER_MODULE_PROVIDERS,
            imports: [
              _angular_common__WEBPACK_IMPORTED_MODULE_0__.b,
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.f
            ]
          })),
          BrowserModule
        );
      })();
      function createMeta() {
        return new Meta(
          Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb)(
            _angular_common__WEBPACK_IMPORTED_MODULE_0__.c
          )
        );
      }
      let Meta = (() => {
        class Meta {
          constructor(_doc) {
            (this._doc = _doc),
              (this._dom = Object(
                _angular_common__WEBPACK_IMPORTED_MODULE_0__.y
              )());
          }
          addTag(tag, forceCreation = !1) {
            return tag ? this._getOrCreateElement(tag, forceCreation) : null;
          }
          addTags(tags, forceCreation = !1) {
            return tags
              ? tags.reduce(
                  (result, tag) => (
                    tag &&
                      result.push(this._getOrCreateElement(tag, forceCreation)),
                    result
                  ),
                  []
                )
              : [];
          }
          getTag(attrSelector) {
            return (
              (attrSelector &&
                this._doc.querySelector(`meta[${attrSelector}]`)) ||
              null
            );
          }
          getTags(attrSelector) {
            if (!attrSelector) return [];
            const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
            return list ? [].slice.call(list) : [];
          }
          updateTag(tag, selector) {
            if (!tag) return null;
            selector = selector || this._parseSelector(tag);
            const meta = this.getTag(selector);
            return meta
              ? this._setMetaElementAttributes(tag, meta)
              : this._getOrCreateElement(tag, !0);
          }
          removeTag(attrSelector) {
            this.removeTagElement(this.getTag(attrSelector));
          }
          removeTagElement(meta) {
            meta && this._dom.remove(meta);
          }
          _getOrCreateElement(meta, forceCreation = !1) {
            if (!forceCreation) {
              const selector = this._parseSelector(meta),
                elem = this.getTag(selector);
              if (elem && this._containsAttributes(meta, elem)) return elem;
            }
            const element = this._dom.createElement('meta');
            return (
              this._setMetaElementAttributes(meta, element),
              this._doc.getElementsByTagName('head')[0].appendChild(element),
              element
            );
          }
          _setMetaElementAttributes(tag, el) {
            return (
              Object.keys(tag).forEach(prop =>
                el.setAttribute(prop, tag[prop])
              ),
              el
            );
          }
          _parseSelector(tag) {
            const attr = tag.name ? 'name' : 'property';
            return `${attr}="${tag[attr]}"`;
          }
          _containsAttributes(tag, elem) {
            return Object.keys(tag).every(
              key => elem.getAttribute(key) === tag[key]
            );
          }
        }
        return (
          (Meta.ɵfac = function(t) {
            return new (t || Meta)(
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb(
                _angular_common__WEBPACK_IMPORTED_MODULE_0__.c
              )
            );
          }),
          (Meta.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Hb)({
            factory: createMeta,
            token: Meta,
            providedIn: 'root'
          })),
          Meta
        );
      })();
      function createTitle() {
        return new Title(
          Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb)(
            _angular_common__WEBPACK_IMPORTED_MODULE_0__.c
          )
        );
      }
      let Title = (() => {
        class Title {
          constructor(_doc) {
            this._doc = _doc;
          }
          getTitle() {
            return this._doc.title;
          }
          setTitle(newTitle) {
            this._doc.title = newTitle || '';
          }
        }
        return (
          (Title.ɵfac = function(t) {
            return new (t || Title)(
              _angular_core__WEBPACK_IMPORTED_MODULE_1__.Yb(
                _angular_common__WEBPACK_IMPORTED_MODULE_0__.c
              )
            );
          }),
          (Title.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Hb)({
            factory: createTitle,
            token: Title,
            providedIn: 'root'
          })),
          Title
        );
      })();
      'undefined' != typeof window && window;
    },
    kJWO: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return observable;
      });
      const observable = (() =>
        ('function' == typeof Symbol && Symbol.observable) || '@@observable')();
    },
    kOOl: function(module, exports) {
      var id = 0,
        postfix = Math.random();
      module.exports = function(key) {
        return (
          'Symbol(' +
          String(void 0 === key ? '' : key) +
          ')_' +
          (++id + postfix).toString(36)
        );
      };
    },
    kmMV: function(module, exports, __webpack_require__) {
      'use strict';
      var re1,
        re2,
        regexpFlags = __webpack_require__('rW0t'),
        nativeExec = RegExp.prototype.exec,
        nativeReplace = String.prototype.replace,
        patchedExec = nativeExec,
        UPDATES_LAST_INDEX_WRONG =
          ((re2 = /b*/g),
          nativeExec.call((re1 = /a/), 'a'),
          nativeExec.call(re2, 'a'),
          0 !== re1.lastIndex || 0 !== re2.lastIndex),
        NPCG_INCLUDED = void 0 !== /()??/.exec('')[1];
      (UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED) &&
        (patchedExec = function(str) {
          var lastIndex,
            reCopy,
            match,
            i,
            re = this;
          return (
            NPCG_INCLUDED &&
              (reCopy = new RegExp(
                '^' + re.source + '$(?!\\s)',
                regexpFlags.call(re)
              )),
            UPDATES_LAST_INDEX_WRONG && (lastIndex = re.lastIndex),
            (match = nativeExec.call(re, str)),
            UPDATES_LAST_INDEX_WRONG &&
              match &&
              (re.lastIndex = re.global
                ? match.index + match[0].length
                : lastIndex),
            NPCG_INCLUDED &&
              match &&
              match.length > 1 &&
              nativeReplace.call(match[0], reCopy, function() {
                for (i = 1; i < arguments.length - 2; i++)
                  void 0 === arguments[i] && (match[i] = void 0);
              }),
            match
          );
        }),
        (module.exports = patchedExec);
    },
    l7GE: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return OuterSubscriber;
      });
      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        '7o/Q'
      );
      class OuterSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
        notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(innerValue);
        }
        notifyError(error, innerSub) {
          this.destination.error(error);
        }
        notifyComplete(innerSub) {
          this.destination.complete();
        }
      }
    },
    lJxs: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return map;
      });
      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        '7o/Q'
      );
      function map(project, thisArg) {
        return function(source) {
          if ('function' != typeof project)
            throw new TypeError(
              'argument is not a function. Are you looking for `mapTo()`?'
            );
          return source.lift(new MapOperator(project, thisArg));
        };
      }
      class MapOperator {
        constructor(project, thisArg) {
          (this.project = project), (this.thisArg = thisArg);
        }
        call(subscriber, source) {
          return source.subscribe(
            new MapSubscriber(subscriber, this.project, this.thisArg)
          );
        }
      }
      class MapSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(destination, project, thisArg) {
          super(destination),
            (this.project = project),
            (this.count = 0),
            (this.thisArg = thisArg || this);
        }
        _next(value) {
          let result;
          try {
            result = this.project.call(this.thisArg, value, this.count++);
          } catch (err) {
            return void this.destination.error(err);
          }
          this.destination.next(result);
        }
      }
    },
    lMq5: function(module, exports, __webpack_require__) {
      var fails = __webpack_require__('0Dky'),
        replacement = /#|\.prototype\./,
        isForced = function(feature, detection) {
          var value = data[normalize(feature)];
          return (
            value == POLYFILL ||
            (value != NATIVE &&
              ('function' == typeof detection ? fails(detection) : !!detection))
          );
        },
        normalize = (isForced.normalize = function(string) {
          return String(string)
            .replace(replacement, '.')
            .toLowerCase();
        }),
        data = (isForced.data = {}),
        NATIVE = (isForced.NATIVE = 'N'),
        POLYFILL = (isForced.POLYFILL = 'P');
      module.exports = isForced;
    },
    'm/L8': function(module, exports, __webpack_require__) {
      var DESCRIPTORS = __webpack_require__('g6v/'),
        IE8_DOM_DEFINE = __webpack_require__('DPsx'),
        anObject = __webpack_require__('glrk'),
        toPrimitive = __webpack_require__('wE6v'),
        nativeDefineProperty = Object.defineProperty;
      exports.f = DESCRIPTORS
        ? nativeDefineProperty
        : function(O, P, Attributes) {
            if (
              (anObject(O),
              (P = toPrimitive(P, !0)),
              anObject(Attributes),
              IE8_DOM_DEFINE)
            )
              try {
                return nativeDefineProperty(O, P, Attributes);
              } catch (error) {}
            if ('get' in Attributes || 'set' in Attributes)
              throw TypeError('Accessors not supported');
            return 'value' in Attributes && (O[P] = Attributes.value), O;
          };
    },
    m92n: function(module, exports, __webpack_require__) {
      var anObject = __webpack_require__('glrk');
      module.exports = function(iterator, fn, value, ENTRIES) {
        try {
          return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
        } catch (error) {
          var returnMethod = iterator.return;
          throw (void 0 !== returnMethod &&
            anObject(returnMethod.call(iterator)),
          error);
        }
      };
    },
    mCNh: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return pipe;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return pipeFromArray;
        });
      var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__('KqfI');
      function pipe(...fns) {
        return pipeFromArray(fns);
      }
      function pipeFromArray(fns) {
        return fns
          ? 1 === fns.length
            ? fns[0]
            : function(input) {
                return fns.reduce((prev, fn) => fn(prev), input);
              }
          : _noop__WEBPACK_IMPORTED_MODULE_0__.a;
      }
    },
    n6bG: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function isFunction(x) {
        return 'function' == typeof x;
      }
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return isFunction;
      });
    },
    ngJS: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return subscribeToArray;
      });
      const subscribeToArray = array => subscriber => {
        for (let i = 0, len = array.length; i < len && !subscriber.closed; i++)
          subscriber.next(array[i]);
        subscriber.complete();
      };
    },
    noGo: function(module, exports, __webpack_require__) {
      var shared = __webpack_require__('VpIT');
      module.exports = shared('native-function-to-string', Function.toString);
    },
    ntOU: function(module, exports, __webpack_require__) {
      'use strict';
      var IteratorPrototype = __webpack_require__('rpNk').IteratorPrototype,
        create = __webpack_require__('fHMY'),
        createPropertyDescriptor = __webpack_require__('XGwC'),
        setToStringTag = __webpack_require__('1E5z'),
        Iterators = __webpack_require__('P4y1'),
        returnThis = function() {
          return this;
        };
      module.exports = function(IteratorConstructor, NAME, next) {
        var TO_STRING_TAG = NAME + ' Iterator';
        return (
          (IteratorConstructor.prototype = create(IteratorPrototype, {
            next: createPropertyDescriptor(1, next)
          })),
          setToStringTag(IteratorConstructor, TO_STRING_TAG, !1, !0),
          (Iterators[TO_STRING_TAG] = returnThis),
          IteratorConstructor
        );
      };
    },
    ofXK: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return APP_BASE_HREF;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return CommonModule;
        }),
        __webpack_require__.d(__webpack_exports__, 'c', function() {
          return DOCUMENT;
        }),
        __webpack_require__.d(__webpack_exports__, 'd', function() {
          return FormStyle;
        }),
        __webpack_require__.d(__webpack_exports__, 'e', function() {
          return HashLocationStrategy;
        }),
        __webpack_require__.d(__webpack_exports__, 'f', function() {
          return LOCATION_INITIALIZED;
        }),
        __webpack_require__.d(__webpack_exports__, 'g', function() {
          return Location;
        }),
        __webpack_require__.d(__webpack_exports__, 'h', function() {
          return LocationStrategy;
        }),
        __webpack_require__.d(__webpack_exports__, 'i', function() {
          return NgClass;
        }),
        __webpack_require__.d(__webpack_exports__, 'j', function() {
          return NgForOf;
        }),
        __webpack_require__.d(__webpack_exports__, 'k', function() {
          return NgIf;
        }),
        __webpack_require__.d(__webpack_exports__, 'l', function() {
          return NgStyle;
        }),
        __webpack_require__.d(__webpack_exports__, 'm', function() {
          return NgTemplateOutlet;
        }),
        __webpack_require__.d(__webpack_exports__, 'n', function() {
          return PathLocationStrategy;
        }),
        __webpack_require__.d(__webpack_exports__, 'o', function() {
          return PlatformLocation;
        }),
        __webpack_require__.d(__webpack_exports__, 'p', function() {
          return TranslationWidth;
        }),
        __webpack_require__.d(__webpack_exports__, 'q', function() {
          return ViewportScroller;
        }),
        __webpack_require__.d(__webpack_exports__, 'r', function() {
          return formatDate;
        }),
        __webpack_require__.d(__webpack_exports__, 's', function() {
          return getLocaleDayNames;
        }),
        __webpack_require__.d(__webpack_exports__, 't', function() {
          return getLocaleDayPeriods;
        }),
        __webpack_require__.d(__webpack_exports__, 'u', function() {
          return getLocaleMonthNames;
        }),
        __webpack_require__.d(__webpack_exports__, 'v', function() {
          return isPlatformBrowser;
        }),
        __webpack_require__.d(__webpack_exports__, 'w', function() {
          return DomAdapter;
        }),
        __webpack_require__.d(__webpack_exports__, 'x', function() {
          return PLATFORM_BROWSER_ID;
        }),
        __webpack_require__.d(__webpack_exports__, 'y', function() {
          return getDOM;
        }),
        __webpack_require__.d(__webpack_exports__, 'z', function() {
          return parseCookieValue;
        }),
        __webpack_require__.d(__webpack_exports__, 'A', function() {
          return setRootDomAdapter;
        });
      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        'fXoL'
      );
      let _DOM = null;
      function getDOM() {
        return _DOM;
      }
      function setRootDomAdapter(adapter) {
        _DOM || (_DOM = adapter);
      }
      class DomAdapter {}
      const DOCUMENT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.q(
        'DocumentToken'
      );
      let PlatformLocation = (() => {
        class PlatformLocation {}
        return (
          (PlatformLocation.ɵfac = function(t) {
            return new (t || PlatformLocation)();
          }),
          (PlatformLocation.ɵprov = Object(
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb
          )({
            factory: useBrowserPlatformLocation,
            token: PlatformLocation,
            providedIn: 'platform'
          })),
          PlatformLocation
        );
      })();
      function useBrowserPlatformLocation() {
        return Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb)(
          BrowserPlatformLocation
        );
      }
      const LOCATION_INITIALIZED = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.q(
        'Location Initialized'
      );
      let BrowserPlatformLocation = (() => {
        class BrowserPlatformLocation extends PlatformLocation {
          constructor(_doc) {
            super(), (this._doc = _doc), this._init();
          }
          _init() {
            (this.location = getDOM().getLocation()),
              (this._history = getDOM().getHistory());
          }
          getBaseHrefFromDOM() {
            return getDOM().getBaseHref(this._doc);
          }
          onPopState(fn) {
            getDOM()
              .getGlobalEventTarget(this._doc, 'window')
              .addEventListener('popstate', fn, !1);
          }
          onHashChange(fn) {
            getDOM()
              .getGlobalEventTarget(this._doc, 'window')
              .addEventListener('hashchange', fn, !1);
          }
          get href() {
            return this.location.href;
          }
          get protocol() {
            return this.location.protocol;
          }
          get hostname() {
            return this.location.hostname;
          }
          get port() {
            return this.location.port;
          }
          get pathname() {
            return this.location.pathname;
          }
          get search() {
            return this.location.search;
          }
          get hash() {
            return this.location.hash;
          }
          set pathname(newPath) {
            this.location.pathname = newPath;
          }
          pushState(state, title, url) {
            supportsState()
              ? this._history.pushState(state, title, url)
              : (this.location.hash = url);
          }
          replaceState(state, title, url) {
            supportsState()
              ? this._history.replaceState(state, title, url)
              : (this.location.hash = url);
          }
          forward() {
            this._history.forward();
          }
          back() {
            this._history.back();
          }
          getState() {
            return this._history.state;
          }
        }
        return (
          (BrowserPlatformLocation.ɵfac = function(t) {
            return new (t || BrowserPlatformLocation)(
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(DOCUMENT)
            );
          }),
          (BrowserPlatformLocation.ɵprov = Object(
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb
          )({
            factory: createBrowserPlatformLocation,
            token: BrowserPlatformLocation,
            providedIn: 'platform'
          })),
          BrowserPlatformLocation
        );
      })();
      function supportsState() {
        return !!window.history.pushState;
      }
      function createBrowserPlatformLocation() {
        return new BrowserPlatformLocation(
          Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb)(DOCUMENT)
        );
      }
      function joinWithSlash(start, end) {
        if (0 == start.length) return end;
        if (0 == end.length) return start;
        let slashes = 0;
        return (
          start.endsWith('/') && slashes++,
          end.startsWith('/') && slashes++,
          2 == slashes
            ? start + end.substring(1)
            : 1 == slashes
            ? start + end
            : start + '/' + end
        );
      }
      function stripTrailingSlash(url) {
        const match = url.match(/#|\?|$/),
          pathEndIdx = (match && match.index) || url.length;
        return (
          url.slice(0, pathEndIdx - ('/' === url[pathEndIdx - 1] ? 1 : 0)) +
          url.slice(pathEndIdx)
        );
      }
      function normalizeQueryParams(params) {
        return params && '?' !== params[0] ? '?' + params : params;
      }
      let LocationStrategy = (() => {
        class LocationStrategy {}
        return (
          (LocationStrategy.ɵfac = function(t) {
            return new (t || LocationStrategy)();
          }),
          (LocationStrategy.ɵprov = Object(
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb
          )({
            factory: provideLocationStrategy,
            token: LocationStrategy,
            providedIn: 'root'
          })),
          LocationStrategy
        );
      })();
      function provideLocationStrategy(platformLocation) {
        const location = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb)(
          DOCUMENT
        ).location;
        return new PathLocationStrategy(
          Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb)(
            PlatformLocation
          ),
          (location && location.origin) || ''
        );
      }
      const APP_BASE_HREF = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.q(
        'appBaseHref'
      );
      let PathLocationStrategy = (() => {
          class PathLocationStrategy extends LocationStrategy {
            constructor(_platformLocation, href) {
              if (
                (super(),
                (this._platformLocation = _platformLocation),
                null == href &&
                  (href = this._platformLocation.getBaseHrefFromDOM()),
                null == href)
              )
                throw new Error(
                  'No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.'
                );
              this._baseHref = href;
            }
            onPopState(fn) {
              this._platformLocation.onPopState(fn),
                this._platformLocation.onHashChange(fn);
            }
            getBaseHref() {
              return this._baseHref;
            }
            prepareExternalUrl(internal) {
              return joinWithSlash(this._baseHref, internal);
            }
            path(includeHash = !1) {
              const pathname =
                  this._platformLocation.pathname +
                  normalizeQueryParams(this._platformLocation.search),
                hash = this._platformLocation.hash;
              return hash && includeHash ? `${pathname}${hash}` : pathname;
            }
            pushState(state, title, url, queryParams) {
              const externalUrl = this.prepareExternalUrl(
                url + normalizeQueryParams(queryParams)
              );
              this._platformLocation.pushState(state, title, externalUrl);
            }
            replaceState(state, title, url, queryParams) {
              const externalUrl = this.prepareExternalUrl(
                url + normalizeQueryParams(queryParams)
              );
              this._platformLocation.replaceState(state, title, externalUrl);
            }
            forward() {
              this._platformLocation.forward();
            }
            back() {
              this._platformLocation.back();
            }
          }
          return (
            (PathLocationStrategy.ɵfac = function(t) {
              return new (t || PathLocationStrategy)(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(PlatformLocation),
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(APP_BASE_HREF, 8)
              );
            }),
            (PathLocationStrategy.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb(
              {
                token: PathLocationStrategy,
                factory: PathLocationStrategy.ɵfac
              }
            )),
            PathLocationStrategy
          );
        })(),
        HashLocationStrategy = (() => {
          class HashLocationStrategy extends LocationStrategy {
            constructor(_platformLocation, _baseHref) {
              super(),
                (this._platformLocation = _platformLocation),
                (this._baseHref = ''),
                null != _baseHref && (this._baseHref = _baseHref);
            }
            onPopState(fn) {
              this._platformLocation.onPopState(fn),
                this._platformLocation.onHashChange(fn);
            }
            getBaseHref() {
              return this._baseHref;
            }
            path(includeHash = !1) {
              let path = this._platformLocation.hash;
              return (
                null == path && (path = '#'),
                path.length > 0 ? path.substring(1) : path
              );
            }
            prepareExternalUrl(internal) {
              const url = joinWithSlash(this._baseHref, internal);
              return url.length > 0 ? '#' + url : url;
            }
            pushState(state, title, path, queryParams) {
              let url = this.prepareExternalUrl(
                path + normalizeQueryParams(queryParams)
              );
              0 == url.length && (url = this._platformLocation.pathname),
                this._platformLocation.pushState(state, title, url);
            }
            replaceState(state, title, path, queryParams) {
              let url = this.prepareExternalUrl(
                path + normalizeQueryParams(queryParams)
              );
              0 == url.length && (url = this._platformLocation.pathname),
                this._platformLocation.replaceState(state, title, url);
            }
            forward() {
              this._platformLocation.forward();
            }
            back() {
              this._platformLocation.back();
            }
          }
          return (
            (HashLocationStrategy.ɵfac = function(t) {
              return new (t || HashLocationStrategy)(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(PlatformLocation),
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(APP_BASE_HREF, 8)
              );
            }),
            (HashLocationStrategy.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb(
              {
                token: HashLocationStrategy,
                factory: HashLocationStrategy.ɵfac
              }
            )),
            HashLocationStrategy
          );
        })(),
        Location = (() => {
          class Location {
            constructor(platformStrategy, platformLocation) {
              (this._subject = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.n()),
                (this._urlChangeListeners = []),
                (this._platformStrategy = platformStrategy);
              const browserBaseHref = this._platformStrategy.getBaseHref();
              (this._platformLocation = platformLocation),
                (this._baseHref = stripTrailingSlash(
                  _stripIndexHtml(browserBaseHref)
                )),
                this._platformStrategy.onPopState(ev => {
                  this._subject.emit({
                    url: this.path(!0),
                    pop: !0,
                    state: ev.state,
                    type: ev.type
                  });
                });
            }
            path(includeHash = !1) {
              return this.normalize(this._platformStrategy.path(includeHash));
            }
            getState() {
              return this._platformLocation.getState();
            }
            isCurrentPathEqualTo(path, query = '') {
              return (
                this.path() ==
                this.normalize(path + normalizeQueryParams(query))
              );
            }
            normalize(url) {
              return Location.stripTrailingSlash(
                (function(baseHref, url) {
                  return baseHref && url.startsWith(baseHref)
                    ? url.substring(baseHref.length)
                    : url;
                })(this._baseHref, _stripIndexHtml(url))
              );
            }
            prepareExternalUrl(url) {
              return (
                url && '/' !== url[0] && (url = '/' + url),
                this._platformStrategy.prepareExternalUrl(url)
              );
            }
            go(path, query = '', state = null) {
              this._platformStrategy.pushState(state, '', path, query),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(path + normalizeQueryParams(query)),
                  state
                );
            }
            replaceState(path, query = '', state = null) {
              this._platformStrategy.replaceState(state, '', path, query),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(path + normalizeQueryParams(query)),
                  state
                );
            }
            forward() {
              this._platformStrategy.forward();
            }
            back() {
              this._platformStrategy.back();
            }
            onUrlChange(fn) {
              this._urlChangeListeners.push(fn),
                this._urlChangeSubscription ||
                  (this._urlChangeSubscription = this.subscribe(v => {
                    this._notifyUrlChangeListeners(v.url, v.state);
                  }));
            }
            _notifyUrlChangeListeners(url = '', state) {
              this._urlChangeListeners.forEach(fn => fn(url, state));
            }
            subscribe(onNext, onThrow, onReturn) {
              return this._subject.subscribe({
                next: onNext,
                error: onThrow,
                complete: onReturn
              });
            }
          }
          return (
            (Location.ɵfac = function(t) {
              return new (t || Location)(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(LocationStrategy),
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(PlatformLocation)
              );
            }),
            (Location.normalizeQueryParams = normalizeQueryParams),
            (Location.joinWithSlash = joinWithSlash),
            (Location.stripTrailingSlash = stripTrailingSlash),
            (Location.ɵprov = Object(
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb
            )({
              factory: createLocation,
              token: Location,
              providedIn: 'root'
            })),
            Location
          );
        })();
      function createLocation() {
        return new Location(
          Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb)(
            LocationStrategy
          ),
          Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb)(
            PlatformLocation
          )
        );
      }
      function _stripIndexHtml(url) {
        return url.replace(/\/index.html$/, '');
      }
      var Plural = (function(Plural) {
          return (
            (Plural[(Plural.Zero = 0)] = 'Zero'),
            (Plural[(Plural.One = 1)] = 'One'),
            (Plural[(Plural.Two = 2)] = 'Two'),
            (Plural[(Plural.Few = 3)] = 'Few'),
            (Plural[(Plural.Many = 4)] = 'Many'),
            (Plural[(Plural.Other = 5)] = 'Other'),
            Plural
          );
        })({}),
        FormStyle = (function(FormStyle) {
          return (
            (FormStyle[(FormStyle.Format = 0)] = 'Format'),
            (FormStyle[(FormStyle.Standalone = 1)] = 'Standalone'),
            FormStyle
          );
        })({}),
        TranslationWidth = (function(TranslationWidth) {
          return (
            (TranslationWidth[(TranslationWidth.Narrow = 0)] = 'Narrow'),
            (TranslationWidth[(TranslationWidth.Abbreviated = 1)] =
              'Abbreviated'),
            (TranslationWidth[(TranslationWidth.Wide = 2)] = 'Wide'),
            (TranslationWidth[(TranslationWidth.Short = 3)] = 'Short'),
            TranslationWidth
          );
        })({}),
        FormatWidth = (function(FormatWidth) {
          return (
            (FormatWidth[(FormatWidth.Short = 0)] = 'Short'),
            (FormatWidth[(FormatWidth.Medium = 1)] = 'Medium'),
            (FormatWidth[(FormatWidth.Long = 2)] = 'Long'),
            (FormatWidth[(FormatWidth.Full = 3)] = 'Full'),
            FormatWidth
          );
        })({}),
        NumberSymbol = (function(NumberSymbol) {
          return (
            (NumberSymbol[(NumberSymbol.Decimal = 0)] = 'Decimal'),
            (NumberSymbol[(NumberSymbol.Group = 1)] = 'Group'),
            (NumberSymbol[(NumberSymbol.List = 2)] = 'List'),
            (NumberSymbol[(NumberSymbol.PercentSign = 3)] = 'PercentSign'),
            (NumberSymbol[(NumberSymbol.PlusSign = 4)] = 'PlusSign'),
            (NumberSymbol[(NumberSymbol.MinusSign = 5)] = 'MinusSign'),
            (NumberSymbol[(NumberSymbol.Exponential = 6)] = 'Exponential'),
            (NumberSymbol[(NumberSymbol.SuperscriptingExponent = 7)] =
              'SuperscriptingExponent'),
            (NumberSymbol[(NumberSymbol.PerMille = 8)] = 'PerMille'),
            (NumberSymbol[(NumberSymbol[1 / 0] = 9)] = 'Infinity'),
            (NumberSymbol[(NumberSymbol.NaN = 10)] = 'NaN'),
            (NumberSymbol[(NumberSymbol.TimeSeparator = 11)] = 'TimeSeparator'),
            (NumberSymbol[(NumberSymbol.CurrencyDecimal = 12)] =
              'CurrencyDecimal'),
            (NumberSymbol[(NumberSymbol.CurrencyGroup = 13)] = 'CurrencyGroup'),
            NumberSymbol
          );
        })({});
      function getLocaleDayPeriods(locale, formStyle, width) {
        const data = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.hb)(
            locale
          ),
          amPm = getLastDefinedValue(
            [
              data[
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.DayPeriodsFormat
              ],
              data[
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Y
                  .DayPeriodsStandalone
              ]
            ],
            formStyle
          );
        return getLastDefinedValue(amPm, width);
      }
      function getLocaleDayNames(locale, formStyle, width) {
        const data = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.hb)(
            locale
          ),
          days = getLastDefinedValue(
            [
              data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.DaysFormat],
              data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.DaysStandalone]
            ],
            formStyle
          );
        return getLastDefinedValue(days, width);
      }
      function getLocaleMonthNames(locale, formStyle, width) {
        const data = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.hb)(
            locale
          ),
          months = getLastDefinedValue(
            [
              data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.MonthsFormat],
              data[
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.MonthsStandalone
              ]
            ],
            formStyle
          );
        return getLastDefinedValue(months, width);
      }
      function getLocaleDateFormat(locale, width) {
        return getLastDefinedValue(
          Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.hb)(locale)[
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.DateFormat
          ],
          width
        );
      }
      function getLocaleTimeFormat(locale, width) {
        return getLastDefinedValue(
          Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.hb)(locale)[
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.TimeFormat
          ],
          width
        );
      }
      function getLocaleDateTimeFormat(locale, width) {
        return getLastDefinedValue(
          Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.hb)(locale)[
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.DateTimeFormat
          ],
          width
        );
      }
      function getLocaleNumberSymbol(locale, symbol) {
        const data = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.hb)(
            locale
          ),
          res =
            data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.NumberSymbols][
              symbol
            ];
        if (void 0 === res) {
          if (symbol === NumberSymbol.CurrencyDecimal)
            return data[
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.NumberSymbols
            ][NumberSymbol.Decimal];
          if (symbol === NumberSymbol.CurrencyGroup)
            return data[
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.NumberSymbols
            ][NumberSymbol.Group];
        }
        return res;
      }
      const getLocalePluralCase = _angular_core__WEBPACK_IMPORTED_MODULE_0__.kb;
      function checkFullData(data) {
        if (!data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.ExtraData])
          throw new Error(
            `Missing extra locale data for the locale "${
              data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.LocaleId]
            }". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`
          );
      }
      function getLastDefinedValue(data, index) {
        for (let i = index; i > -1; i--) if (void 0 !== data[i]) return data[i];
        throw new Error('Locale data API: locale data undefined');
      }
      function extractTime(time) {
        const [h, m] = time.split(':');
        return { hours: +h, minutes: +m };
      }
      const ISO8601_DATE_REGEX = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/,
        NAMED_FORMATS = {},
        DATE_FORMATS_SPLIT = /((?:[^GyMLwWdEabBhHmsSzZO']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
      var ZoneWidth = (function(ZoneWidth) {
          return (
            (ZoneWidth[(ZoneWidth.Short = 0)] = 'Short'),
            (ZoneWidth[(ZoneWidth.ShortGMT = 1)] = 'ShortGMT'),
            (ZoneWidth[(ZoneWidth.Long = 2)] = 'Long'),
            (ZoneWidth[(ZoneWidth.Extended = 3)] = 'Extended'),
            ZoneWidth
          );
        })({}),
        DateType = (function(DateType) {
          return (
            (DateType[(DateType.FullYear = 0)] = 'FullYear'),
            (DateType[(DateType.Month = 1)] = 'Month'),
            (DateType[(DateType.Date = 2)] = 'Date'),
            (DateType[(DateType.Hours = 3)] = 'Hours'),
            (DateType[(DateType.Minutes = 4)] = 'Minutes'),
            (DateType[(DateType.Seconds = 5)] = 'Seconds'),
            (DateType[(DateType.FractionalSeconds = 6)] = 'FractionalSeconds'),
            (DateType[(DateType.Day = 7)] = 'Day'),
            DateType
          );
        })({}),
        TranslationType = (function(TranslationType) {
          return (
            (TranslationType[(TranslationType.DayPeriods = 0)] = 'DayPeriods'),
            (TranslationType[(TranslationType.Days = 1)] = 'Days'),
            (TranslationType[(TranslationType.Months = 2)] = 'Months'),
            (TranslationType[(TranslationType.Eras = 3)] = 'Eras'),
            TranslationType
          );
        })({});
      function formatDate(value, format, locale, timezone) {
        let date = (function(value) {
          if (isDate(value)) return value;
          if ('number' == typeof value && !isNaN(value)) return new Date(value);
          if ('string' == typeof value) {
            value = value.trim();
            const parsedNb = parseFloat(value);
            if (!isNaN(value - parsedNb)) return new Date(parsedNb);
            if (/^(\d{4}-\d{1,2}-\d{1,2})$/.test(value)) {
              const [y, m, d] = value.split('-').map(val => +val);
              return new Date(y, m - 1, d);
            }
            let match;
            if ((match = value.match(ISO8601_DATE_REGEX)))
              return (function(match) {
                const date = new Date(0);
                let tzHour = 0,
                  tzMin = 0;
                const dateSetter = match[8]
                    ? date.setUTCFullYear
                    : date.setFullYear,
                  timeSetter = match[8] ? date.setUTCHours : date.setHours;
                match[9] &&
                  ((tzHour = Number(match[9] + match[10])),
                  (tzMin = Number(match[9] + match[11]))),
                  dateSetter.call(
                    date,
                    Number(match[1]),
                    Number(match[2]) - 1,
                    Number(match[3])
                  );
                const h = Number(match[4] || 0) - tzHour,
                  m = Number(match[5] || 0) - tzMin,
                  s = Number(match[6] || 0),
                  ms = Math.round(1e3 * parseFloat('0.' + (match[7] || 0)));
                return timeSetter.call(date, h, m, s, ms), date;
              })(match);
          }
          const date = new Date(value);
          if (!isDate(date))
            throw new Error(`Unable to convert "${value}" into a date`);
          return date;
        })(value);
        format =
          (function getNamedFormat(locale, format) {
            const localeId = (function(locale) {
              return Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.hb)(
                locale
              )[_angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.LocaleId];
            })(locale);
            if (
              ((NAMED_FORMATS[localeId] = NAMED_FORMATS[localeId] || {}),
              NAMED_FORMATS[localeId][format])
            )
              return NAMED_FORMATS[localeId][format];
            let formatValue = '';
            switch (format) {
              case 'shortDate':
                formatValue = getLocaleDateFormat(locale, FormatWidth.Short);
                break;
              case 'mediumDate':
                formatValue = getLocaleDateFormat(locale, FormatWidth.Medium);
                break;
              case 'longDate':
                formatValue = getLocaleDateFormat(locale, FormatWidth.Long);
                break;
              case 'fullDate':
                formatValue = getLocaleDateFormat(locale, FormatWidth.Full);
                break;
              case 'shortTime':
                formatValue = getLocaleTimeFormat(locale, FormatWidth.Short);
                break;
              case 'mediumTime':
                formatValue = getLocaleTimeFormat(locale, FormatWidth.Medium);
                break;
              case 'longTime':
                formatValue = getLocaleTimeFormat(locale, FormatWidth.Long);
                break;
              case 'fullTime':
                formatValue = getLocaleTimeFormat(locale, FormatWidth.Full);
                break;
              case 'short':
                const shortTime = getNamedFormat(locale, 'shortTime'),
                  shortDate = getNamedFormat(locale, 'shortDate');
                formatValue = formatDateTime(
                  getLocaleDateTimeFormat(locale, FormatWidth.Short),
                  [shortTime, shortDate]
                );
                break;
              case 'medium':
                const mediumTime = getNamedFormat(locale, 'mediumTime'),
                  mediumDate = getNamedFormat(locale, 'mediumDate');
                formatValue = formatDateTime(
                  getLocaleDateTimeFormat(locale, FormatWidth.Medium),
                  [mediumTime, mediumDate]
                );
                break;
              case 'long':
                const longTime = getNamedFormat(locale, 'longTime'),
                  longDate = getNamedFormat(locale, 'longDate');
                formatValue = formatDateTime(
                  getLocaleDateTimeFormat(locale, FormatWidth.Long),
                  [longTime, longDate]
                );
                break;
              case 'full':
                const fullTime = getNamedFormat(locale, 'fullTime'),
                  fullDate = getNamedFormat(locale, 'fullDate');
                formatValue = formatDateTime(
                  getLocaleDateTimeFormat(locale, FormatWidth.Full),
                  [fullTime, fullDate]
                );
            }
            return (
              formatValue && (NAMED_FORMATS[localeId][format] = formatValue),
              formatValue
            );
          })(locale, format) || format;
        let match,
          parts = [];
        for (; format; ) {
          if (((match = DATE_FORMATS_SPLIT.exec(format)), !match)) {
            parts.push(format);
            break;
          }
          {
            parts = parts.concat(match.slice(1));
            const part = parts.pop();
            if (!part) break;
            format = part;
          }
        }
        let dateTimezoneOffset = date.getTimezoneOffset();
        timezone &&
          ((dateTimezoneOffset = timezoneToOffset(
            timezone,
            dateTimezoneOffset
          )),
          (date = (function(date, timezone, reverse) {
            const dateTimezoneOffset = date.getTimezoneOffset();
            return (function(date, minutes) {
              return (
                (date = new Date(date.getTime())).setMinutes(
                  date.getMinutes() + minutes
                ),
                date
              );
            })(
              date,
              -1 *
                (timezoneToOffset(timezone, dateTimezoneOffset) -
                  dateTimezoneOffset)
            );
          })(date, timezone)));
        let text = '';
        return (
          parts.forEach(value => {
            const dateFormatter = (function(format) {
              if (DATE_FORMATS[format]) return DATE_FORMATS[format];
              let formatter;
              switch (format) {
                case 'G':
                case 'GG':
                case 'GGG':
                  formatter = dateStrGetter(
                    TranslationType.Eras,
                    TranslationWidth.Abbreviated
                  );
                  break;
                case 'GGGG':
                  formatter = dateStrGetter(
                    TranslationType.Eras,
                    TranslationWidth.Wide
                  );
                  break;
                case 'GGGGG':
                  formatter = dateStrGetter(
                    TranslationType.Eras,
                    TranslationWidth.Narrow
                  );
                  break;
                case 'y':
                  formatter = dateGetter(DateType.FullYear, 1, 0, !1, !0);
                  break;
                case 'yy':
                  formatter = dateGetter(DateType.FullYear, 2, 0, !0, !0);
                  break;
                case 'yyy':
                  formatter = dateGetter(DateType.FullYear, 3, 0, !1, !0);
                  break;
                case 'yyyy':
                  formatter = dateGetter(DateType.FullYear, 4, 0, !1, !0);
                  break;
                case 'M':
                case 'L':
                  formatter = dateGetter(DateType.Month, 1, 1);
                  break;
                case 'MM':
                case 'LL':
                  formatter = dateGetter(DateType.Month, 2, 1);
                  break;
                case 'MMM':
                  formatter = dateStrGetter(
                    TranslationType.Months,
                    TranslationWidth.Abbreviated
                  );
                  break;
                case 'MMMM':
                  formatter = dateStrGetter(
                    TranslationType.Months,
                    TranslationWidth.Wide
                  );
                  break;
                case 'MMMMM':
                  formatter = dateStrGetter(
                    TranslationType.Months,
                    TranslationWidth.Narrow
                  );
                  break;
                case 'LLL':
                  formatter = dateStrGetter(
                    TranslationType.Months,
                    TranslationWidth.Abbreviated,
                    FormStyle.Standalone
                  );
                  break;
                case 'LLLL':
                  formatter = dateStrGetter(
                    TranslationType.Months,
                    TranslationWidth.Wide,
                    FormStyle.Standalone
                  );
                  break;
                case 'LLLLL':
                  formatter = dateStrGetter(
                    TranslationType.Months,
                    TranslationWidth.Narrow,
                    FormStyle.Standalone
                  );
                  break;
                case 'w':
                  formatter = weekGetter(1);
                  break;
                case 'ww':
                  formatter = weekGetter(2);
                  break;
                case 'W':
                  formatter = weekGetter(1, !0);
                  break;
                case 'd':
                  formatter = dateGetter(DateType.Date, 1);
                  break;
                case 'dd':
                  formatter = dateGetter(DateType.Date, 2);
                  break;
                case 'E':
                case 'EE':
                case 'EEE':
                  formatter = dateStrGetter(
                    TranslationType.Days,
                    TranslationWidth.Abbreviated
                  );
                  break;
                case 'EEEE':
                  formatter = dateStrGetter(
                    TranslationType.Days,
                    TranslationWidth.Wide
                  );
                  break;
                case 'EEEEE':
                  formatter = dateStrGetter(
                    TranslationType.Days,
                    TranslationWidth.Narrow
                  );
                  break;
                case 'EEEEEE':
                  formatter = dateStrGetter(
                    TranslationType.Days,
                    TranslationWidth.Short
                  );
                  break;
                case 'a':
                case 'aa':
                case 'aaa':
                  formatter = dateStrGetter(
                    TranslationType.DayPeriods,
                    TranslationWidth.Abbreviated
                  );
                  break;
                case 'aaaa':
                  formatter = dateStrGetter(
                    TranslationType.DayPeriods,
                    TranslationWidth.Wide
                  );
                  break;
                case 'aaaaa':
                  formatter = dateStrGetter(
                    TranslationType.DayPeriods,
                    TranslationWidth.Narrow
                  );
                  break;
                case 'b':
                case 'bb':
                case 'bbb':
                  formatter = dateStrGetter(
                    TranslationType.DayPeriods,
                    TranslationWidth.Abbreviated,
                    FormStyle.Standalone,
                    !0
                  );
                  break;
                case 'bbbb':
                  formatter = dateStrGetter(
                    TranslationType.DayPeriods,
                    TranslationWidth.Wide,
                    FormStyle.Standalone,
                    !0
                  );
                  break;
                case 'bbbbb':
                  formatter = dateStrGetter(
                    TranslationType.DayPeriods,
                    TranslationWidth.Narrow,
                    FormStyle.Standalone,
                    !0
                  );
                  break;
                case 'B':
                case 'BB':
                case 'BBB':
                  formatter = dateStrGetter(
                    TranslationType.DayPeriods,
                    TranslationWidth.Abbreviated,
                    FormStyle.Format,
                    !0
                  );
                  break;
                case 'BBBB':
                  formatter = dateStrGetter(
                    TranslationType.DayPeriods,
                    TranslationWidth.Wide,
                    FormStyle.Format,
                    !0
                  );
                  break;
                case 'BBBBB':
                  formatter = dateStrGetter(
                    TranslationType.DayPeriods,
                    TranslationWidth.Narrow,
                    FormStyle.Format,
                    !0
                  );
                  break;
                case 'h':
                  formatter = dateGetter(DateType.Hours, 1, -12);
                  break;
                case 'hh':
                  formatter = dateGetter(DateType.Hours, 2, -12);
                  break;
                case 'H':
                  formatter = dateGetter(DateType.Hours, 1);
                  break;
                case 'HH':
                  formatter = dateGetter(DateType.Hours, 2);
                  break;
                case 'm':
                  formatter = dateGetter(DateType.Minutes, 1);
                  break;
                case 'mm':
                  formatter = dateGetter(DateType.Minutes, 2);
                  break;
                case 's':
                  formatter = dateGetter(DateType.Seconds, 1);
                  break;
                case 'ss':
                  formatter = dateGetter(DateType.Seconds, 2);
                  break;
                case 'S':
                  formatter = dateGetter(DateType.FractionalSeconds, 1);
                  break;
                case 'SS':
                  formatter = dateGetter(DateType.FractionalSeconds, 2);
                  break;
                case 'SSS':
                  formatter = dateGetter(DateType.FractionalSeconds, 3);
                  break;
                case 'Z':
                case 'ZZ':
                case 'ZZZ':
                  formatter = timeZoneGetter(ZoneWidth.Short);
                  break;
                case 'ZZZZZ':
                  formatter = timeZoneGetter(ZoneWidth.Extended);
                  break;
                case 'O':
                case 'OO':
                case 'OOO':
                case 'z':
                case 'zz':
                case 'zzz':
                  formatter = timeZoneGetter(ZoneWidth.ShortGMT);
                  break;
                case 'OOOO':
                case 'ZZZZ':
                case 'zzzz':
                  formatter = timeZoneGetter(ZoneWidth.Long);
                  break;
                default:
                  return null;
              }
              return (DATE_FORMATS[format] = formatter), formatter;
            })(value);
            text += dateFormatter
              ? dateFormatter(date, locale, dateTimezoneOffset)
              : "''" === value
              ? "'"
              : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          }),
          text
        );
      }
      function formatDateTime(str, opt_values) {
        return (
          opt_values &&
            (str = str.replace(/\{([^}]+)}/g, function(match, key) {
              return null != opt_values && key in opt_values
                ? opt_values[key]
                : match;
            })),
          str
        );
      }
      function padNumber(num, digits, minusSign = '-', trim, negWrap) {
        let neg = '';
        (num < 0 || (negWrap && num <= 0)) &&
          (negWrap ? (num = 1 - num) : ((num = -num), (neg = minusSign)));
        let strNum = String(num);
        for (; strNum.length < digits; ) strNum = '0' + strNum;
        return (
          trim && (strNum = strNum.substr(strNum.length - digits)), neg + strNum
        );
      }
      function dateGetter(name, size, offset = 0, trim = !1, negWrap = !1) {
        return function(date, locale) {
          let part = (function(part, date) {
            switch (part) {
              case DateType.FullYear:
                return date.getFullYear();
              case DateType.Month:
                return date.getMonth();
              case DateType.Date:
                return date.getDate();
              case DateType.Hours:
                return date.getHours();
              case DateType.Minutes:
                return date.getMinutes();
              case DateType.Seconds:
                return date.getSeconds();
              case DateType.FractionalSeconds:
                return date.getMilliseconds();
              case DateType.Day:
                return date.getDay();
              default:
                throw new Error(`Unknown DateType value "${part}".`);
            }
          })(name, date);
          if (
            ((offset > 0 || part > -offset) && (part += offset),
            name === DateType.Hours)
          )
            0 === part && -12 === offset && (part = 12);
          else if (name === DateType.FractionalSeconds)
            return (digits = size), padNumber(part, 3).substr(0, digits);
          var digits;
          const localeMinus = getLocaleNumberSymbol(
            locale,
            NumberSymbol.MinusSign
          );
          return padNumber(part, size, localeMinus, trim, negWrap);
        };
      }
      function dateStrGetter(
        name,
        width,
        form = FormStyle.Format,
        extended = !1
      ) {
        return function(date, locale) {
          return (function(date, locale, name, width, form, extended) {
            switch (name) {
              case TranslationType.Months:
                return getLocaleMonthNames(locale, form, width)[
                  date.getMonth()
                ];
              case TranslationType.Days:
                return getLocaleDayNames(locale, form, width)[date.getDay()];
              case TranslationType.DayPeriods:
                const currentHours = date.getHours(),
                  currentMinutes = date.getMinutes();
                if (extended) {
                  const rules = (function(locale) {
                      const data = Object(
                        _angular_core__WEBPACK_IMPORTED_MODULE_0__.hb
                      )(locale);
                      return (
                        checkFullData(data),
                        (
                          data[
                            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Y
                              .ExtraData
                          ][2] || []
                        ).map(rule =>
                          'string' == typeof rule
                            ? extractTime(rule)
                            : [extractTime(rule[0]), extractTime(rule[1])]
                        )
                      );
                    })(locale),
                    dayPeriods = (function(locale, formStyle, width) {
                      const data = Object(
                        _angular_core__WEBPACK_IMPORTED_MODULE_0__.hb
                      )(locale);
                      checkFullData(data);
                      const dayPeriods =
                        getLastDefinedValue(
                          [
                            data[
                              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Y
                                .ExtraData
                            ][0],
                            data[
                              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Y
                                .ExtraData
                            ][1]
                          ],
                          formStyle
                        ) || [];
                      return getLastDefinedValue(dayPeriods, width) || [];
                    })(locale, form, width),
                    index = rules.findIndex(rule => {
                      if (Array.isArray(rule)) {
                        const [from, to] = rule,
                          afterFrom =
                            currentHours >= from.hours &&
                            currentMinutes >= from.minutes,
                          beforeTo =
                            currentHours < to.hours ||
                            (currentHours === to.hours &&
                              currentMinutes < to.minutes);
                        if (from.hours < to.hours) {
                          if (afterFrom && beforeTo) return !0;
                        } else if (afterFrom || beforeTo) return !0;
                      } else if (
                        rule.hours === currentHours &&
                        rule.minutes === currentMinutes
                      )
                        return !0;
                      return !1;
                    });
                  if (-1 !== index) return dayPeriods[index];
                }
                return getLocaleDayPeriods(locale, form, width)[
                  currentHours < 12 ? 0 : 1
                ];
              case TranslationType.Eras:
                return (function(locale, width) {
                  return getLastDefinedValue(
                    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.hb)(
                      locale
                    )[_angular_core__WEBPACK_IMPORTED_MODULE_0__.Y.Eras],
                    width
                  );
                })(locale, width)[date.getFullYear() <= 0 ? 0 : 1];
              default:
                throw new Error('unexpected translation type ' + name);
            }
          })(date, locale, name, width, form, extended);
        };
      }
      function timeZoneGetter(width) {
        return function(date, locale, offset) {
          const zone = -1 * offset,
            minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign),
            hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
          switch (width) {
            case ZoneWidth.Short:
              return (
                (zone >= 0 ? '+' : '') +
                padNumber(hours, 2, minusSign) +
                padNumber(Math.abs(zone % 60), 2, minusSign)
              );
            case ZoneWidth.ShortGMT:
              return (
                'GMT' + (zone >= 0 ? '+' : '') + padNumber(hours, 1, minusSign)
              );
            case ZoneWidth.Long:
              return (
                'GMT' +
                (zone >= 0 ? '+' : '') +
                padNumber(hours, 2, minusSign) +
                ':' +
                padNumber(Math.abs(zone % 60), 2, minusSign)
              );
            case ZoneWidth.Extended:
              return 0 === offset
                ? 'Z'
                : (zone >= 0 ? '+' : '') +
                    padNumber(hours, 2, minusSign) +
                    ':' +
                    padNumber(Math.abs(zone % 60), 2, minusSign);
            default:
              throw new Error(`Unknown zone width "${width}"`);
          }
        };
      }
      function weekGetter(size, monthBased = !1) {
        return function(date, locale) {
          let result;
          if (monthBased) {
            const nbDaysBefore1stDayOfMonth =
                new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1,
              today = date.getDate();
            result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
          } else {
            const firstThurs = (function(year) {
                const firstDayOfYear = new Date(year, 0, 1).getDay();
                return new Date(
                  year,
                  0,
                  1 + (firstDayOfYear <= 4 ? 4 : 11) - firstDayOfYear
                );
              })(date.getFullYear()),
              diff =
                ((datetime = date),
                new Date(
                  datetime.getFullYear(),
                  datetime.getMonth(),
                  datetime.getDate() + (4 - datetime.getDay())
                )).getTime() - firstThurs.getTime();
            result = 1 + Math.round(diff / 6048e5);
          }
          var datetime;
          return padNumber(
            result,
            size,
            getLocaleNumberSymbol(locale, NumberSymbol.MinusSign)
          );
        };
      }
      const DATE_FORMATS = {};
      function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(/:/g, '');
        const requestedTimezoneOffset =
          Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 6e4;
        return isNaN(requestedTimezoneOffset)
          ? fallback
          : requestedTimezoneOffset;
      }
      function isDate(value) {
        return value instanceof Date && !isNaN(value.valueOf());
      }
      class NgLocalization {}
      let NgLocaleLocalization = (() => {
        class NgLocaleLocalization extends NgLocalization {
          constructor(locale) {
            super(), (this.locale = locale);
          }
          getPluralCategory(value, locale) {
            switch (getLocalePluralCase(locale || this.locale)(value)) {
              case Plural.Zero:
                return 'zero';
              case Plural.One:
                return 'one';
              case Plural.Two:
                return 'two';
              case Plural.Few:
                return 'few';
              case Plural.Many:
                return 'many';
              default:
                return 'other';
            }
          }
        }
        return (
          (NgLocaleLocalization.ɵfac = function(t) {
            return new (t || NgLocaleLocalization)(
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.u
              )
            );
          }),
          (NgLocaleLocalization.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb(
            { token: NgLocaleLocalization, factory: NgLocaleLocalization.ɵfac }
          )),
          NgLocaleLocalization
        );
      })();
      function parseCookieValue(cookieStr, name) {
        name = encodeURIComponent(name);
        for (const cookie of cookieStr.split(';')) {
          const eqIndex = cookie.indexOf('='),
            [cookieName, cookieValue] =
              -1 == eqIndex
                ? [cookie, '']
                : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
          if (cookieName.trim() === name)
            return decodeURIComponent(cookieValue);
        }
        return null;
      }
      let NgClass = (() => {
        class NgClass {
          constructor(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
            (this._iterableDiffers = _iterableDiffers),
              (this._keyValueDiffers = _keyValueDiffers),
              (this._ngEl = _ngEl),
              (this._renderer = _renderer),
              (this._iterableDiffer = null),
              (this._keyValueDiffer = null),
              (this._initialClasses = []),
              (this._rawClass = null);
          }
          set klass(value) {
            this._removeClasses(this._initialClasses),
              (this._initialClasses =
                'string' == typeof value ? value.split(/\s+/) : []),
              this._applyClasses(this._initialClasses),
              this._applyClasses(this._rawClass);
          }
          set ngClass(value) {
            this._removeClasses(this._rawClass),
              this._applyClasses(this._initialClasses),
              (this._iterableDiffer = null),
              (this._keyValueDiffer = null),
              (this._rawClass =
                'string' == typeof value ? value.split(/\s+/) : value),
              this._rawClass &&
                (Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.nb)(
                  this._rawClass
                )
                  ? (this._iterableDiffer = this._iterableDiffers
                      .find(this._rawClass)
                      .create())
                  : (this._keyValueDiffer = this._keyValueDiffers
                      .find(this._rawClass)
                      .create()));
          }
          ngDoCheck() {
            if (this._iterableDiffer) {
              const iterableChanges = this._iterableDiffer.diff(this._rawClass);
              iterableChanges && this._applyIterableChanges(iterableChanges);
            } else if (this._keyValueDiffer) {
              const keyValueChanges = this._keyValueDiffer.diff(this._rawClass);
              keyValueChanges && this._applyKeyValueChanges(keyValueChanges);
            }
          }
          _applyKeyValueChanges(changes) {
            changes.forEachAddedItem(record =>
              this._toggleClass(record.key, record.currentValue)
            ),
              changes.forEachChangedItem(record =>
                this._toggleClass(record.key, record.currentValue)
              ),
              changes.forEachRemovedItem(record => {
                record.previousValue && this._toggleClass(record.key, !1);
              });
          }
          _applyIterableChanges(changes) {
            changes.forEachAddedItem(record => {
              if ('string' != typeof record.item)
                throw new Error(
                  'NgClass can only toggle CSS classes expressed as strings, got ' +
                    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.sb)(
                      record.item
                    )
                );
              this._toggleClass(record.item, !0);
            }),
              changes.forEachRemovedItem(record =>
                this._toggleClass(record.item, !1)
              );
          }
          _applyClasses(rawClassVal) {
            rawClassVal &&
              (Array.isArray(rawClassVal) || rawClassVal instanceof Set
                ? rawClassVal.forEach(klass => this._toggleClass(klass, !0))
                : Object.keys(rawClassVal).forEach(klass =>
                    this._toggleClass(klass, !!rawClassVal[klass])
                  ));
          }
          _removeClasses(rawClassVal) {
            rawClassVal &&
              (Array.isArray(rawClassVal) || rawClassVal instanceof Set
                ? rawClassVal.forEach(klass => this._toggleClass(klass, !1))
                : Object.keys(rawClassVal).forEach(klass =>
                    this._toggleClass(klass, !1)
                  ));
          }
          _toggleClass(klass, enabled) {
            (klass = klass.trim()) &&
              klass.split(/\s+/g).forEach(klass => {
                enabled
                  ? this._renderer.addClass(this._ngEl.nativeElement, klass)
                  : this._renderer.removeClass(this._ngEl.nativeElement, klass);
              });
          }
        }
        return (
          (NgClass.ɵfac = function(t) {
            return new (t || NgClass)(
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.s
              ),
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.t
              ),
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.l
              ),
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.D
              )
            );
          }),
          (NgClass.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Gb({
            type: NgClass,
            selectors: [['', 'ngClass', '']],
            inputs: { klass: ['class', 'klass'], ngClass: 'ngClass' }
          })),
          NgClass
        );
      })();
      class NgForOfContext {
        constructor($implicit, ngForOf, index, count) {
          (this.$implicit = $implicit),
            (this.ngForOf = ngForOf),
            (this.index = index),
            (this.count = count);
        }
        get first() {
          return 0 === this.index;
        }
        get last() {
          return this.index === this.count - 1;
        }
        get even() {
          return this.index % 2 == 0;
        }
        get odd() {
          return !this.even;
        }
      }
      let NgForOf = (() => {
        class NgForOf {
          constructor(_viewContainer, _template, _differs) {
            (this._viewContainer = _viewContainer),
              (this._template = _template),
              (this._differs = _differs),
              (this._ngForOf = null),
              (this._ngForOfDirty = !0),
              (this._differ = null);
          }
          set ngForOf(ngForOf) {
            (this._ngForOf = ngForOf), (this._ngForOfDirty = !0);
          }
          set ngForTrackBy(fn) {
            Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.T)() &&
              null != fn &&
              'function' != typeof fn &&
              console &&
              console.warn &&
              console.warn(
                `trackBy must be a function, but received ${JSON.stringify(
                  fn
                )}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`
              ),
              (this._trackByFn = fn);
          }
          get ngForTrackBy() {
            return this._trackByFn;
          }
          set ngForTemplate(value) {
            value && (this._template = value);
          }
          ngDoCheck() {
            if (this._ngForOfDirty) {
              this._ngForOfDirty = !1;
              const value = this._ngForOf;
              if (!this._differ && value)
                try {
                  this._differ = this._differs
                    .find(value)
                    .create(this.ngForTrackBy);
                } catch (_a) {
                  throw new Error(
                    `Cannot find a differ supporting object '${value}' of type '${((type = value),
                    type.name ||
                      typeof type)}'. NgFor only supports binding to Iterables such as Arrays.`
                  );
                }
            }
            var type;
            if (this._differ) {
              const changes = this._differ.diff(this._ngForOf);
              changes && this._applyChanges(changes);
            }
          }
          _applyChanges(changes) {
            const insertTuples = [];
            changes.forEachOperation(
              (item, adjustedPreviousIndex, currentIndex) => {
                if (null == item.previousIndex) {
                  const view = this._viewContainer.createEmbeddedView(
                      this._template,
                      new NgForOfContext(null, this._ngForOf, -1, -1),
                      null === currentIndex ? void 0 : currentIndex
                    ),
                    tuple = new RecordViewTuple(item, view);
                  insertTuples.push(tuple);
                } else if (null == currentIndex)
                  this._viewContainer.remove(
                    null === adjustedPreviousIndex
                      ? void 0
                      : adjustedPreviousIndex
                  );
                else if (null !== adjustedPreviousIndex) {
                  const view = this._viewContainer.get(adjustedPreviousIndex);
                  this._viewContainer.move(view, currentIndex);
                  const tuple = new RecordViewTuple(item, view);
                  insertTuples.push(tuple);
                }
              }
            );
            for (let i = 0; i < insertTuples.length; i++)
              this._perViewChange(insertTuples[i].view, insertTuples[i].record);
            for (let i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
              const viewRef = this._viewContainer.get(i);
              (viewRef.context.index = i),
                (viewRef.context.count = ilen),
                (viewRef.context.ngForOf = this._ngForOf);
            }
            changes.forEachIdentityChange(record => {
              this._viewContainer.get(record.currentIndex).context.$implicit =
                record.item;
            });
          }
          _perViewChange(view, record) {
            view.context.$implicit = record.item;
          }
          static ngTemplateContextGuard(dir, ctx) {
            return !0;
          }
        }
        return (
          (NgForOf.ɵfac = function(t) {
            return new (t || NgForOf)(
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.O
              ),
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.K
              ),
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.s
              )
            );
          }),
          (NgForOf.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Gb({
            type: NgForOf,
            selectors: [['', 'ngFor', '', 'ngForOf', '']],
            inputs: {
              ngForOf: 'ngForOf',
              ngForTrackBy: 'ngForTrackBy',
              ngForTemplate: 'ngForTemplate'
            }
          })),
          NgForOf
        );
      })();
      class RecordViewTuple {
        constructor(record, view) {
          (this.record = record), (this.view = view);
        }
      }
      let NgIf = (() => {
        class NgIf {
          constructor(_viewContainer, templateRef) {
            (this._viewContainer = _viewContainer),
              (this._context = new NgIfContext()),
              (this._thenTemplateRef = null),
              (this._elseTemplateRef = null),
              (this._thenViewRef = null),
              (this._elseViewRef = null),
              (this._thenTemplateRef = templateRef);
          }
          set ngIf(condition) {
            (this._context.$implicit = this._context.ngIf = condition),
              this._updateView();
          }
          set ngIfThen(templateRef) {
            assertTemplate('ngIfThen', templateRef),
              (this._thenTemplateRef = templateRef),
              (this._thenViewRef = null),
              this._updateView();
          }
          set ngIfElse(templateRef) {
            assertTemplate('ngIfElse', templateRef),
              (this._elseTemplateRef = templateRef),
              (this._elseViewRef = null),
              this._updateView();
          }
          _updateView() {
            this._context.$implicit
              ? this._thenViewRef ||
                (this._viewContainer.clear(),
                (this._elseViewRef = null),
                this._thenTemplateRef &&
                  (this._thenViewRef = this._viewContainer.createEmbeddedView(
                    this._thenTemplateRef,
                    this._context
                  )))
              : this._elseViewRef ||
                (this._viewContainer.clear(),
                (this._thenViewRef = null),
                this._elseTemplateRef &&
                  (this._elseViewRef = this._viewContainer.createEmbeddedView(
                    this._elseTemplateRef,
                    this._context
                  )));
          }
          static ngTemplateContextGuard(dir, ctx) {
            return !0;
          }
        }
        return (
          (NgIf.ɵfac = function(t) {
            return new (t || NgIf)(
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.O
              ),
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.K
              )
            );
          }),
          (NgIf.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Gb({
            type: NgIf,
            selectors: [['', 'ngIf', '']],
            inputs: { ngIf: 'ngIf', ngIfThen: 'ngIfThen', ngIfElse: 'ngIfElse' }
          })),
          NgIf
        );
      })();
      class NgIfContext {
        constructor() {
          (this.$implicit = null), (this.ngIf = null);
        }
      }
      function assertTemplate(property, templateRef) {
        if (templateRef && !templateRef.createEmbeddedView)
          throw new Error(
            `${property} must be a TemplateRef, but received '${Object(
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.sb
            )(templateRef)}'.`
          );
      }
      let NgStyle = (() => {
          class NgStyle {
            constructor(_ngEl, _differs, _renderer) {
              (this._ngEl = _ngEl),
                (this._differs = _differs),
                (this._renderer = _renderer),
                (this._ngStyle = null),
                (this._differ = null);
            }
            set ngStyle(values) {
              (this._ngStyle = values),
                !this._differ &&
                  values &&
                  (this._differ = this._differs.find(values).create());
            }
            ngDoCheck() {
              if (this._differ) {
                const changes = this._differ.diff(this._ngStyle);
                changes && this._applyChanges(changes);
              }
            }
            _setStyle(nameAndUnit, value) {
              const [name, unit] = nameAndUnit.split('.');
              null !=
              (value = null != value && unit ? `${value}${unit}` : value)
                ? this._renderer.setStyle(this._ngEl.nativeElement, name, value)
                : this._renderer.removeStyle(this._ngEl.nativeElement, name);
            }
            _applyChanges(changes) {
              changes.forEachRemovedItem(record =>
                this._setStyle(record.key, null)
              ),
                changes.forEachAddedItem(record =>
                  this._setStyle(record.key, record.currentValue)
                ),
                changes.forEachChangedItem(record =>
                  this._setStyle(record.key, record.currentValue)
                );
            }
          }
          return (
            (NgStyle.ɵfac = function(t) {
              return new (t || NgStyle)(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                  _angular_core__WEBPACK_IMPORTED_MODULE_0__.l
                ),
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                  _angular_core__WEBPACK_IMPORTED_MODULE_0__.t
                ),
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                  _angular_core__WEBPACK_IMPORTED_MODULE_0__.D
                )
              );
            }),
            (NgStyle.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Gb({
              type: NgStyle,
              selectors: [['', 'ngStyle', '']],
              inputs: { ngStyle: 'ngStyle' }
            })),
            NgStyle
          );
        })(),
        NgTemplateOutlet = (() => {
          class NgTemplateOutlet {
            constructor(_viewContainerRef) {
              (this._viewContainerRef = _viewContainerRef),
                (this._viewRef = null),
                (this.ngTemplateOutletContext = null),
                (this.ngTemplateOutlet = null);
            }
            ngOnChanges(changes) {
              if (this._shouldRecreateView(changes)) {
                const viewContainerRef = this._viewContainerRef;
                this._viewRef &&
                  viewContainerRef.remove(
                    viewContainerRef.indexOf(this._viewRef)
                  ),
                  (this._viewRef = this.ngTemplateOutlet
                    ? viewContainerRef.createEmbeddedView(
                        this.ngTemplateOutlet,
                        this.ngTemplateOutletContext
                      )
                    : null);
              } else
                this._viewRef &&
                  this.ngTemplateOutletContext &&
                  this._updateExistingContext(this.ngTemplateOutletContext);
            }
            _shouldRecreateView(changes) {
              const ctxChange = changes.ngTemplateOutletContext;
              return (
                !!changes.ngTemplateOutlet ||
                (ctxChange && this._hasContextShapeChanged(ctxChange))
              );
            }
            _hasContextShapeChanged(ctxChange) {
              const prevCtxKeys = Object.keys(ctxChange.previousValue || {}),
                currCtxKeys = Object.keys(ctxChange.currentValue || {});
              if (prevCtxKeys.length === currCtxKeys.length) {
                for (let propName of currCtxKeys)
                  if (-1 === prevCtxKeys.indexOf(propName)) return !0;
                return !1;
              }
              return !0;
            }
            _updateExistingContext(ctx) {
              for (let propName of Object.keys(ctx))
                this._viewRef.context[propName] = this.ngTemplateOutletContext[
                  propName
                ];
            }
          }
          return (
            (NgTemplateOutlet.ɵfac = function(t) {
              return new (t || NgTemplateOutlet)(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb(
                  _angular_core__WEBPACK_IMPORTED_MODULE_0__.O
                )
              );
            }),
            (NgTemplateOutlet.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Gb(
              {
                type: NgTemplateOutlet,
                selectors: [['', 'ngTemplateOutlet', '']],
                inputs: {
                  ngTemplateOutletContext: 'ngTemplateOutletContext',
                  ngTemplateOutlet: 'ngTemplateOutlet'
                },
                features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb]
              }
            )),
            NgTemplateOutlet
          );
        })(),
        CommonModule = (() => {
          class CommonModule {}
          return (
            (CommonModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb({
              type: CommonModule
            })),
            (CommonModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ib({
              factory: function(t) {
                return new (t || CommonModule)();
              },
              providers: [
                { provide: NgLocalization, useClass: NgLocaleLocalization }
              ]
            })),
            CommonModule
          );
        })();
      const PLATFORM_BROWSER_ID = 'browser';
      function isPlatformBrowser(platformId) {
        return platformId === PLATFORM_BROWSER_ID;
      }
      let ViewportScroller = (() => {
        class ViewportScroller {}
        return (
          (ViewportScroller.ɵprov = Object(
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb
          )({
            token: ViewportScroller,
            providedIn: 'root',
            factory: () =>
              new BrowserViewportScroller(
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb)(DOCUMENT),
                window,
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb)(
                  _angular_core__WEBPACK_IMPORTED_MODULE_0__.m
                )
              )
          })),
          ViewportScroller
        );
      })();
      class BrowserViewportScroller {
        constructor(document, window, errorHandler) {
          (this.document = document),
            (this.window = window),
            (this.errorHandler = errorHandler),
            (this.offset = () => [0, 0]);
        }
        setOffset(offset) {
          this.offset = Array.isArray(offset) ? () => offset : offset;
        }
        getScrollPosition() {
          return this.supportScrollRestoration()
            ? [this.window.scrollX, this.window.scrollY]
            : [0, 0];
        }
        scrollToPosition(position) {
          this.supportScrollRestoration() &&
            this.window.scrollTo(position[0], position[1]);
        }
        scrollToAnchor(anchor) {
          if (this.supportScrollRestoration()) {
            anchor =
              this.window.CSS && this.window.CSS.escape
                ? this.window.CSS.escape(anchor)
                : anchor.replace(/(\"|\'\ |:|\.|\[|\]|,|=)/g, '\\$1');
            try {
              const elSelectedById = this.document.querySelector('#' + anchor);
              if (elSelectedById)
                return void this.scrollToElement(elSelectedById);
              const elSelectedByName = this.document.querySelector(
                `[name='${anchor}']`
              );
              if (elSelectedByName)
                return void this.scrollToElement(elSelectedByName);
            } catch (e) {
              this.errorHandler.handleError(e);
            }
          }
        }
        setHistoryScrollRestoration(scrollRestoration) {
          if (this.supportScrollRestoration()) {
            const history = this.window.history;
            history &&
              history.scrollRestoration &&
              (history.scrollRestoration = scrollRestoration);
          }
        }
        scrollToElement(el) {
          const rect = el.getBoundingClientRect(),
            left = rect.left + this.window.pageXOffset,
            top = rect.top + this.window.pageYOffset,
            offset = this.offset();
          this.window.scrollTo(left - offset[0], top - offset[1]);
        }
        supportScrollRestoration() {
          try {
            return !!this.window && !!this.window.scrollTo;
          } catch (_a) {
            return !1;
          }
        }
      }
    },
    pLZG: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return filter;
      });
      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        '7o/Q'
      );
      function filter(predicate, thisArg) {
        return function(source) {
          return source.lift(new FilterOperator(predicate, thisArg));
        };
      }
      class FilterOperator {
        constructor(predicate, thisArg) {
          (this.predicate = predicate), (this.thisArg = thisArg);
        }
        call(subscriber, source) {
          return source.subscribe(
            new FilterSubscriber(subscriber, this.predicate, this.thisArg)
          );
        }
      }
      class FilterSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(destination, predicate, thisArg) {
          super(destination),
            (this.predicate = predicate),
            (this.thisArg = thisArg),
            (this.count = 0);
        }
        _next(value) {
          let result;
          try {
            result = this.predicate.call(this.thisArg, value, this.count++);
          } catch (err) {
            return void this.destination.error(err);
          }
          result && this.destination.next(value);
        }
      }
    },
    ppGB: function(module, exports) {
      var ceil = Math.ceil,
        floor = Math.floor;
      module.exports = function(argument) {
        return isNaN((argument = +argument))
          ? 0
          : (argument > 0 ? floor : ceil)(argument);
      };
    },
    quSY: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return Subscription_Subscription;
      });
      var isArray = __webpack_require__('DH7j'),
        isObject = __webpack_require__('XoHu'),
        isFunction = __webpack_require__('n6bG');
      const UnsubscriptionError = (() => {
        function UnsubscriptionErrorImpl(errors) {
          return (
            Error.call(this),
            (this.message = errors
              ? `${
                  errors.length
                } errors occurred during unsubscription:\n${errors
                  .map((err, i) => `${i + 1}) ${err.toString()}`)
                  .join('\n  ')}`
              : ''),
            (this.name = 'UnsubscriptionError'),
            (this.errors = errors),
            this
          );
        }
        return (
          (UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype)),
          UnsubscriptionErrorImpl
        );
      })();
      let Subscription_Subscription = (() => {
        class Subscription {
          constructor(unsubscribe) {
            (this.closed = !1),
              (this._parentOrParents = null),
              (this._subscriptions = null),
              unsubscribe && (this._unsubscribe = unsubscribe);
          }
          unsubscribe() {
            let errors;
            if (this.closed) return;
            let {
              _parentOrParents: _parentOrParents,
              _unsubscribe: _unsubscribe,
              _subscriptions: _subscriptions
            } = this;
            if (
              ((this.closed = !0),
              (this._parentOrParents = null),
              (this._subscriptions = null),
              _parentOrParents instanceof Subscription)
            )
              _parentOrParents.remove(this);
            else if (null !== _parentOrParents)
              for (let index = 0; index < _parentOrParents.length; ++index)
                _parentOrParents[index].remove(this);
            if (Object(isFunction.a)(_unsubscribe))
              try {
                _unsubscribe.call(this);
              } catch (e) {
                errors =
                  e instanceof UnsubscriptionError
                    ? flattenUnsubscriptionErrors(e.errors)
                    : [e];
              }
            if (Object(isArray.a)(_subscriptions)) {
              let index = -1,
                len = _subscriptions.length;
              for (; ++index < len; ) {
                const sub = _subscriptions[index];
                if (Object(isObject.a)(sub))
                  try {
                    sub.unsubscribe();
                  } catch (e) {
                    (errors = errors || []),
                      e instanceof UnsubscriptionError
                        ? (errors = errors.concat(
                            flattenUnsubscriptionErrors(e.errors)
                          ))
                        : errors.push(e);
                  }
              }
            }
            if (errors) throw new UnsubscriptionError(errors);
          }
          add(teardown) {
            let subscription = teardown;
            if (!teardown) return Subscription.EMPTY;
            switch (typeof teardown) {
              case 'function':
                subscription = new Subscription(teardown);
              case 'object':
                if (
                  subscription === this ||
                  subscription.closed ||
                  'function' != typeof subscription.unsubscribe
                )
                  return subscription;
                if (this.closed)
                  return subscription.unsubscribe(), subscription;
                if (!(subscription instanceof Subscription)) {
                  const tmp = subscription;
                  (subscription = new Subscription()),
                    (subscription._subscriptions = [tmp]);
                }
                break;
              default:
                throw new Error(
                  'unrecognized teardown ' +
                    teardown +
                    ' added to Subscription.'
                );
            }
            let { _parentOrParents: _parentOrParents } = subscription;
            if (null === _parentOrParents) subscription._parentOrParents = this;
            else if (_parentOrParents instanceof Subscription) {
              if (_parentOrParents === this) return subscription;
              subscription._parentOrParents = [_parentOrParents, this];
            } else {
              if (-1 !== _parentOrParents.indexOf(this)) return subscription;
              _parentOrParents.push(this);
            }
            const subscriptions = this._subscriptions;
            return (
              null === subscriptions
                ? (this._subscriptions = [subscription])
                : subscriptions.push(subscription),
              subscription
            );
          }
          remove(subscription) {
            const subscriptions = this._subscriptions;
            if (subscriptions) {
              const subscriptionIndex = subscriptions.indexOf(subscription);
              -1 !== subscriptionIndex &&
                subscriptions.splice(subscriptionIndex, 1);
            }
          }
        }
        var empty;
        return (
          (Subscription.EMPTY =
            (((empty = new Subscription()).closed = !0), empty)),
          Subscription
        );
      })();
      function flattenUnsubscriptionErrors(errors) {
        return errors.reduce(
          (errs, err) =>
            errs.concat(err instanceof UnsubscriptionError ? err.errors : err),
          []
        );
      }
    },
    'rB/T': function(module, exports, __webpack_require__) {
      'use strict';
      function __export(m) {
        for (var p in m) exports.hasOwnProperty(p) || (exports[p] = m[p]);
      }
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        __export(__webpack_require__('LbVS')),
        __export(__webpack_require__('vauT')),
        __export(__webpack_require__('PsNa'));
    },
    rB9j: function(module, exports, __webpack_require__) {
      'use strict';
      var $ = __webpack_require__('I+eb'),
        exec = __webpack_require__('kmMV');
      $(
        { target: 'RegExp', proto: !0, forced: /./.exec !== exec },
        { exec: exec }
      );
    },
    rKzb: function(module, exports, __webpack_require__) {
      'use strict';
      var redefineAll = __webpack_require__('4syw'),
        getWeakData = __webpack_require__('8YOa').getWeakData,
        anObject = __webpack_require__('glrk'),
        isObject = __webpack_require__('hh1v'),
        anInstance = __webpack_require__('GarU'),
        iterate = __webpack_require__('ImZN'),
        ArrayIterationModule = __webpack_require__('tycR'),
        $has = __webpack_require__('UTVS'),
        InternalStateModule = __webpack_require__('afO8'),
        setInternalState = InternalStateModule.set,
        internalStateGetterFor = InternalStateModule.getterFor,
        find = ArrayIterationModule.find,
        findIndex = ArrayIterationModule.findIndex,
        id = 0,
        uncaughtFrozenStore = function(store) {
          return store.frozen || (store.frozen = new UncaughtFrozenStore());
        },
        UncaughtFrozenStore = function() {
          this.entries = [];
        },
        findUncaughtFrozen = function(store, key) {
          return find(store.entries, function(it) {
            return it[0] === key;
          });
        };
      (UncaughtFrozenStore.prototype = {
        get: function(key) {
          var entry = findUncaughtFrozen(this, key);
          if (entry) return entry[1];
        },
        has: function(key) {
          return !!findUncaughtFrozen(this, key);
        },
        set: function(key, value) {
          var entry = findUncaughtFrozen(this, key);
          entry ? (entry[1] = value) : this.entries.push([key, value]);
        },
        delete: function(key) {
          var index = findIndex(this.entries, function(it) {
            return it[0] === key;
          });
          return ~index && this.entries.splice(index, 1), !!~index;
        }
      }),
        (module.exports = {
          getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
            var C = wrapper(function(that, iterable) {
                anInstance(that, C, CONSTRUCTOR_NAME),
                  setInternalState(that, {
                    type: CONSTRUCTOR_NAME,
                    id: id++,
                    frozen: void 0
                  }),
                  null != iterable &&
                    iterate(iterable, that[ADDER], that, IS_MAP);
              }),
              getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME),
              define = function(that, key, value) {
                var state = getInternalState(that),
                  data = getWeakData(anObject(key), !0);
                return (
                  !0 === data
                    ? uncaughtFrozenStore(state).set(key, value)
                    : (data[state.id] = value),
                  that
                );
              };
            return (
              redefineAll(C.prototype, {
                delete: function(key) {
                  var state = getInternalState(this);
                  if (!isObject(key)) return !1;
                  var data = getWeakData(key);
                  return !0 === data
                    ? uncaughtFrozenStore(state).delete(key)
                    : data && $has(data, state.id) && delete data[state.id];
                },
                has: function(key) {
                  var state = getInternalState(this);
                  if (!isObject(key)) return !1;
                  var data = getWeakData(key);
                  return !0 === data
                    ? uncaughtFrozenStore(state).has(key)
                    : data && $has(data, state.id);
                }
              }),
              redefineAll(
                C.prototype,
                IS_MAP
                  ? {
                      get: function(key) {
                        var state = getInternalState(this);
                        if (isObject(key)) {
                          var data = getWeakData(key);
                          return !0 === data
                            ? uncaughtFrozenStore(state).get(key)
                            : data
                            ? data[state.id]
                            : void 0;
                        }
                      },
                      set: function(key, value) {
                        return define(this, key, value);
                      }
                    }
                  : {
                      add: function(value) {
                        return define(this, value, !0);
                      }
                    }
              ),
              C
            );
          }
        });
    },
    rW0t: function(module, exports, __webpack_require__) {
      'use strict';
      var anObject = __webpack_require__('glrk');
      module.exports = function() {
        var that = anObject(this),
          result = '';
        return (
          that.global && (result += 'g'),
          that.ignoreCase && (result += 'i'),
          that.multiline && (result += 'm'),
          that.dotAll && (result += 's'),
          that.unicode && (result += 'u'),
          that.sticky && (result += 'y'),
          result
        );
      };
    },
    rpNk: function(module, exports, __webpack_require__) {
      'use strict';
      var IteratorPrototype,
        PrototypeOfArrayIteratorPrototype,
        arrayIterator,
        getPrototypeOf = __webpack_require__('4WOD'),
        hide = __webpack_require__('X2U+'),
        has = __webpack_require__('UTVS'),
        wellKnownSymbol = __webpack_require__('tiKp'),
        IS_PURE = __webpack_require__('xDBR'),
        ITERATOR = wellKnownSymbol('iterator'),
        BUGGY_SAFARI_ITERATORS = !1;
      [].keys &&
        ('next' in (arrayIterator = [].keys())
          ? (PrototypeOfArrayIteratorPrototype = getPrototypeOf(
              getPrototypeOf(arrayIterator)
            )) !== Object.prototype &&
            (IteratorPrototype = PrototypeOfArrayIteratorPrototype)
          : (BUGGY_SAFARI_ITERATORS = !0)),
        null == IteratorPrototype && (IteratorPrototype = {}),
        IS_PURE ||
          has(IteratorPrototype, ITERATOR) ||
          hide(IteratorPrototype, ITERATOR, function() {
            return this;
          }),
        (module.exports = {
          IteratorPrototype: IteratorPrototype,
          BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
        });
    },
    sEFX: function(module, exports, __webpack_require__) {
      'use strict';
      var classof = __webpack_require__('9d/t'),
        test = {};
      (test[__webpack_require__('tiKp')('toStringTag')] = 'z'),
        (module.exports =
          '[object z]' !== String(test)
            ? function() {
                return '[object ' + classof(this) + ']';
              }
            : test.toString);
    },
    sMBO: function(module, exports, __webpack_require__) {
      var DESCRIPTORS = __webpack_require__('g6v/'),
        defineProperty = __webpack_require__('m/L8').f,
        FunctionPrototype = Function.prototype,
        FunctionPrototypeToString = FunctionPrototype.toString,
        nameRE = /^\s*function ([^ (]*)/;
      DESCRIPTORS &&
        !('name' in FunctionPrototype) &&
        defineProperty(FunctionPrototype, 'name', {
          configurable: !0,
          get: function() {
            try {
              return FunctionPrototypeToString.call(this).match(nameRE)[1];
            } catch (error) {
              return '';
            }
          }
        });
    },
    sYmb: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return ngx_translate_core_TranslateModule;
      }),
        __webpack_require__.d(__webpack_exports__, 'c', function() {
          return ngx_translate_core_TranslateService;
        }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return ngx_translate_core_TranslatePipe;
        });
      var core = __webpack_require__('fXoL'),
        of = __webpack_require__('LRne'),
        merge = __webpack_require__('VRyK'),
        Observable = __webpack_require__('HDdC'),
        concat = __webpack_require__('GyhO'),
        take = __webpack_require__('IzEk'),
        share = __webpack_require__('w1tV'),
        map = __webpack_require__('lJxs'),
        scan = __webpack_require__('Kqap'),
        takeLast = __webpack_require__('BFxc'),
        defaultIfEmpty = __webpack_require__('xbPD'),
        pipe = __webpack_require__('mCNh');
      function toArrayReducer(arr, item, index) {
        return 0 === index ? [item] : (arr.push(item), arr);
      }
      var switchMap = __webpack_require__('eIep');
      class TranslateLoader {}
      let ngx_translate_core_TranslateFakeLoader = (() => {
        class TranslateFakeLoader extends TranslateLoader {
          getTranslation(lang) {
            return Object(of.a)({});
          }
        }
        return (
          (TranslateFakeLoader.ɵfac = function(t) {
            return ɵTranslateFakeLoader_BaseFactory(t || TranslateFakeLoader);
          }),
          (TranslateFakeLoader.ɵprov = core.Hb({
            token: TranslateFakeLoader,
            factory: TranslateFakeLoader.ɵfac
          })),
          TranslateFakeLoader
        );
      })();
      const ɵTranslateFakeLoader_BaseFactory = core.Sb(
        ngx_translate_core_TranslateFakeLoader
      );
      class MissingTranslationHandler {}
      let ngx_translate_core_FakeMissingTranslationHandler = (() => {
        class FakeMissingTranslationHandler {
          handle(params) {
            return params.key;
          }
        }
        return (
          (FakeMissingTranslationHandler.ɵfac = function(t) {
            return new (t || FakeMissingTranslationHandler)();
          }),
          (FakeMissingTranslationHandler.ɵprov = core.Hb({
            token: FakeMissingTranslationHandler,
            factory: FakeMissingTranslationHandler.ɵfac
          })),
          FakeMissingTranslationHandler
        );
      })();
      class TranslateCompiler {}
      let ngx_translate_core_TranslateFakeCompiler = (() => {
        class TranslateFakeCompiler extends TranslateCompiler {
          compile(value, lang) {
            return value;
          }
          compileTranslations(translations, lang) {
            return translations;
          }
        }
        return (
          (TranslateFakeCompiler.ɵfac = function(t) {
            return ɵTranslateFakeCompiler_BaseFactory(
              t || TranslateFakeCompiler
            );
          }),
          (TranslateFakeCompiler.ɵprov = core.Hb({
            token: TranslateFakeCompiler,
            factory: TranslateFakeCompiler.ɵfac
          })),
          TranslateFakeCompiler
        );
      })();
      const ɵTranslateFakeCompiler_BaseFactory = core.Sb(
        ngx_translate_core_TranslateFakeCompiler
      );
      function equals(o1, o2) {
        if (o1 === o2) return !0;
        if (null === o1 || null === o2) return !1;
        if (o1 != o1 && o2 != o2) return !0;
        let length,
          key,
          keySet,
          t1 = typeof o1;
        if (t1 == typeof o2 && 'object' == t1) {
          if (!Array.isArray(o1)) {
            if (Array.isArray(o2)) return !1;
            for (key in ((keySet = Object.create(null)), o1)) {
              if (!equals(o1[key], o2[key])) return !1;
              keySet[key] = !0;
            }
            for (key in o2)
              if (!(key in keySet) && void 0 !== o2[key]) return !1;
            return !0;
          }
          if (!Array.isArray(o2)) return !1;
          if ((length = o1.length) == o2.length) {
            for (key = 0; key < length; key++)
              if (!equals(o1[key], o2[key])) return !1;
            return !0;
          }
        }
        return !1;
      }
      function isDefined(value) {
        return null != value;
      }
      function isObject(item) {
        return item && 'object' == typeof item && !Array.isArray(item);
      }
      class TranslateParser {}
      let ngx_translate_core_TranslateDefaultParser = (() => {
        class TranslateDefaultParser extends TranslateParser {
          constructor() {
            super(...arguments),
              (this.templateMatcher = /{{\s?([^{}\s]*)\s?}}/g);
          }
          interpolate(expr, params) {
            let result;
            return (
              (result =
                'string' == typeof expr
                  ? this.interpolateString(expr, params)
                  : 'function' == typeof expr
                  ? this.interpolateFunction(expr, params)
                  : expr),
              result
            );
          }
          getValue(target, key) {
            let keys = key.split('.');
            key = '';
            do {
              (key += keys.shift()),
                !isDefined(target) ||
                !isDefined(target[key]) ||
                ('object' != typeof target[key] && keys.length)
                  ? keys.length
                    ? (key += '.')
                    : (target = void 0)
                  : ((target = target[key]), (key = ''));
            } while (keys.length);
            return target;
          }
          interpolateFunction(fn, params) {
            return fn(params);
          }
          interpolateString(expr, params) {
            return params
              ? expr.replace(this.templateMatcher, (substring, b) => {
                  let r = this.getValue(params, b);
                  return isDefined(r) ? r : substring;
                })
              : expr;
          }
        }
        return (
          (TranslateDefaultParser.ɵfac = function(t) {
            return ɵTranslateDefaultParser_BaseFactory(
              t || TranslateDefaultParser
            );
          }),
          (TranslateDefaultParser.ɵprov = core.Hb({
            token: TranslateDefaultParser,
            factory: TranslateDefaultParser.ɵfac
          })),
          TranslateDefaultParser
        );
      })();
      const ɵTranslateDefaultParser_BaseFactory = core.Sb(
        ngx_translate_core_TranslateDefaultParser
      );
      class ngx_translate_core_TranslateStore {
        constructor() {
          (this.currentLang = this.defaultLang),
            (this.translations = {}),
            (this.langs = []),
            (this.onTranslationChange = new core.n()),
            (this.onLangChange = new core.n()),
            (this.onDefaultLangChange = new core.n());
        }
      }
      const USE_STORE = new core.q('USE_STORE'),
        USE_DEFAULT_LANG = new core.q('USE_DEFAULT_LANG');
      let ngx_translate_core_TranslateService = (() => {
          class TranslateService {
            constructor(
              store,
              currentLoader,
              compiler,
              parser,
              missingTranslationHandler,
              useDefaultLang = !0,
              isolate = !1
            ) {
              (this.store = store),
                (this.currentLoader = currentLoader),
                (this.compiler = compiler),
                (this.parser = parser),
                (this.missingTranslationHandler = missingTranslationHandler),
                (this.useDefaultLang = useDefaultLang),
                (this.isolate = isolate),
                (this.pending = !1),
                (this._onTranslationChange = new core.n()),
                (this._onLangChange = new core.n()),
                (this._onDefaultLangChange = new core.n()),
                (this._langs = []),
                (this._translations = {}),
                (this._translationRequests = {});
            }
            get onTranslationChange() {
              return this.isolate
                ? this._onTranslationChange
                : this.store.onTranslationChange;
            }
            get onLangChange() {
              return this.isolate
                ? this._onLangChange
                : this.store.onLangChange;
            }
            get onDefaultLangChange() {
              return this.isolate
                ? this._onDefaultLangChange
                : this.store.onDefaultLangChange;
            }
            get defaultLang() {
              return this.isolate ? this._defaultLang : this.store.defaultLang;
            }
            set defaultLang(defaultLang) {
              this.isolate
                ? (this._defaultLang = defaultLang)
                : (this.store.defaultLang = defaultLang);
            }
            get currentLang() {
              return this.isolate ? this._currentLang : this.store.currentLang;
            }
            set currentLang(currentLang) {
              this.isolate
                ? (this._currentLang = currentLang)
                : (this.store.currentLang = currentLang);
            }
            get langs() {
              return this.isolate ? this._langs : this.store.langs;
            }
            set langs(langs) {
              this.isolate ? (this._langs = langs) : (this.store.langs = langs);
            }
            get translations() {
              return this.isolate
                ? this._translations
                : this.store.translations;
            }
            set translations(translations) {
              this.isolate
                ? (this._translations = translations)
                : (this.store.translations = translations);
            }
            setDefaultLang(lang) {
              if (lang === this.defaultLang) return;
              let pending = this.retrieveTranslations(lang);
              void 0 !== pending
                ? (this.defaultLang || (this.defaultLang = lang),
                  pending.pipe(Object(take.a)(1)).subscribe(res => {
                    this.changeDefaultLang(lang);
                  }))
                : this.changeDefaultLang(lang);
            }
            getDefaultLang() {
              return this.defaultLang;
            }
            use(lang) {
              if (lang === this.currentLang)
                return Object(of.a)(this.translations[lang]);
              let pending = this.retrieveTranslations(lang);
              return void 0 !== pending
                ? (this.currentLang || (this.currentLang = lang),
                  pending.pipe(Object(take.a)(1)).subscribe(res => {
                    this.changeLang(lang);
                  }),
                  pending)
                : (this.changeLang(lang),
                  Object(of.a)(this.translations[lang]));
            }
            retrieveTranslations(lang) {
              let pending;
              return (
                void 0 === this.translations[lang] &&
                  ((this._translationRequests[lang] =
                    this._translationRequests[lang] ||
                    this.getTranslation(lang)),
                  (pending = this._translationRequests[lang])),
                pending
              );
            }
            getTranslation(lang) {
              this.pending = !0;
              const loadingTranslations = this.currentLoader
                .getTranslation(lang)
                .pipe(Object(share.a)());
              return (
                (this.loadingTranslations = loadingTranslations.pipe(
                  Object(take.a)(1),
                  Object(map.a)(res =>
                    this.compiler.compileTranslations(res, lang)
                  ),
                  Object(share.a)()
                )),
                this.loadingTranslations.subscribe(
                  res => {
                    (this.translations[lang] = res),
                      this.updateLangs(),
                      (this.pending = !1);
                  },
                  err => {
                    this.pending = !1;
                  }
                ),
                loadingTranslations
              );
            }
            setTranslation(lang, translations, shouldMerge = !1) {
              (translations = this.compiler.compileTranslations(
                translations,
                lang
              )),
                (this.translations[lang] =
                  shouldMerge && this.translations[lang]
                    ? (function mergeDeep(target, source) {
                        let output = Object.assign({}, target);
                        return (
                          isObject(target) &&
                            isObject(source) &&
                            Object.keys(source).forEach(key => {
                              isObject(source[key])
                                ? key in target
                                  ? (output[key] = mergeDeep(
                                      target[key],
                                      source[key]
                                    ))
                                  : Object.assign(output, {
                                      [key]: source[key]
                                    })
                                : Object.assign(output, { [key]: source[key] });
                            }),
                          output
                        );
                      })(this.translations[lang], translations)
                    : translations),
                this.updateLangs(),
                this.onTranslationChange.emit({
                  lang: lang,
                  translations: this.translations[lang]
                });
            }
            getLangs() {
              return this.langs;
            }
            addLangs(langs) {
              langs.forEach(lang => {
                -1 === this.langs.indexOf(lang) && this.langs.push(lang);
              });
            }
            updateLangs() {
              this.addLangs(Object.keys(this.translations));
            }
            getParsedResult(translations, key, interpolateParams) {
              let res;
              if (key instanceof Array) {
                let result = {},
                  observables = !1;
                for (let k of key)
                  (result[k] = this.getParsedResult(
                    translations,
                    k,
                    interpolateParams
                  )),
                    'function' == typeof result[k].subscribe &&
                      (observables = !0);
                if (observables) {
                  let mergedObs;
                  for (let k of key) {
                    let obs =
                      'function' == typeof result[k].subscribe
                        ? result[k]
                        : Object(of.a)(result[k]);
                    mergedObs =
                      void 0 === mergedObs
                        ? obs
                        : Object(merge.a)(mergedObs, obs);
                  }
                  return mergedObs.pipe(
                    (function(accumulator, seed) {
                      return arguments.length >= 2
                        ? function(source) {
                            return Object(pipe.a)(
                              Object(scan.a)(accumulator, seed),
                              Object(takeLast.a)(1),
                              Object(defaultIfEmpty.a)(seed)
                            )(source);
                          }
                        : function(source) {
                            return Object(pipe.a)(
                              Object(scan.a)((acc, value, index) =>
                                accumulator(acc, value, index + 1)
                              ),
                              Object(takeLast.a)(1)
                            )(source);
                          };
                    })(toArrayReducer, []),
                    Object(map.a)(arr => {
                      let obj = {};
                      return (
                        arr.forEach((value, index) => {
                          obj[key[index]] = value;
                        }),
                        obj
                      );
                    })
                  );
                }
                return result;
              }
              if (
                (translations &&
                  (res = this.parser.interpolate(
                    this.parser.getValue(translations, key),
                    interpolateParams
                  )),
                void 0 === res &&
                  this.defaultLang &&
                  this.defaultLang !== this.currentLang &&
                  this.useDefaultLang &&
                  (res = this.parser.interpolate(
                    this.parser.getValue(
                      this.translations[this.defaultLang],
                      key
                    ),
                    interpolateParams
                  )),
                void 0 === res)
              ) {
                let params = { key: key, translateService: this };
                void 0 !== interpolateParams &&
                  (params.interpolateParams = interpolateParams),
                  (res = this.missingTranslationHandler.handle(params));
              }
              return void 0 !== res ? res : key;
            }
            get(key, interpolateParams) {
              if (!isDefined(key) || !key.length)
                throw new Error('Parameter "key" required');
              if (this.pending)
                return Observable.a.create(observer => {
                  let onComplete = res => {
                      observer.next(res), observer.complete();
                    },
                    onError = err => {
                      observer.error(err);
                    };
                  this.loadingTranslations.subscribe(res => {
                    'function' ==
                    typeof (res = this.getParsedResult(
                      res,
                      key,
                      interpolateParams
                    )).subscribe
                      ? res.subscribe(onComplete, onError)
                      : onComplete(res);
                  }, onError);
                });
              {
                let res = this.getParsedResult(
                  this.translations[this.currentLang],
                  key,
                  interpolateParams
                );
                return 'function' == typeof res.subscribe
                  ? res
                  : Object(of.a)(res);
              }
            }
            stream(key, interpolateParams) {
              if (!isDefined(key) || !key.length)
                throw new Error('Parameter "key" required');
              return Object(concat.a)(
                this.get(key, interpolateParams),
                this.onLangChange.pipe(
                  Object(switchMap.a)(event => {
                    const res = this.getParsedResult(
                      event.translations,
                      key,
                      interpolateParams
                    );
                    return 'function' == typeof res.subscribe
                      ? res
                      : Object(of.a)(res);
                  })
                )
              );
            }
            instant(key, interpolateParams) {
              if (!isDefined(key) || !key.length)
                throw new Error('Parameter "key" required');
              let res = this.getParsedResult(
                this.translations[this.currentLang],
                key,
                interpolateParams
              );
              if (void 0 !== res.subscribe) {
                if (key instanceof Array) {
                  let obj = {};
                  return (
                    key.forEach((value, index) => {
                      obj[key[index]] = key[index];
                    }),
                    obj
                  );
                }
                return key;
              }
              return res;
            }
            set(key, value, lang = this.currentLang) {
              (this.translations[lang][key] = this.compiler.compile(
                value,
                lang
              )),
                this.updateLangs(),
                this.onTranslationChange.emit({
                  lang: lang,
                  translations: this.translations[lang]
                });
            }
            changeLang(lang) {
              (this.currentLang = lang),
                this.onLangChange.emit({
                  lang: lang,
                  translations: this.translations[lang]
                }),
                this.defaultLang || this.changeDefaultLang(lang);
            }
            changeDefaultLang(lang) {
              (this.defaultLang = lang),
                this.onDefaultLangChange.emit({
                  lang: lang,
                  translations: this.translations[lang]
                });
            }
            reloadLang(lang) {
              return this.resetLang(lang), this.getTranslation(lang);
            }
            resetLang(lang) {
              (this._translationRequests[lang] = void 0),
                (this.translations[lang] = void 0);
            }
            getBrowserLang() {
              if ('undefined' == typeof window || void 0 === window.navigator)
                return;
              let browserLang = window.navigator.languages
                ? window.navigator.languages[0]
                : null;
              return (
                (browserLang =
                  browserLang ||
                  window.navigator.language ||
                  window.navigator.browserLanguage ||
                  window.navigator.userLanguage),
                -1 !== browserLang.indexOf('-') &&
                  (browserLang = browserLang.split('-')[0]),
                -1 !== browserLang.indexOf('_') &&
                  (browserLang = browserLang.split('_')[0]),
                browserLang
              );
            }
            getBrowserCultureLang() {
              if ('undefined' == typeof window || void 0 === window.navigator)
                return;
              let browserCultureLang = window.navigator.languages
                ? window.navigator.languages[0]
                : null;
              return (
                (browserCultureLang =
                  browserCultureLang ||
                  window.navigator.language ||
                  window.navigator.browserLanguage ||
                  window.navigator.userLanguage),
                browserCultureLang
              );
            }
          }
          return (
            (TranslateService.ɵfac = function(t) {
              return new (t || TranslateService)(
                core.Yb(ngx_translate_core_TranslateStore),
                core.Yb(TranslateLoader),
                core.Yb(TranslateCompiler),
                core.Yb(TranslateParser),
                core.Yb(MissingTranslationHandler),
                core.Yb(USE_DEFAULT_LANG),
                core.Yb(USE_STORE)
              );
            }),
            (TranslateService.ɵprov = core.Hb({
              token: TranslateService,
              factory: TranslateService.ɵfac
            })),
            TranslateService
          );
        })(),
        ngx_translate_core_TranslatePipe = (() => {
          class TranslatePipe {
            constructor(translate, _ref) {
              (this.translate = translate),
                (this._ref = _ref),
                (this.value = '');
            }
            updateValue(key, interpolateParams, translations) {
              let onTranslation = res => {
                (this.value = void 0 !== res ? res : key),
                  (this.lastKey = key),
                  this._ref.markForCheck();
              };
              if (translations) {
                let res = this.translate.getParsedResult(
                  translations,
                  key,
                  interpolateParams
                );
                'function' == typeof res.subscribe
                  ? res.subscribe(onTranslation)
                  : onTranslation(res);
              }
              this.translate
                .get(key, interpolateParams)
                .subscribe(onTranslation);
            }
            transform(query, ...args) {
              if (!query || 0 === query.length) return query;
              if (equals(query, this.lastKey) && equals(args, this.lastParams))
                return this.value;
              let interpolateParams;
              if (isDefined(args[0]) && args.length)
                if ('string' == typeof args[0] && args[0].length) {
                  let validArgs = args[0]
                    .replace(/(\')?([a-zA-Z0-9_]+)(\')?(\s)?:/g, '"$2":')
                    .replace(/:(\s)?(\')(.*?)(\')/g, ':"$3"');
                  try {
                    interpolateParams = JSON.parse(validArgs);
                  } catch (e) {
                    throw new SyntaxError(
                      'Wrong parameter in TranslatePipe. Expected a valid Object, received: ' +
                        args[0]
                    );
                  }
                } else
                  'object' != typeof args[0] ||
                    Array.isArray(args[0]) ||
                    (interpolateParams = args[0]);
              return (
                (this.lastKey = query),
                (this.lastParams = args),
                this.updateValue(query, interpolateParams),
                this._dispose(),
                this.onTranslationChange ||
                  (this.onTranslationChange = this.translate.onTranslationChange.subscribe(
                    event => {
                      this.lastKey &&
                        event.lang === this.translate.currentLang &&
                        ((this.lastKey = null),
                        this.updateValue(
                          query,
                          interpolateParams,
                          event.translations
                        ));
                    }
                  )),
                this.onLangChange ||
                  (this.onLangChange = this.translate.onLangChange.subscribe(
                    event => {
                      this.lastKey &&
                        ((this.lastKey = null),
                        this.updateValue(
                          query,
                          interpolateParams,
                          event.translations
                        ));
                    }
                  )),
                this.onDefaultLangChange ||
                  (this.onDefaultLangChange = this.translate.onDefaultLangChange.subscribe(
                    () => {
                      this.lastKey &&
                        ((this.lastKey = null),
                        this.updateValue(query, interpolateParams));
                    }
                  )),
                this.value
              );
            }
            _dispose() {
              void 0 !== this.onTranslationChange &&
                (this.onTranslationChange.unsubscribe(),
                (this.onTranslationChange = void 0)),
                void 0 !== this.onLangChange &&
                  (this.onLangChange.unsubscribe(),
                  (this.onLangChange = void 0)),
                void 0 !== this.onDefaultLangChange &&
                  (this.onDefaultLangChange.unsubscribe(),
                  (this.onDefaultLangChange = void 0));
            }
            ngOnDestroy() {
              this._dispose();
            }
          }
          return (
            (TranslatePipe.ɵfac = function(t) {
              return new (t || TranslatePipe)(
                core.Lb(ngx_translate_core_TranslateService),
                core.ac()
              );
            }),
            (TranslatePipe.ɵpipe = core.Kb({
              name: 'translate',
              type: TranslatePipe,
              pure: !1
            })),
            (TranslatePipe.ɵprov = core.Hb({
              token: TranslatePipe,
              factory: TranslatePipe.ɵfac
            })),
            TranslatePipe
          );
        })(),
        ngx_translate_core_TranslateModule = (() => {
          class TranslateModule {
            static forRoot(config = {}) {
              return {
                ngModule: TranslateModule,
                providers: [
                  config.loader || {
                    provide: TranslateLoader,
                    useClass: ngx_translate_core_TranslateFakeLoader
                  },
                  config.compiler || {
                    provide: TranslateCompiler,
                    useClass: ngx_translate_core_TranslateFakeCompiler
                  },
                  config.parser || {
                    provide: TranslateParser,
                    useClass: ngx_translate_core_TranslateDefaultParser
                  },
                  config.missingTranslationHandler || {
                    provide: MissingTranslationHandler,
                    useClass: ngx_translate_core_FakeMissingTranslationHandler
                  },
                  ngx_translate_core_TranslateStore,
                  { provide: USE_STORE, useValue: config.isolate },
                  {
                    provide: USE_DEFAULT_LANG,
                    useValue: config.useDefaultLang
                  },
                  ngx_translate_core_TranslateService
                ]
              };
            }
            static forChild(config = {}) {
              return {
                ngModule: TranslateModule,
                providers: [
                  config.loader || {
                    provide: TranslateLoader,
                    useClass: ngx_translate_core_TranslateFakeLoader
                  },
                  config.compiler || {
                    provide: TranslateCompiler,
                    useClass: ngx_translate_core_TranslateFakeCompiler
                  },
                  config.parser || {
                    provide: TranslateParser,
                    useClass: ngx_translate_core_TranslateDefaultParser
                  },
                  config.missingTranslationHandler || {
                    provide: MissingTranslationHandler,
                    useClass: ngx_translate_core_FakeMissingTranslationHandler
                  },
                  { provide: USE_STORE, useValue: config.isolate },
                  {
                    provide: USE_DEFAULT_LANG,
                    useValue: config.useDefaultLang
                  },
                  ngx_translate_core_TranslateService
                ]
              };
            }
          }
          return (
            (TranslateModule.ɵmod = core.Jb({ type: TranslateModule })),
            (TranslateModule.ɵinj = core.Ib({
              factory: function(t) {
                return new (t || TranslateModule)();
              }
            })),
            TranslateModule
          );
        })();
    },
    swFL: function(module, exports, __webpack_require__) {
      'use strict';
      var fails = __webpack_require__('0Dky');
      module.exports = function(METHOD_NAME, argument) {
        var method = [][METHOD_NAME];
        return (
          !method ||
          !fails(function() {
            method.call(
              null,
              argument ||
                function() {
                  throw 1;
                },
              1
            );
          })
        );
      };
    },
    tiKp: function(module, exports, __webpack_require__) {
      var global = __webpack_require__('2oRo'),
        shared = __webpack_require__('VpIT'),
        uid = __webpack_require__('kOOl'),
        NATIVE_SYMBOL = __webpack_require__('STAE'),
        Symbol = global.Symbol,
        store = shared('wks');
      module.exports = function(name) {
        return (
          store[name] ||
          (store[name] =
            (NATIVE_SYMBOL && Symbol[name]) ||
            (NATIVE_SYMBOL ? Symbol : uid)('Symbol.' + name))
        );
      };
    },
    'tk/3': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return HttpClient;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return HttpClientModule;
        }),
        __webpack_require__.d(__webpack_exports__, 'c', function() {
          return HttpHandler;
        }),
        __webpack_require__.d(__webpack_exports__, 'd', function() {
          return HttpResponse;
        });
      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'fXoL'
        ),
        rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__('LRne'),
        rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__('HDdC'),
        rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
          'bOdf'
        ),
        rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
          'pLZG'
        ),
        rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
          'lJxs'
        ),
        _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
          'ofXK'
        );
      class HttpHandler {}
      class HttpBackend {}
      class HttpHeaders {
        constructor(headers) {
          (this.normalizedNames = new Map()),
            (this.lazyUpdate = null),
            headers
              ? (this.lazyInit =
                  'string' == typeof headers
                    ? () => {
                        (this.headers = new Map()),
                          headers.split('\n').forEach(line => {
                            const index = line.indexOf(':');
                            if (index > 0) {
                              const name = line.slice(0, index),
                                key = name.toLowerCase(),
                                value = line.slice(index + 1).trim();
                              this.maybeSetNormalizedName(name, key),
                                this.headers.has(key)
                                  ? this.headers.get(key).push(value)
                                  : this.headers.set(key, [value]);
                            }
                          });
                      }
                    : () => {
                        (this.headers = new Map()),
                          Object.keys(headers).forEach(name => {
                            let values = headers[name];
                            const key = name.toLowerCase();
                            'string' == typeof values && (values = [values]),
                              values.length > 0 &&
                                (this.headers.set(key, values),
                                this.maybeSetNormalizedName(name, key));
                          });
                      })
              : (this.headers = new Map());
        }
        has(name) {
          return this.init(), this.headers.has(name.toLowerCase());
        }
        get(name) {
          this.init();
          const values = this.headers.get(name.toLowerCase());
          return values && values.length > 0 ? values[0] : null;
        }
        keys() {
          return this.init(), Array.from(this.normalizedNames.values());
        }
        getAll(name) {
          return this.init(), this.headers.get(name.toLowerCase()) || null;
        }
        append(name, value) {
          return this.clone({ name: name, value: value, op: 'a' });
        }
        set(name, value) {
          return this.clone({ name: name, value: value, op: 's' });
        }
        delete(name, value) {
          return this.clone({ name: name, value: value, op: 'd' });
        }
        maybeSetNormalizedName(name, lcName) {
          this.normalizedNames.has(lcName) ||
            this.normalizedNames.set(lcName, name);
        }
        init() {
          this.lazyInit &&
            (this.lazyInit instanceof HttpHeaders
              ? this.copyFrom(this.lazyInit)
              : this.lazyInit(),
            (this.lazyInit = null),
            this.lazyUpdate &&
              (this.lazyUpdate.forEach(update => this.applyUpdate(update)),
              (this.lazyUpdate = null)));
        }
        copyFrom(other) {
          other.init(),
            Array.from(other.headers.keys()).forEach(key => {
              this.headers.set(key, other.headers.get(key)),
                this.normalizedNames.set(key, other.normalizedNames.get(key));
            });
        }
        clone(update) {
          const clone = new HttpHeaders();
          return (
            (clone.lazyInit =
              this.lazyInit && this.lazyInit instanceof HttpHeaders
                ? this.lazyInit
                : this),
            (clone.lazyUpdate = (this.lazyUpdate || []).concat([update])),
            clone
          );
        }
        applyUpdate(update) {
          const key = update.name.toLowerCase();
          switch (update.op) {
            case 'a':
            case 's':
              let value = update.value;
              if (
                ('string' == typeof value && (value = [value]),
                0 === value.length)
              )
                return;
              this.maybeSetNormalizedName(update.name, key);
              const base =
                ('a' === update.op ? this.headers.get(key) : void 0) || [];
              base.push(...value), this.headers.set(key, base);
              break;
            case 'd':
              const toDelete = update.value;
              if (toDelete) {
                let existing = this.headers.get(key);
                if (!existing) return;
                (existing = existing.filter(
                  value => -1 === toDelete.indexOf(value)
                )),
                  0 === existing.length
                    ? (this.headers.delete(key),
                      this.normalizedNames.delete(key))
                    : this.headers.set(key, existing);
              } else this.headers.delete(key), this.normalizedNames.delete(key);
          }
        }
        forEach(fn) {
          this.init(),
            Array.from(this.normalizedNames.keys()).forEach(key =>
              fn(this.normalizedNames.get(key), this.headers.get(key))
            );
        }
      }
      class HttpUrlEncodingCodec {
        encodeKey(key) {
          return standardEncoding(key);
        }
        encodeValue(value) {
          return standardEncoding(value);
        }
        decodeKey(key) {
          return decodeURIComponent(key);
        }
        decodeValue(value) {
          return decodeURIComponent(value);
        }
      }
      function standardEncoding(v) {
        return encodeURIComponent(v)
          .replace(/%40/gi, '@')
          .replace(/%3A/gi, ':')
          .replace(/%24/gi, '$')
          .replace(/%2C/gi, ',')
          .replace(/%3B/gi, ';')
          .replace(/%2B/gi, '+')
          .replace(/%3D/gi, '=')
          .replace(/%3F/gi, '?')
          .replace(/%2F/gi, '/');
      }
      class HttpParams {
        constructor(options = {}) {
          if (
            ((this.updates = null),
            (this.cloneFrom = null),
            (this.encoder = options.encoder || new HttpUrlEncodingCodec()),
            options.fromString)
          ) {
            if (options.fromObject)
              throw new Error('Cannot specify both fromString and fromObject.');
            this.map = (function(rawParams, codec) {
              const map = new Map();
              return (
                rawParams.length > 0 &&
                  rawParams.split('&').forEach(param => {
                    const eqIdx = param.indexOf('='),
                      [key, val] =
                        -1 == eqIdx
                          ? [codec.decodeKey(param), '']
                          : [
                              codec.decodeKey(param.slice(0, eqIdx)),
                              codec.decodeValue(param.slice(eqIdx + 1))
                            ],
                      list = map.get(key) || [];
                    list.push(val), map.set(key, list);
                  }),
                map
              );
            })(options.fromString, this.encoder);
          } else
            options.fromObject
              ? ((this.map = new Map()),
                Object.keys(options.fromObject).forEach(key => {
                  const value = options.fromObject[key];
                  this.map.set(key, Array.isArray(value) ? value : [value]);
                }))
              : (this.map = null);
        }
        has(param) {
          return this.init(), this.map.has(param);
        }
        get(param) {
          this.init();
          const res = this.map.get(param);
          return res ? res[0] : null;
        }
        getAll(param) {
          return this.init(), this.map.get(param) || null;
        }
        keys() {
          return this.init(), Array.from(this.map.keys());
        }
        append(param, value) {
          return this.clone({ param: param, value: value, op: 'a' });
        }
        set(param, value) {
          return this.clone({ param: param, value: value, op: 's' });
        }
        delete(param, value) {
          return this.clone({ param: param, value: value, op: 'd' });
        }
        toString() {
          return (
            this.init(),
            this.keys()
              .map(key => {
                const eKey = this.encoder.encodeKey(key);
                return this.map
                  .get(key)
                  .map(value => eKey + '=' + this.encoder.encodeValue(value))
                  .join('&');
              })
              .filter(param => '' !== param)
              .join('&')
          );
        }
        clone(update) {
          const clone = new HttpParams({ encoder: this.encoder });
          return (
            (clone.cloneFrom = this.cloneFrom || this),
            (clone.updates = (this.updates || []).concat([update])),
            clone
          );
        }
        init() {
          null === this.map && (this.map = new Map()),
            null !== this.cloneFrom &&
              (this.cloneFrom.init(),
              this.cloneFrom
                .keys()
                .forEach(key => this.map.set(key, this.cloneFrom.map.get(key))),
              this.updates.forEach(update => {
                switch (update.op) {
                  case 'a':
                  case 's':
                    const base =
                      ('a' === update.op
                        ? this.map.get(update.param)
                        : void 0) || [];
                    base.push(update.value), this.map.set(update.param, base);
                    break;
                  case 'd':
                    if (void 0 === update.value) {
                      this.map.delete(update.param);
                      break;
                    }
                    {
                      let base = this.map.get(update.param) || [];
                      const idx = base.indexOf(update.value);
                      -1 !== idx && base.splice(idx, 1),
                        base.length > 0
                          ? this.map.set(update.param, base)
                          : this.map.delete(update.param);
                    }
                }
              }),
              (this.cloneFrom = this.updates = null));
        }
      }
      function isArrayBuffer(value) {
        return (
          'undefined' != typeof ArrayBuffer && value instanceof ArrayBuffer
        );
      }
      function isBlob(value) {
        return 'undefined' != typeof Blob && value instanceof Blob;
      }
      function isFormData(value) {
        return 'undefined' != typeof FormData && value instanceof FormData;
      }
      class HttpRequest {
        constructor(method, url, third, fourth) {
          let options;
          if (
            ((this.url = url),
            (this.body = null),
            (this.reportProgress = !1),
            (this.withCredentials = !1),
            (this.responseType = 'json'),
            (this.method = method.toUpperCase()),
            (function(method) {
              switch (method) {
                case 'DELETE':
                case 'GET':
                case 'HEAD':
                case 'OPTIONS':
                case 'JSONP':
                  return !1;
                default:
                  return !0;
              }
            })(this.method) || fourth
              ? ((this.body = void 0 !== third ? third : null),
                (options = fourth))
              : (options = third),
            options &&
              ((this.reportProgress = !!options.reportProgress),
              (this.withCredentials = !!options.withCredentials),
              options.responseType &&
                (this.responseType = options.responseType),
              options.headers && (this.headers = options.headers),
              options.params && (this.params = options.params)),
            this.headers || (this.headers = new HttpHeaders()),
            this.params)
          ) {
            const params = this.params.toString();
            if (0 === params.length) this.urlWithParams = url;
            else {
              const qIdx = url.indexOf('?');
              this.urlWithParams =
                url +
                (-1 === qIdx ? '?' : qIdx < url.length - 1 ? '&' : '') +
                params;
            }
          } else (this.params = new HttpParams()), (this.urlWithParams = url);
        }
        serializeBody() {
          return null === this.body
            ? null
            : isArrayBuffer(this.body) ||
              isBlob(this.body) ||
              isFormData(this.body) ||
              'string' == typeof this.body
            ? this.body
            : this.body instanceof HttpParams
            ? this.body.toString()
            : 'object' == typeof this.body ||
              'boolean' == typeof this.body ||
              Array.isArray(this.body)
            ? JSON.stringify(this.body)
            : this.body.toString();
        }
        detectContentTypeHeader() {
          return null === this.body || isFormData(this.body)
            ? null
            : isBlob(this.body)
            ? this.body.type || null
            : isArrayBuffer(this.body)
            ? null
            : 'string' == typeof this.body
            ? 'text/plain'
            : this.body instanceof HttpParams
            ? 'application/x-www-form-urlencoded;charset=UTF-8'
            : 'object' == typeof this.body ||
              'number' == typeof this.body ||
              Array.isArray(this.body)
            ? 'application/json'
            : null;
        }
        clone(update = {}) {
          const method = update.method || this.method,
            url = update.url || this.url,
            responseType = update.responseType || this.responseType,
            body = void 0 !== update.body ? update.body : this.body,
            withCredentials =
              void 0 !== update.withCredentials
                ? update.withCredentials
                : this.withCredentials,
            reportProgress =
              void 0 !== update.reportProgress
                ? update.reportProgress
                : this.reportProgress;
          let headers = update.headers || this.headers,
            params = update.params || this.params;
          return (
            void 0 !== update.setHeaders &&
              (headers = Object.keys(update.setHeaders).reduce(
                (headers, name) => headers.set(name, update.setHeaders[name]),
                headers
              )),
            update.setParams &&
              (params = Object.keys(update.setParams).reduce(
                (params, param) => params.set(param, update.setParams[param]),
                params
              )),
            new HttpRequest(method, url, body, {
              params: params,
              headers: headers,
              reportProgress: reportProgress,
              responseType: responseType,
              withCredentials: withCredentials
            })
          );
        }
      }
      var HttpEventType = (function(HttpEventType) {
        return (
          (HttpEventType[(HttpEventType.Sent = 0)] = 'Sent'),
          (HttpEventType[(HttpEventType.UploadProgress = 1)] =
            'UploadProgress'),
          (HttpEventType[(HttpEventType.ResponseHeader = 2)] =
            'ResponseHeader'),
          (HttpEventType[(HttpEventType.DownloadProgress = 3)] =
            'DownloadProgress'),
          (HttpEventType[(HttpEventType.Response = 4)] = 'Response'),
          (HttpEventType[(HttpEventType.User = 5)] = 'User'),
          HttpEventType
        );
      })({});
      class HttpResponseBase {
        constructor(init, defaultStatus = 200, defaultStatusText = 'OK') {
          (this.headers = init.headers || new HttpHeaders()),
            (this.status =
              void 0 !== init.status ? init.status : defaultStatus),
            (this.statusText = init.statusText || defaultStatusText),
            (this.url = init.url || null),
            (this.ok = this.status >= 200 && this.status < 300);
        }
      }
      class HttpHeaderResponse extends HttpResponseBase {
        constructor(init = {}) {
          super(init), (this.type = HttpEventType.ResponseHeader);
        }
        clone(update = {}) {
          return new HttpHeaderResponse({
            headers: update.headers || this.headers,
            status: void 0 !== update.status ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || void 0
          });
        }
      }
      class HttpResponse extends HttpResponseBase {
        constructor(init = {}) {
          super(init),
            (this.type = HttpEventType.Response),
            (this.body = void 0 !== init.body ? init.body : null);
        }
        clone(update = {}) {
          return new HttpResponse({
            body: void 0 !== update.body ? update.body : this.body,
            headers: update.headers || this.headers,
            status: void 0 !== update.status ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || void 0
          });
        }
      }
      class HttpErrorResponse extends HttpResponseBase {
        constructor(init) {
          super(init, 0, 'Unknown Error'),
            (this.name = 'HttpErrorResponse'),
            (this.ok = !1),
            (this.message =
              this.status >= 200 && this.status < 300
                ? 'Http failure during parsing for ' +
                  (init.url || '(unknown url)')
                : `Http failure response for ${init.url || '(unknown url)'}: ${
                    init.status
                  } ${init.statusText}`),
            (this.error = init.error || null);
        }
      }
      function addBody(options, body) {
        return {
          body: body,
          headers: options.headers,
          observe: options.observe,
          params: options.params,
          reportProgress: options.reportProgress,
          responseType: options.responseType,
          withCredentials: options.withCredentials
        };
      }
      let HttpClient = (() => {
        class HttpClient {
          constructor(handler) {
            this.handler = handler;
          }
          request(first, url, options = {}) {
            let req;
            if (first instanceof HttpRequest) req = first;
            else {
              let headers = void 0;
              headers =
                options.headers instanceof HttpHeaders
                  ? options.headers
                  : new HttpHeaders(options.headers);
              let params = void 0;
              options.params &&
                (params =
                  options.params instanceof HttpParams
                    ? options.params
                    : new HttpParams({ fromObject: options.params })),
                (req = new HttpRequest(
                  first,
                  url,
                  void 0 !== options.body ? options.body : null,
                  {
                    headers: headers,
                    params: params,
                    reportProgress: options.reportProgress,
                    responseType: options.responseType || 'json',
                    withCredentials: options.withCredentials
                  }
                ));
            }
            const events$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(
              req
            ).pipe(
              Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(req =>
                this.handler.handle(req)
              )
            );
            if (first instanceof HttpRequest || 'events' === options.observe)
              return events$;
            const res$ = events$.pipe(
              Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(
                event => event instanceof HttpResponse
              )
            );
            switch (options.observe || 'body') {
              case 'body':
                switch (req.responseType) {
                  case 'arraybuffer':
                    return res$.pipe(
                      Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(
                        res => {
                          if (
                            null !== res.body &&
                            !(res.body instanceof ArrayBuffer)
                          )
                            throw new Error('Response is not an ArrayBuffer.');
                          return res.body;
                        }
                      )
                    );
                  case 'blob':
                    return res$.pipe(
                      Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(
                        res => {
                          if (null !== res.body && !(res.body instanceof Blob))
                            throw new Error('Response is not a Blob.');
                          return res.body;
                        }
                      )
                    );
                  case 'text':
                    return res$.pipe(
                      Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(
                        res => {
                          if (null !== res.body && 'string' != typeof res.body)
                            throw new Error('Response is not a string.');
                          return res.body;
                        }
                      )
                    );
                  case 'json':
                  default:
                    return res$.pipe(
                      Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(
                        res => res.body
                      )
                    );
                }
              case 'response':
                return res$;
              default:
                throw new Error(
                  `Unreachable: unhandled observe type ${options.observe}}`
                );
            }
          }
          delete(url, options = {}) {
            return this.request('DELETE', url, options);
          }
          get(url, options = {}) {
            return this.request('GET', url, options);
          }
          head(url, options = {}) {
            return this.request('HEAD', url, options);
          }
          jsonp(url, callbackParam) {
            return this.request('JSONP', url, {
              params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),
              observe: 'body',
              responseType: 'json'
            });
          }
          options(url, options = {}) {
            return this.request('OPTIONS', url, options);
          }
          patch(url, body, options = {}) {
            return this.request('PATCH', url, addBody(options, body));
          }
          post(url, body, options = {}) {
            return this.request('POST', url, addBody(options, body));
          }
          put(url, body, options = {}) {
            return this.request('PUT', url, addBody(options, body));
          }
        }
        return (
          (HttpClient.ɵfac = function(t) {
            return new (t || HttpClient)(
              _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(HttpHandler)
            );
          }),
          (HttpClient.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb({
            token: HttpClient,
            factory: HttpClient.ɵfac
          })),
          HttpClient
        );
      })();
      class HttpInterceptorHandler {
        constructor(next, interceptor) {
          (this.next = next), (this.interceptor = interceptor);
        }
        handle(req) {
          return this.interceptor.intercept(req, this.next);
        }
      }
      const HTTP_INTERCEPTORS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.q(
        'HTTP_INTERCEPTORS'
      );
      let NoopInterceptor = (() => {
        class NoopInterceptor {
          intercept(req, next) {
            return next.handle(req);
          }
        }
        return (
          (NoopInterceptor.ɵfac = function(t) {
            return new (t || NoopInterceptor)();
          }),
          (NoopInterceptor.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb(
            { token: NoopInterceptor, factory: NoopInterceptor.ɵfac }
          )),
          NoopInterceptor
        );
      })();
      const XSSI_PREFIX = /^\)\]\}',?\n/;
      class XhrFactory {}
      let BrowserXhr = (() => {
          class BrowserXhr {
            constructor() {}
            build() {
              return new XMLHttpRequest();
            }
          }
          return (
            (BrowserXhr.ɵfac = function(t) {
              return new (t || BrowserXhr)();
            }),
            (BrowserXhr.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb({
              token: BrowserXhr,
              factory: BrowserXhr.ɵfac
            })),
            BrowserXhr
          );
        })(),
        HttpXhrBackend = (() => {
          class HttpXhrBackend {
            constructor(xhrFactory) {
              this.xhrFactory = xhrFactory;
            }
            handle(req) {
              if ('JSONP' === req.method)
                throw new Error(
                  'Attempted to construct Jsonp request without JsonpClientModule installed.'
                );
              return new rxjs__WEBPACK_IMPORTED_MODULE_2__.a(observer => {
                const xhr = this.xhrFactory.build();
                if (
                  (xhr.open(req.method, req.urlWithParams),
                  req.withCredentials && (xhr.withCredentials = !0),
                  req.headers.forEach((name, values) =>
                    xhr.setRequestHeader(name, values.join(','))
                  ),
                  req.headers.has('Accept') ||
                    xhr.setRequestHeader(
                      'Accept',
                      'application/json, text/plain, */*'
                    ),
                  !req.headers.has('Content-Type'))
                ) {
                  const detectedType = req.detectContentTypeHeader();
                  null !== detectedType &&
                    xhr.setRequestHeader('Content-Type', detectedType);
                }
                if (req.responseType) {
                  const responseType = req.responseType.toLowerCase();
                  xhr.responseType =
                    'json' !== responseType ? responseType : 'text';
                }
                const reqBody = req.serializeBody();
                let headerResponse = null;
                const partialFromXhr = () => {
                    if (null !== headerResponse) return headerResponse;
                    const status = 1223 === xhr.status ? 204 : xhr.status,
                      statusText = xhr.statusText || 'OK',
                      headers = new HttpHeaders(xhr.getAllResponseHeaders()),
                      url =
                        (function(xhr) {
                          return 'responseURL' in xhr && xhr.responseURL
                            ? xhr.responseURL
                            : /^X-Request-URL:/m.test(
                                xhr.getAllResponseHeaders()
                              )
                            ? xhr.getResponseHeader('X-Request-URL')
                            : null;
                        })(xhr) || req.url;
                    return (
                      (headerResponse = new HttpHeaderResponse({
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url
                      })),
                      headerResponse
                    );
                  },
                  onLoad = () => {
                    let {
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url
                      } = partialFromXhr(),
                      body = null;
                    204 !== status &&
                      (body =
                        void 0 === xhr.response
                          ? xhr.responseText
                          : xhr.response),
                      0 === status && (status = body ? 200 : 0);
                    let ok = status >= 200 && status < 300;
                    if (
                      'json' === req.responseType &&
                      'string' == typeof body
                    ) {
                      const originalBody = body;
                      body = body.replace(XSSI_PREFIX, '');
                      try {
                        body = '' !== body ? JSON.parse(body) : null;
                      } catch (error) {
                        (body = originalBody),
                          ok &&
                            ((ok = !1), (body = { error: error, text: body }));
                      }
                    }
                    ok
                      ? (observer.next(
                          new HttpResponse({
                            body: body,
                            headers: headers,
                            status: status,
                            statusText: statusText,
                            url: url || void 0
                          })
                        ),
                        observer.complete())
                      : observer.error(
                          new HttpErrorResponse({
                            error: body,
                            headers: headers,
                            status: status,
                            statusText: statusText,
                            url: url || void 0
                          })
                        );
                  },
                  onError = error => {
                    const { url: url } = partialFromXhr(),
                      res = new HttpErrorResponse({
                        error: error,
                        status: xhr.status || 0,
                        statusText: xhr.statusText || 'Unknown Error',
                        url: url || void 0
                      });
                    observer.error(res);
                  };
                let sentHeaders = !1;
                const onDownProgress = event => {
                    sentHeaders ||
                      (observer.next(partialFromXhr()), (sentHeaders = !0));
                    let progressEvent = {
                      type: HttpEventType.DownloadProgress,
                      loaded: event.loaded
                    };
                    event.lengthComputable &&
                      (progressEvent.total = event.total),
                      'text' === req.responseType &&
                        xhr.responseText &&
                        (progressEvent.partialText = xhr.responseText),
                      observer.next(progressEvent);
                  },
                  onUpProgress = event => {
                    let progress = {
                      type: HttpEventType.UploadProgress,
                      loaded: event.loaded
                    };
                    event.lengthComputable && (progress.total = event.total),
                      observer.next(progress);
                  };
                return (
                  xhr.addEventListener('load', onLoad),
                  xhr.addEventListener('error', onError),
                  req.reportProgress &&
                    (xhr.addEventListener('progress', onDownProgress),
                    null !== reqBody &&
                      xhr.upload &&
                      xhr.upload.addEventListener('progress', onUpProgress)),
                  xhr.send(reqBody),
                  observer.next({ type: HttpEventType.Sent }),
                  () => {
                    xhr.removeEventListener('error', onError),
                      xhr.removeEventListener('load', onLoad),
                      req.reportProgress &&
                        (xhr.removeEventListener('progress', onDownProgress),
                        null !== reqBody &&
                          xhr.upload &&
                          xhr.upload.removeEventListener(
                            'progress',
                            onUpProgress
                          )),
                      xhr.readyState !== xhr.DONE && xhr.abort();
                  }
                );
              });
            }
          }
          return (
            (HttpXhrBackend.ɵfac = function(t) {
              return new (t || HttpXhrBackend)(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(XhrFactory)
              );
            }),
            (HttpXhrBackend.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb(
              { token: HttpXhrBackend, factory: HttpXhrBackend.ɵfac }
            )),
            HttpXhrBackend
          );
        })();
      const XSRF_COOKIE_NAME = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.q(
          'XSRF_COOKIE_NAME'
        ),
        XSRF_HEADER_NAME = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.q(
          'XSRF_HEADER_NAME'
        );
      class HttpXsrfTokenExtractor {}
      let HttpXsrfCookieExtractor = (() => {
          class HttpXsrfCookieExtractor {
            constructor(doc, platform, cookieName) {
              (this.doc = doc),
                (this.platform = platform),
                (this.cookieName = cookieName),
                (this.lastCookieString = ''),
                (this.lastToken = null),
                (this.parseCount = 0);
            }
            getToken() {
              if ('server' === this.platform) return null;
              const cookieString = this.doc.cookie || '';
              return (
                cookieString !== this.lastCookieString &&
                  (this.parseCount++,
                  (this.lastToken = Object(
                    _angular_common__WEBPACK_IMPORTED_MODULE_6__.z
                  )(cookieString, this.cookieName)),
                  (this.lastCookieString = cookieString)),
                this.lastToken
              );
            }
          }
          return (
            (HttpXsrfCookieExtractor.ɵfac = function(t) {
              return new (t || HttpXsrfCookieExtractor)(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(
                  _angular_common__WEBPACK_IMPORTED_MODULE_6__.c
                ),
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(
                  _angular_core__WEBPACK_IMPORTED_MODULE_0__.B
                ),
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(XSRF_COOKIE_NAME)
              );
            }),
            (HttpXsrfCookieExtractor.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb(
              {
                token: HttpXsrfCookieExtractor,
                factory: HttpXsrfCookieExtractor.ɵfac
              }
            )),
            HttpXsrfCookieExtractor
          );
        })(),
        HttpXsrfInterceptor = (() => {
          class HttpXsrfInterceptor {
            constructor(tokenService, headerName) {
              (this.tokenService = tokenService),
                (this.headerName = headerName);
            }
            intercept(req, next) {
              const lcUrl = req.url.toLowerCase();
              if (
                'GET' === req.method ||
                'HEAD' === req.method ||
                lcUrl.startsWith('http://') ||
                lcUrl.startsWith('https://')
              )
                return next.handle(req);
              const token = this.tokenService.getToken();
              return (
                null === token ||
                  req.headers.has(this.headerName) ||
                  (req = req.clone({
                    headers: req.headers.set(this.headerName, token)
                  })),
                next.handle(req)
              );
            }
          }
          return (
            (HttpXsrfInterceptor.ɵfac = function(t) {
              return new (t || HttpXsrfInterceptor)(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(
                  HttpXsrfTokenExtractor
                ),
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(XSRF_HEADER_NAME)
              );
            }),
            (HttpXsrfInterceptor.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb(
              { token: HttpXsrfInterceptor, factory: HttpXsrfInterceptor.ɵfac }
            )),
            HttpXsrfInterceptor
          );
        })(),
        HttpInterceptingHandler = (() => {
          class HttpInterceptingHandler {
            constructor(backend, injector) {
              (this.backend = backend),
                (this.injector = injector),
                (this.chain = null);
            }
            handle(req) {
              if (null === this.chain) {
                const interceptors = this.injector.get(HTTP_INTERCEPTORS, []);
                this.chain = interceptors.reduceRight(
                  (next, interceptor) =>
                    new HttpInterceptorHandler(next, interceptor),
                  this.backend
                );
              }
              return this.chain.handle(req);
            }
          }
          return (
            (HttpInterceptingHandler.ɵfac = function(t) {
              return new (t || HttpInterceptingHandler)(
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(HttpBackend),
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yb(
                  _angular_core__WEBPACK_IMPORTED_MODULE_0__.r
                )
              );
            }),
            (HttpInterceptingHandler.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hb(
              {
                token: HttpInterceptingHandler,
                factory: HttpInterceptingHandler.ɵfac
              }
            )),
            HttpInterceptingHandler
          );
        })(),
        HttpClientXsrfModule = (() => {
          class HttpClientXsrfModule {
            static disable() {
              return {
                ngModule: HttpClientXsrfModule,
                providers: [
                  { provide: HttpXsrfInterceptor, useClass: NoopInterceptor }
                ]
              };
            }
            static withOptions(options = {}) {
              return {
                ngModule: HttpClientXsrfModule,
                providers: [
                  options.cookieName
                    ? {
                        provide: XSRF_COOKIE_NAME,
                        useValue: options.cookieName
                      }
                    : [],
                  options.headerName
                    ? {
                        provide: XSRF_HEADER_NAME,
                        useValue: options.headerName
                      }
                    : []
                ]
              };
            }
          }
          return (
            (HttpClientXsrfModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb(
              { type: HttpClientXsrfModule }
            )),
            (HttpClientXsrfModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ib(
              {
                factory: function(t) {
                  return new (t || HttpClientXsrfModule)();
                },
                providers: [
                  HttpXsrfInterceptor,
                  {
                    provide: HTTP_INTERCEPTORS,
                    useExisting: HttpXsrfInterceptor,
                    multi: !0
                  },
                  {
                    provide: HttpXsrfTokenExtractor,
                    useClass: HttpXsrfCookieExtractor
                  },
                  { provide: XSRF_COOKIE_NAME, useValue: 'XSRF-TOKEN' },
                  { provide: XSRF_HEADER_NAME, useValue: 'X-XSRF-TOKEN' }
                ]
              }
            )),
            HttpClientXsrfModule
          );
        })(),
        HttpClientModule = (() => {
          class HttpClientModule {}
          return (
            (HttpClientModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb(
              { type: HttpClientModule }
            )),
            (HttpClientModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ib(
              {
                factory: function(t) {
                  return new (t || HttpClientModule)();
                },
                providers: [
                  HttpClient,
                  { provide: HttpHandler, useClass: HttpInterceptingHandler },
                  HttpXhrBackend,
                  { provide: HttpBackend, useExisting: HttpXhrBackend },
                  BrowserXhr,
                  { provide: XhrFactory, useExisting: BrowserXhr }
                ],
                imports: [
                  [
                    HttpClientXsrfModule.withOptions({
                      cookieName: 'XSRF-TOKEN',
                      headerName: 'X-XSRF-TOKEN'
                    })
                  ]
                ]
              }
            )),
            HttpClientModule
          );
        })();
    },
    tyNb: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return router_ActivatedRoute;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return NavigationEnd;
        }),
        __webpack_require__.d(__webpack_exports__, 'c', function() {
          return router_PreloadAllModules;
        }),
        __webpack_require__.d(__webpack_exports__, 'd', function() {
          return RouteReuseStrategy;
        }),
        __webpack_require__.d(__webpack_exports__, 'e', function() {
          return router_Router;
        }),
        __webpack_require__.d(__webpack_exports__, 'f', function() {
          return router_RouterLinkWithHref;
        }),
        __webpack_require__.d(__webpack_exports__, 'g', function() {
          return router_RouterModule;
        }),
        __webpack_require__.d(__webpack_exports__, 'h', function() {
          return router_RouterOutlet;
        });
      var common = __webpack_require__('ofXK'),
        core = __webpack_require__('fXoL'),
        of = __webpack_require__('LRne'),
        from = __webpack_require__('Cfvw'),
        BehaviorSubject = __webpack_require__('2Vo4'),
        Observable = __webpack_require__('HDdC');
      const EmptyError = (() => {
        function EmptyErrorImpl() {
          return (
            Error.call(this),
            (this.message = 'no elements in sequence'),
            (this.name = 'EmptyError'),
            this
          );
        }
        return (
          (EmptyErrorImpl.prototype = Object.create(Error.prototype)),
          EmptyErrorImpl
        );
      })();
      var combineLatest = __webpack_require__('itXk'),
        empty = __webpack_require__('EY2u');
      function defer(observableFactory) {
        return new Observable.a(subscriber => {
          let input;
          try {
            input = observableFactory();
          } catch (err) {
            return void subscriber.error(err);
          }
          return (input ? Object(from.a)(input) : Object(empty.b)()).subscribe(
            subscriber
          );
        });
      }
      var Subject = __webpack_require__('XNiG'),
        map = __webpack_require__('lJxs'),
        concatAll = __webpack_require__('0EUg'),
        filter = __webpack_require__('pLZG'),
        takeLast = __webpack_require__('BFxc'),
        Subscriber = __webpack_require__('7o/Q');
      function throwIfEmpty(errorFactory = defaultErrorFactory) {
        return source => source.lift(new ThrowIfEmptyOperator(errorFactory));
      }
      class ThrowIfEmptyOperator {
        constructor(errorFactory) {
          this.errorFactory = errorFactory;
        }
        call(subscriber, source) {
          return source.subscribe(
            new throwIfEmpty_ThrowIfEmptySubscriber(
              subscriber,
              this.errorFactory
            )
          );
        }
      }
      class throwIfEmpty_ThrowIfEmptySubscriber extends Subscriber.a {
        constructor(destination, errorFactory) {
          super(destination),
            (this.errorFactory = errorFactory),
            (this.hasValue = !1);
        }
        _next(value) {
          (this.hasValue = !0), this.destination.next(value);
        }
        _complete() {
          if (this.hasValue) return this.destination.complete();
          {
            let err;
            try {
              err = this.errorFactory();
            } catch (e) {
              err = e;
            }
            this.destination.error(err);
          }
        }
      }
      function defaultErrorFactory() {
        return new EmptyError();
      }
      var defaultIfEmpty = __webpack_require__('xbPD'),
        identity = __webpack_require__('SpAZ'),
        catchError = __webpack_require__('JIr8'),
        take = __webpack_require__('IzEk');
      function first(predicate, defaultValue) {
        const hasDefaultValue = arguments.length >= 2;
        return source =>
          source.pipe(
            predicate
              ? Object(filter.a)((v, i) => predicate(v, i, source))
              : identity.a,
            Object(take.a)(1),
            hasDefaultValue
              ? Object(defaultIfEmpty.a)(defaultValue)
              : throwIfEmpty(() => new EmptyError())
          );
      }
      var mergeMap = __webpack_require__('5+tZ'),
        tap = __webpack_require__('vkgz');
      class EveryOperator {
        constructor(predicate, thisArg, source) {
          (this.predicate = predicate),
            (this.thisArg = thisArg),
            (this.source = source);
        }
        call(observer, source) {
          return source.subscribe(
            new every_EverySubscriber(
              observer,
              this.predicate,
              this.thisArg,
              this.source
            )
          );
        }
      }
      class every_EverySubscriber extends Subscriber.a {
        constructor(destination, predicate, thisArg, source) {
          super(destination),
            (this.predicate = predicate),
            (this.thisArg = thisArg),
            (this.source = source),
            (this.index = 0),
            (this.thisArg = thisArg || this);
        }
        notifyComplete(everyValueMatch) {
          this.destination.next(everyValueMatch), this.destination.complete();
        }
        _next(value) {
          let result = !1;
          try {
            result = this.predicate.call(
              this.thisArg,
              value,
              this.index++,
              this.source
            );
          } catch (err) {
            return void this.destination.error(err);
          }
          result || this.notifyComplete(!1);
        }
        _complete() {
          this.notifyComplete(!0);
        }
      }
      var switchMap = __webpack_require__('eIep'),
        startWith = __webpack_require__('JX91'),
        scan = __webpack_require__('Kqap'),
        concatMap = __webpack_require__('bOdf'),
        Subscription = __webpack_require__('quSY');
      class FinallyOperator {
        constructor(callback) {
          this.callback = callback;
        }
        call(subscriber, source) {
          return source.subscribe(
            new finalize_FinallySubscriber(subscriber, this.callback)
          );
        }
      }
      class finalize_FinallySubscriber extends Subscriber.a {
        constructor(destination, callback) {
          super(destination), this.add(new Subscription.a(callback));
        }
      }
      var mergeAll = __webpack_require__('bHdf');
      class RouterEvent {
        constructor(id, url) {
          (this.id = id), (this.url = url);
        }
      }
      class NavigationStart extends RouterEvent {
        constructor(
          id,
          url,
          navigationTrigger = 'imperative',
          restoredState = null
        ) {
          super(id, url),
            (this.navigationTrigger = navigationTrigger),
            (this.restoredState = restoredState);
        }
        toString() {
          return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
        }
      }
      class NavigationEnd extends RouterEvent {
        constructor(id, url, urlAfterRedirects) {
          super(id, url), (this.urlAfterRedirects = urlAfterRedirects);
        }
        toString() {
          return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
        }
      }
      class NavigationCancel extends RouterEvent {
        constructor(id, url, reason) {
          super(id, url), (this.reason = reason);
        }
        toString() {
          return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
        }
      }
      class NavigationError extends RouterEvent {
        constructor(id, url, error) {
          super(id, url), (this.error = error);
        }
        toString() {
          return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
        }
      }
      class RoutesRecognized extends RouterEvent {
        constructor(id, url, urlAfterRedirects, state) {
          super(id, url),
            (this.urlAfterRedirects = urlAfterRedirects),
            (this.state = state);
        }
        toString() {
          return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class GuardsCheckStart extends RouterEvent {
        constructor(id, url, urlAfterRedirects, state) {
          super(id, url),
            (this.urlAfterRedirects = urlAfterRedirects),
            (this.state = state);
        }
        toString() {
          return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class GuardsCheckEnd extends RouterEvent {
        constructor(id, url, urlAfterRedirects, state, shouldActivate) {
          super(id, url),
            (this.urlAfterRedirects = urlAfterRedirects),
            (this.state = state),
            (this.shouldActivate = shouldActivate);
        }
        toString() {
          return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
        }
      }
      class ResolveStart extends RouterEvent {
        constructor(id, url, urlAfterRedirects, state) {
          super(id, url),
            (this.urlAfterRedirects = urlAfterRedirects),
            (this.state = state);
        }
        toString() {
          return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class ResolveEnd extends RouterEvent {
        constructor(id, url, urlAfterRedirects, state) {
          super(id, url),
            (this.urlAfterRedirects = urlAfterRedirects),
            (this.state = state);
        }
        toString() {
          return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class RouteConfigLoadStart {
        constructor(route) {
          this.route = route;
        }
        toString() {
          return `RouteConfigLoadStart(path: ${this.route.path})`;
        }
      }
      class RouteConfigLoadEnd {
        constructor(route) {
          this.route = route;
        }
        toString() {
          return `RouteConfigLoadEnd(path: ${this.route.path})`;
        }
      }
      class ChildActivationStart {
        constructor(snapshot) {
          this.snapshot = snapshot;
        }
        toString() {
          return `ChildActivationStart(path: '${(this.snapshot.routeConfig &&
            this.snapshot.routeConfig.path) ||
            ''}')`;
        }
      }
      class ChildActivationEnd {
        constructor(snapshot) {
          this.snapshot = snapshot;
        }
        toString() {
          return `ChildActivationEnd(path: '${(this.snapshot.routeConfig &&
            this.snapshot.routeConfig.path) ||
            ''}')`;
        }
      }
      class ActivationStart {
        constructor(snapshot) {
          this.snapshot = snapshot;
        }
        toString() {
          return `ActivationStart(path: '${(this.snapshot.routeConfig &&
            this.snapshot.routeConfig.path) ||
            ''}')`;
        }
      }
      class ActivationEnd {
        constructor(snapshot) {
          this.snapshot = snapshot;
        }
        toString() {
          return `ActivationEnd(path: '${(this.snapshot.routeConfig &&
            this.snapshot.routeConfig.path) ||
            ''}')`;
        }
      }
      class Scroll {
        constructor(routerEvent, position, anchor) {
          (this.routerEvent = routerEvent),
            (this.position = position),
            (this.anchor = anchor);
        }
        toString() {
          return `Scroll(anchor: '${this.anchor}', position: '${
            this.position ? `${this.position[0]}, ${this.position[1]}` : null
          }')`;
        }
      }
      let router_EmptyOutletComponent = (() => {
        class ɵEmptyOutletComponent {}
        return (
          (ɵEmptyOutletComponent.ɵfac = function(t) {
            return new (t || ɵEmptyOutletComponent)();
          }),
          (ɵEmptyOutletComponent.ɵcmp = core.Fb({
            type: ɵEmptyOutletComponent,
            selectors: [['ng-component']],
            decls: 1,
            vars: 0,
            template: function(rf, ctx) {
              1 & rf && core.Mb(0, 'router-outlet');
            },
            directives: function() {
              return [router_RouterOutlet];
            },
            encapsulation: 2
          })),
          ɵEmptyOutletComponent
        );
      })();
      class ParamsAsMap {
        constructor(params) {
          this.params = params || {};
        }
        has(name) {
          return Object.prototype.hasOwnProperty.call(this.params, name);
        }
        get(name) {
          if (this.has(name)) {
            const v = this.params[name];
            return Array.isArray(v) ? v[0] : v;
          }
          return null;
        }
        getAll(name) {
          if (this.has(name)) {
            const v = this.params[name];
            return Array.isArray(v) ? v : [v];
          }
          return [];
        }
        get keys() {
          return Object.keys(this.params);
        }
      }
      function convertToParamMap(params) {
        return new ParamsAsMap(params);
      }
      function navigationCancelingError(message) {
        const error = Error('NavigationCancelingError: ' + message);
        return (error.ngNavigationCancelingError = !0), error;
      }
      function defaultUrlMatcher(segments, segmentGroup, route) {
        const parts = route.path.split('/');
        if (parts.length > segments.length) return null;
        if (
          'full' === route.pathMatch &&
          (segmentGroup.hasChildren() || parts.length < segments.length)
        )
          return null;
        const posParams = {};
        for (let index = 0; index < parts.length; index++) {
          const part = parts[index],
            segment = segments[index];
          if (part.startsWith(':')) posParams[part.substring(1)] = segment;
          else if (part !== segment.path) return null;
        }
        return {
          consumed: segments.slice(0, parts.length),
          posParams: posParams
        };
      }
      class LoadedRouterConfig {
        constructor(routes, module) {
          (this.routes = routes), (this.module = module);
        }
      }
      function validateConfig(config, parentPath = '') {
        for (let i = 0; i < config.length; i++) {
          const route = config[i];
          validateNode(route, getFullPath(parentPath, route));
        }
      }
      function validateNode(route, fullPath) {
        if (!route)
          throw new Error(
            `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `
          );
        if (Array.isArray(route))
          throw new Error(
            `Invalid configuration of route '${fullPath}': Array cannot be specified`
          );
        if (
          !route.component &&
          !route.children &&
          !route.loadChildren &&
          route.outlet &&
          'primary' !== route.outlet
        )
          throw new Error(
            `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`
          );
        if (route.redirectTo && route.children)
          throw new Error(
            `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`
          );
        if (route.redirectTo && route.loadChildren)
          throw new Error(
            `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`
          );
        if (route.children && route.loadChildren)
          throw new Error(
            `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`
          );
        if (route.redirectTo && route.component)
          throw new Error(
            `Invalid configuration of route '${fullPath}': redirectTo and component cannot be used together`
          );
        if (route.path && route.matcher)
          throw new Error(
            `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`
          );
        if (
          void 0 === route.redirectTo &&
          !route.component &&
          !route.children &&
          !route.loadChildren
        )
          throw new Error(
            `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, redirectTo, children or loadChildren`
          );
        if (void 0 === route.path && void 0 === route.matcher)
          throw new Error(
            `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`
          );
        if ('string' == typeof route.path && '/' === route.path.charAt(0))
          throw new Error(
            `Invalid configuration of route '${fullPath}': path cannot start with a slash`
          );
        if (
          '' === route.path &&
          void 0 !== route.redirectTo &&
          void 0 === route.pathMatch
        )
          throw new Error(
            `Invalid configuration of route '{path: "${fullPath}", redirectTo: "${route.redirectTo}"}': please provide 'pathMatch'. The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`
          );
        if (
          void 0 !== route.pathMatch &&
          'full' !== route.pathMatch &&
          'prefix' !== route.pathMatch
        )
          throw new Error(
            `Invalid configuration of route '${fullPath}': pathMatch can only be set to 'prefix' or 'full'`
          );
        route.children && validateConfig(route.children, fullPath);
      }
      function getFullPath(parentPath, currentRoute) {
        return currentRoute
          ? parentPath || currentRoute.path
            ? parentPath && !currentRoute.path
              ? parentPath + '/'
              : !parentPath && currentRoute.path
              ? currentRoute.path
              : `${parentPath}/${currentRoute.path}`
            : ''
          : parentPath;
      }
      function standardizeConfig(r) {
        const children = r.children && r.children.map(standardizeConfig),
          c = children
            ? Object.assign(Object.assign({}, r), { children: children })
            : Object.assign({}, r);
        return (
          !c.component &&
            (children || c.loadChildren) &&
            c.outlet &&
            'primary' !== c.outlet &&
            (c.component = router_EmptyOutletComponent),
          c
        );
      }
      function shallowEqual(a, b) {
        const k1 = Object.keys(a),
          k2 = Object.keys(b);
        if (!k1 || !k2 || k1.length != k2.length) return !1;
        let key;
        for (let i = 0; i < k1.length; i++)
          if (((key = k1[i]), !equalArraysOrString(a[key], b[key]))) return !1;
        return !0;
      }
      function equalArraysOrString(a, b) {
        return Array.isArray(a) && Array.isArray(b)
          ? a.length == b.length && a.every(aItem => b.indexOf(aItem) > -1)
          : a === b;
      }
      function flatten(arr) {
        return Array.prototype.concat.apply([], arr);
      }
      function router_last(a) {
        return a.length > 0 ? a[a.length - 1] : null;
      }
      function forEach(map, callback) {
        for (const prop in map)
          map.hasOwnProperty(prop) && callback(map[prop], prop);
      }
      function wrapIntoObservable(value) {
        return Object(core.ob)(value)
          ? value
          : Object(core.pb)(value)
          ? Object(from.a)(Promise.resolve(value))
          : Object(of.a)(value);
      }
      function containsTree(container, containee, exact) {
        return exact
          ? (function(container, containee) {
              return shallowEqual(container, containee);
            })(container.queryParams, containee.queryParams) &&
              (function equalSegmentGroups(container, containee) {
                if (!equalPath(container.segments, containee.segments))
                  return !1;
                if (container.numberOfChildren !== containee.numberOfChildren)
                  return !1;
                for (const c in containee.children) {
                  if (!container.children[c]) return !1;
                  if (
                    !equalSegmentGroups(
                      container.children[c],
                      containee.children[c]
                    )
                  )
                    return !1;
                }
                return !0;
              })(container.root, containee.root)
          : (function(container, containee) {
              return (
                Object.keys(containee).length <=
                  Object.keys(container).length &&
                Object.keys(containee).every(key =>
                  equalArraysOrString(container[key], containee[key])
                )
              );
            })(container.queryParams, containee.queryParams) &&
              (function containsSegmentGroup(container, containee) {
                return (function containsSegmentGroupHelper(
                  container,
                  containee,
                  containeePaths
                ) {
                  if (container.segments.length > containeePaths.length)
                    return (
                      !!equalPath(
                        container.segments.slice(0, containeePaths.length),
                        containeePaths
                      ) && !containee.hasChildren()
                    );
                  if (container.segments.length === containeePaths.length) {
                    if (!equalPath(container.segments, containeePaths))
                      return !1;
                    for (const c in containee.children) {
                      if (!container.children[c]) return !1;
                      if (
                        !containsSegmentGroup(
                          container.children[c],
                          containee.children[c]
                        )
                      )
                        return !1;
                    }
                    return !0;
                  }
                  {
                    const current = containeePaths.slice(
                        0,
                        container.segments.length
                      ),
                      next = containeePaths.slice(container.segments.length);
                    return (
                      !!equalPath(container.segments, current) &&
                      !!container.children.primary &&
                      containsSegmentGroupHelper(
                        container.children.primary,
                        containee,
                        next
                      )
                    );
                  }
                })(container, containee, containee.segments);
              })(container.root, containee.root);
      }
      class UrlTree {
        constructor(root, queryParams, fragment) {
          (this.root = root),
            (this.queryParams = queryParams),
            (this.fragment = fragment);
        }
        get queryParamMap() {
          return (
            this._queryParamMap ||
              (this._queryParamMap = convertToParamMap(this.queryParams)),
            this._queryParamMap
          );
        }
        toString() {
          return DEFAULT_SERIALIZER.serialize(this);
        }
      }
      class UrlSegmentGroup {
        constructor(segments, children) {
          (this.segments = segments),
            (this.children = children),
            (this.parent = null),
            forEach(children, (v, k) => (v.parent = this));
        }
        hasChildren() {
          return this.numberOfChildren > 0;
        }
        get numberOfChildren() {
          return Object.keys(this.children).length;
        }
        toString() {
          return serializePaths(this);
        }
      }
      class UrlSegment {
        constructor(path, parameters) {
          (this.path = path), (this.parameters = parameters);
        }
        get parameterMap() {
          return (
            this._parameterMap ||
              (this._parameterMap = convertToParamMap(this.parameters)),
            this._parameterMap
          );
        }
        toString() {
          return serializePath(this);
        }
      }
      function equalPath(as, bs) {
        return (
          as.length === bs.length && as.every((a, i) => a.path === bs[i].path)
        );
      }
      function mapChildrenIntoArray(segment, fn) {
        let res = [];
        return (
          forEach(segment.children, (child, childOutlet) => {
            'primary' === childOutlet &&
              (res = res.concat(fn(child, childOutlet)));
          }),
          forEach(segment.children, (child, childOutlet) => {
            'primary' !== childOutlet &&
              (res = res.concat(fn(child, childOutlet)));
          }),
          res
        );
      }
      class UrlSerializer {}
      class DefaultUrlSerializer {
        parse(url) {
          const p = new UrlParser(url);
          return new UrlTree(
            p.parseRootSegment(),
            p.parseQueryParams(),
            p.parseFragment()
          );
        }
        serialize(tree) {
          return `${'/' +
            (function serializeSegment(segment, root) {
              if (!segment.hasChildren()) return serializePaths(segment);
              if (root) {
                const primary = segment.children.primary
                    ? serializeSegment(segment.children.primary, !1)
                    : '',
                  children = [];
                return (
                  forEach(segment.children, (v, k) => {
                    'primary' !== k &&
                      children.push(`${k}:${serializeSegment(v, !1)}`);
                  }),
                  children.length > 0
                    ? `${primary}(${children.join('//')})`
                    : primary
                );
              }
              {
                const children = mapChildrenIntoArray(segment, (v, k) =>
                  'primary' === k
                    ? [serializeSegment(segment.children.primary, !1)]
                    : [`${k}:${serializeSegment(v, !1)}`]
                );
                return `${serializePaths(segment)}/(${children.join('//')})`;
              }
            })(tree.root, !0)}${(function(params) {
            const strParams = Object.keys(params).map(name => {
              const value = params[name];
              return Array.isArray(value)
                ? value
                    .map(v => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`)
                    .join('&')
                : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;
            });
            return strParams.length ? '?' + strParams.join('&') : '';
          })(tree.queryParams)}${
            'string' == typeof tree.fragment
              ? '#' + encodeURI(tree.fragment)
              : ''
          }`;
        }
      }
      const DEFAULT_SERIALIZER = new DefaultUrlSerializer();
      function serializePaths(segment) {
        return segment.segments.map(p => serializePath(p)).join('/');
      }
      function encodeUriString(s) {
        return encodeURIComponent(s)
          .replace(/%40/g, '@')
          .replace(/%3A/gi, ':')
          .replace(/%24/g, '$')
          .replace(/%2C/gi, ',');
      }
      function encodeUriQuery(s) {
        return encodeUriString(s).replace(/%3B/gi, ';');
      }
      function encodeUriSegment(s) {
        return encodeUriString(s)
          .replace(/\(/g, '%28')
          .replace(/\)/g, '%29')
          .replace(/%26/gi, '&');
      }
      function decode(s) {
        return decodeURIComponent(s);
      }
      function decodeQuery(s) {
        return decode(s.replace(/\+/g, '%20'));
      }
      function serializePath(path) {
        return `${encodeUriSegment(path.path)}${((params = path.parameters),
        Object.keys(params)
          .map(
            key => `;${encodeUriSegment(key)}=${encodeUriSegment(params[key])}`
          )
          .join(''))}`;
        var params;
      }
      const SEGMENT_RE = /^[^\/()?;=#]+/;
      function matchSegments(str) {
        const match = str.match(SEGMENT_RE);
        return match ? match[0] : '';
      }
      const QUERY_PARAM_RE = /^[^=?&#]+/,
        QUERY_PARAM_VALUE_RE = /^[^?&#]+/;
      class UrlParser {
        constructor(url) {
          (this.url = url), (this.remaining = url);
        }
        parseRootSegment() {
          return (
            this.consumeOptional('/'),
            '' === this.remaining ||
            this.peekStartsWith('?') ||
            this.peekStartsWith('#')
              ? new UrlSegmentGroup([], {})
              : new UrlSegmentGroup([], this.parseChildren())
          );
        }
        parseQueryParams() {
          const params = {};
          if (this.consumeOptional('?'))
            do {
              this.parseQueryParam(params);
            } while (this.consumeOptional('&'));
          return params;
        }
        parseFragment() {
          return this.consumeOptional('#')
            ? decodeURIComponent(this.remaining)
            : null;
        }
        parseChildren() {
          if ('' === this.remaining) return {};
          this.consumeOptional('/');
          const segments = [];
          for (
            this.peekStartsWith('(') || segments.push(this.parseSegment());
            this.peekStartsWith('/') &&
            !this.peekStartsWith('//') &&
            !this.peekStartsWith('/(');

          )
            this.capture('/'), segments.push(this.parseSegment());
          let children = {};
          this.peekStartsWith('/(') &&
            (this.capture('/'), (children = this.parseParens(!0)));
          let res = {};
          return (
            this.peekStartsWith('(') && (res = this.parseParens(!1)),
            (segments.length > 0 || Object.keys(children).length > 0) &&
              (res.primary = new UrlSegmentGroup(segments, children)),
            res
          );
        }
        parseSegment() {
          const path = matchSegments(this.remaining);
          if ('' === path && this.peekStartsWith(';'))
            throw new Error(
              `Empty path url segment cannot have parameters: '${this.remaining}'.`
            );
          return (
            this.capture(path),
            new UrlSegment(decode(path), this.parseMatrixParams())
          );
        }
        parseMatrixParams() {
          const params = {};
          for (; this.consumeOptional(';'); ) this.parseParam(params);
          return params;
        }
        parseParam(params) {
          const key = matchSegments(this.remaining);
          if (!key) return;
          this.capture(key);
          let value = '';
          if (this.consumeOptional('=')) {
            const valueMatch = matchSegments(this.remaining);
            valueMatch && ((value = valueMatch), this.capture(value));
          }
          params[decode(key)] = decode(value);
        }
        parseQueryParam(params) {
          const key = (function(str) {
            const match = str.match(QUERY_PARAM_RE);
            return match ? match[0] : '';
          })(this.remaining);
          if (!key) return;
          this.capture(key);
          let value = '';
          if (this.consumeOptional('=')) {
            const valueMatch = (function(str) {
              const match = str.match(QUERY_PARAM_VALUE_RE);
              return match ? match[0] : '';
            })(this.remaining);
            valueMatch && ((value = valueMatch), this.capture(value));
          }
          const decodedKey = decodeQuery(key),
            decodedVal = decodeQuery(value);
          if (params.hasOwnProperty(decodedKey)) {
            let currentVal = params[decodedKey];
            Array.isArray(currentVal) ||
              ((currentVal = [currentVal]), (params[decodedKey] = currentVal)),
              currentVal.push(decodedVal);
          } else params[decodedKey] = decodedVal;
        }
        parseParens(allowPrimary) {
          const segments = {};
          for (
            this.capture('(');
            !this.consumeOptional(')') && this.remaining.length > 0;

          ) {
            const path = matchSegments(this.remaining),
              next = this.remaining[path.length];
            if ('/' !== next && ')' !== next && ';' !== next)
              throw new Error(`Cannot parse url '${this.url}'`);
            let outletName = void 0;
            path.indexOf(':') > -1
              ? ((outletName = path.substr(0, path.indexOf(':'))),
                this.capture(outletName),
                this.capture(':'))
              : allowPrimary && (outletName = 'primary');
            const children = this.parseChildren();
            (segments[outletName] =
              1 === Object.keys(children).length
                ? children.primary
                : new UrlSegmentGroup([], children)),
              this.consumeOptional('//');
          }
          return segments;
        }
        peekStartsWith(str) {
          return this.remaining.startsWith(str);
        }
        consumeOptional(str) {
          return (
            !!this.peekStartsWith(str) &&
            ((this.remaining = this.remaining.substring(str.length)), !0)
          );
        }
        capture(str) {
          if (!this.consumeOptional(str)) throw new Error(`Expected "${str}".`);
        }
      }
      class Tree {
        constructor(root) {
          this._root = root;
        }
        get root() {
          return this._root.value;
        }
        parent(t) {
          const p = this.pathFromRoot(t);
          return p.length > 1 ? p[p.length - 2] : null;
        }
        children(t) {
          const n = findNode(t, this._root);
          return n ? n.children.map(t => t.value) : [];
        }
        firstChild(t) {
          const n = findNode(t, this._root);
          return n && n.children.length > 0 ? n.children[0].value : null;
        }
        siblings(t) {
          const p = findPath(t, this._root);
          return p.length < 2
            ? []
            : p[p.length - 2].children.map(c => c.value).filter(cc => cc !== t);
        }
        pathFromRoot(t) {
          return findPath(t, this._root).map(s => s.value);
        }
      }
      function findNode(value, node) {
        if (value === node.value) return node;
        for (const child of node.children) {
          const node = findNode(value, child);
          if (node) return node;
        }
        return null;
      }
      function findPath(value, node) {
        if (value === node.value) return [node];
        for (const child of node.children) {
          const path = findPath(value, child);
          if (path.length) return path.unshift(node), path;
        }
        return [];
      }
      class TreeNode {
        constructor(value, children) {
          (this.value = value), (this.children = children);
        }
        toString() {
          return `TreeNode(${this.value})`;
        }
      }
      function nodeChildrenAsMap(node) {
        const map = {};
        return (
          node &&
            node.children.forEach(child => (map[child.value.outlet] = child)),
          map
        );
      }
      class RouterState extends Tree {
        constructor(root, snapshot) {
          super(root), (this.snapshot = snapshot), setRouterState(this, root);
        }
        toString() {
          return this.snapshot.toString();
        }
      }
      function createEmptyState(urlTree, rootComponent) {
        const snapshot = (function(urlTree, rootComponent) {
            const activated = new ActivatedRouteSnapshot(
              [],
              {},
              {},
              '',
              {},
              'primary',
              rootComponent,
              null,
              urlTree.root,
              -1,
              {}
            );
            return new RouterStateSnapshot('', new TreeNode(activated, []));
          })(urlTree, rootComponent),
          emptyUrl = new BehaviorSubject.a([new UrlSegment('', {})]),
          emptyParams = new BehaviorSubject.a({}),
          emptyData = new BehaviorSubject.a({}),
          emptyQueryParams = new BehaviorSubject.a({}),
          fragment = new BehaviorSubject.a(''),
          activated = new router_ActivatedRoute(
            emptyUrl,
            emptyParams,
            emptyQueryParams,
            fragment,
            emptyData,
            'primary',
            rootComponent,
            snapshot.root
          );
        return (
          (activated.snapshot = snapshot.root),
          new RouterState(new TreeNode(activated, []), snapshot)
        );
      }
      class router_ActivatedRoute {
        constructor(
          url,
          params,
          queryParams,
          fragment,
          data,
          outlet,
          component,
          futureSnapshot
        ) {
          (this.url = url),
            (this.params = params),
            (this.queryParams = queryParams),
            (this.fragment = fragment),
            (this.data = data),
            (this.outlet = outlet),
            (this.component = component),
            (this._futureSnapshot = futureSnapshot);
        }
        get routeConfig() {
          return this._futureSnapshot.routeConfig;
        }
        get root() {
          return this._routerState.root;
        }
        get parent() {
          return this._routerState.parent(this);
        }
        get firstChild() {
          return this._routerState.firstChild(this);
        }
        get children() {
          return this._routerState.children(this);
        }
        get pathFromRoot() {
          return this._routerState.pathFromRoot(this);
        }
        get paramMap() {
          return (
            this._paramMap ||
              (this._paramMap = this.params.pipe(
                Object(map.a)(p => convertToParamMap(p))
              )),
            this._paramMap
          );
        }
        get queryParamMap() {
          return (
            this._queryParamMap ||
              (this._queryParamMap = this.queryParams.pipe(
                Object(map.a)(p => convertToParamMap(p))
              )),
            this._queryParamMap
          );
        }
        toString() {
          return this.snapshot
            ? this.snapshot.toString()
            : `Future(${this._futureSnapshot})`;
        }
      }
      function inheritedParamsDataResolve(
        route,
        paramsInheritanceStrategy = 'emptyOnly'
      ) {
        const pathFromRoot = route.pathFromRoot;
        let inheritingStartingFrom = 0;
        if ('always' !== paramsInheritanceStrategy)
          for (
            inheritingStartingFrom = pathFromRoot.length - 1;
            inheritingStartingFrom >= 1;

          ) {
            const current = pathFromRoot[inheritingStartingFrom],
              parent = pathFromRoot[inheritingStartingFrom - 1];
            if (current.routeConfig && '' === current.routeConfig.path)
              inheritingStartingFrom--;
            else {
              if (parent.component) break;
              inheritingStartingFrom--;
            }
          }
        return (function(pathFromRoot) {
          return pathFromRoot.reduce(
            (res, curr) => ({
              params: Object.assign(Object.assign({}, res.params), curr.params),
              data: Object.assign(Object.assign({}, res.data), curr.data),
              resolve: Object.assign(
                Object.assign({}, res.resolve),
                curr._resolvedData
              )
            }),
            { params: {}, data: {}, resolve: {} }
          );
        })(pathFromRoot.slice(inheritingStartingFrom));
      }
      class ActivatedRouteSnapshot {
        constructor(
          url,
          params,
          queryParams,
          fragment,
          data,
          outlet,
          component,
          routeConfig,
          urlSegment,
          lastPathIndex,
          resolve
        ) {
          (this.url = url),
            (this.params = params),
            (this.queryParams = queryParams),
            (this.fragment = fragment),
            (this.data = data),
            (this.outlet = outlet),
            (this.component = component),
            (this.routeConfig = routeConfig),
            (this._urlSegment = urlSegment),
            (this._lastPathIndex = lastPathIndex),
            (this._resolve = resolve);
        }
        get root() {
          return this._routerState.root;
        }
        get parent() {
          return this._routerState.parent(this);
        }
        get firstChild() {
          return this._routerState.firstChild(this);
        }
        get children() {
          return this._routerState.children(this);
        }
        get pathFromRoot() {
          return this._routerState.pathFromRoot(this);
        }
        get paramMap() {
          return (
            this._paramMap || (this._paramMap = convertToParamMap(this.params)),
            this._paramMap
          );
        }
        get queryParamMap() {
          return (
            this._queryParamMap ||
              (this._queryParamMap = convertToParamMap(this.queryParams)),
            this._queryParamMap
          );
        }
        toString() {
          return `Route(url:'${this.url
            .map(segment => segment.toString())
            .join('/')}', path:'${
            this.routeConfig ? this.routeConfig.path : ''
          }')`;
        }
      }
      class RouterStateSnapshot extends Tree {
        constructor(url, root) {
          super(root), (this.url = url), setRouterState(this, root);
        }
        toString() {
          return serializeNode(this._root);
        }
      }
      function setRouterState(state, node) {
        (node.value._routerState = state),
          node.children.forEach(c => setRouterState(state, c));
      }
      function serializeNode(node) {
        const c =
          node.children.length > 0
            ? ` { ${node.children.map(serializeNode).join(', ')} } `
            : '';
        return `${node.value}${c}`;
      }
      function advanceActivatedRoute(route) {
        if (route.snapshot) {
          const currentSnapshot = route.snapshot,
            nextSnapshot = route._futureSnapshot;
          (route.snapshot = nextSnapshot),
            shallowEqual(
              currentSnapshot.queryParams,
              nextSnapshot.queryParams
            ) || route.queryParams.next(nextSnapshot.queryParams),
            currentSnapshot.fragment !== nextSnapshot.fragment &&
              route.fragment.next(nextSnapshot.fragment),
            shallowEqual(currentSnapshot.params, nextSnapshot.params) ||
              route.params.next(nextSnapshot.params),
            (function(a, b) {
              if (a.length !== b.length) return !1;
              for (let i = 0; i < a.length; ++i)
                if (!shallowEqual(a[i], b[i])) return !1;
              return !0;
            })(currentSnapshot.url, nextSnapshot.url) ||
              route.url.next(nextSnapshot.url),
            shallowEqual(currentSnapshot.data, nextSnapshot.data) ||
              route.data.next(nextSnapshot.data);
        } else
          (route.snapshot = route._futureSnapshot),
            route.data.next(route._futureSnapshot.data);
      }
      function equalParamsAndUrlSegments(a, b) {
        var as, bs;
        return (
          shallowEqual(a.params, b.params) &&
          equalPath((as = a.url), (bs = b.url)) &&
          as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters)) &&
          !(!a.parent != !b.parent) &&
          (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent))
        );
      }
      function isMatrixParams(command) {
        return (
          'object' == typeof command &&
          null != command &&
          !command.outlets &&
          !command.segmentPath
        );
      }
      function router_tree(
        oldSegmentGroup,
        newSegmentGroup,
        urlTree,
        queryParams,
        fragment
      ) {
        let qp = {};
        return (
          queryParams &&
            forEach(queryParams, (value, name) => {
              qp[name] = Array.isArray(value)
                ? value.map(v => '' + v)
                : '' + value;
            }),
          new UrlTree(
            urlTree.root === oldSegmentGroup
              ? newSegmentGroup
              : (function replaceSegment(current, oldSegment, newSegment) {
                  const children = {};
                  return (
                    forEach(current.children, (c, outletName) => {
                      children[outletName] =
                        c === oldSegment
                          ? newSegment
                          : replaceSegment(c, oldSegment, newSegment);
                    }),
                    new UrlSegmentGroup(current.segments, children)
                  );
                })(urlTree.root, oldSegmentGroup, newSegmentGroup),
            qp,
            fragment
          )
        );
      }
      class Navigation {
        constructor(isAbsolute, numberOfDoubleDots, commands) {
          if (
            ((this.isAbsolute = isAbsolute),
            (this.numberOfDoubleDots = numberOfDoubleDots),
            (this.commands = commands),
            isAbsolute && commands.length > 0 && isMatrixParams(commands[0]))
          )
            throw new Error('Root segment cannot have matrix parameters');
          const cmdWithOutlet = commands.find(
            c => 'object' == typeof c && null != c && c.outlets
          );
          if (cmdWithOutlet && cmdWithOutlet !== router_last(commands))
            throw new Error('{outlets:{}} has to be the last command');
        }
        toRoot() {
          return (
            this.isAbsolute &&
            1 === this.commands.length &&
            '/' == this.commands[0]
          );
        }
      }
      class Position {
        constructor(segmentGroup, processChildren, index) {
          (this.segmentGroup = segmentGroup),
            (this.processChildren = processChildren),
            (this.index = index);
        }
      }
      function getPath(command) {
        return 'object' == typeof command && null != command && command.outlets
          ? command.outlets.primary
          : '' + command;
      }
      function updateSegmentGroup(segmentGroup, startIndex, commands) {
        if (
          (segmentGroup || (segmentGroup = new UrlSegmentGroup([], {})),
          0 === segmentGroup.segments.length && segmentGroup.hasChildren())
        )
          return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
        const m = (function(segmentGroup, startIndex, commands) {
            let currentCommandIndex = 0,
              currentPathIndex = startIndex;
            const noMatch = { match: !1, pathIndex: 0, commandIndex: 0 };
            for (; currentPathIndex < segmentGroup.segments.length; ) {
              if (currentCommandIndex >= commands.length) return noMatch;
              const path = segmentGroup.segments[currentPathIndex],
                curr = getPath(commands[currentCommandIndex]),
                next =
                  currentCommandIndex < commands.length - 1
                    ? commands[currentCommandIndex + 1]
                    : null;
              if (currentPathIndex > 0 && void 0 === curr) break;
              if (
                curr &&
                next &&
                'object' == typeof next &&
                void 0 === next.outlets
              ) {
                if (!compare(curr, next, path)) return noMatch;
                currentCommandIndex += 2;
              } else {
                if (!compare(curr, {}, path)) return noMatch;
                currentCommandIndex++;
              }
              currentPathIndex++;
            }
            return {
              match: !0,
              pathIndex: currentPathIndex,
              commandIndex: currentCommandIndex
            };
          })(segmentGroup, startIndex, commands),
          slicedCommands = commands.slice(m.commandIndex);
        if (m.match && m.pathIndex < segmentGroup.segments.length) {
          const g = new UrlSegmentGroup(
            segmentGroup.segments.slice(0, m.pathIndex),
            {}
          );
          return (
            (g.children.primary = new UrlSegmentGroup(
              segmentGroup.segments.slice(m.pathIndex),
              segmentGroup.children
            )),
            updateSegmentGroupChildren(g, 0, slicedCommands)
          );
        }
        return m.match && 0 === slicedCommands.length
          ? new UrlSegmentGroup(segmentGroup.segments, {})
          : m.match && !segmentGroup.hasChildren()
          ? createNewSegmentGroup(segmentGroup, startIndex, commands)
          : m.match
          ? updateSegmentGroupChildren(segmentGroup, 0, slicedCommands)
          : createNewSegmentGroup(segmentGroup, startIndex, commands);
      }
      function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
        if (0 === commands.length)
          return new UrlSegmentGroup(segmentGroup.segments, {});
        {
          const outlets = (function(commands) {
              return 'object' == typeof commands[0] &&
                null !== commands[0] &&
                commands[0].outlets
                ? commands[0].outlets
                : { primary: commands };
            })(commands),
            children = {};
          return (
            forEach(outlets, (commands, outlet) => {
              null !== commands &&
                (children[outlet] = updateSegmentGroup(
                  segmentGroup.children[outlet],
                  startIndex,
                  commands
                ));
            }),
            forEach(segmentGroup.children, (child, childOutlet) => {
              void 0 === outlets[childOutlet] &&
                (children[childOutlet] = child);
            }),
            new UrlSegmentGroup(segmentGroup.segments, children)
          );
        }
      }
      function createNewSegmentGroup(segmentGroup, startIndex, commands) {
        const paths = segmentGroup.segments.slice(0, startIndex);
        let i = 0;
        for (; i < commands.length; ) {
          if (
            'object' == typeof commands[i] &&
            null !== commands[i] &&
            void 0 !== commands[i].outlets
          ) {
            const children = createNewSegmentChildren(commands[i].outlets);
            return new UrlSegmentGroup(paths, children);
          }
          if (0 === i && isMatrixParams(commands[0])) {
            paths.push(
              new UrlSegment(
                segmentGroup.segments[startIndex].path,
                commands[0]
              )
            ),
              i++;
            continue;
          }
          const curr = getPath(commands[i]),
            next = i < commands.length - 1 ? commands[i + 1] : null;
          curr && next && isMatrixParams(next)
            ? (paths.push(new UrlSegment(curr, stringify(next))), (i += 2))
            : (paths.push(new UrlSegment(curr, {})), i++);
        }
        return new UrlSegmentGroup(paths, {});
      }
      function createNewSegmentChildren(outlets) {
        const children = {};
        return (
          forEach(outlets, (commands, outlet) => {
            null !== commands &&
              (children[outlet] = createNewSegmentGroup(
                new UrlSegmentGroup([], {}),
                0,
                commands
              ));
          }),
          children
        );
      }
      function stringify(params) {
        const res = {};
        return forEach(params, (v, k) => (res[k] = '' + v)), res;
      }
      function compare(path, params, segment) {
        return path == segment.path && shallowEqual(params, segment.parameters);
      }
      class ActivateRoutes {
        constructor(routeReuseStrategy, futureState, currState, forwardEvent) {
          (this.routeReuseStrategy = routeReuseStrategy),
            (this.futureState = futureState),
            (this.currState = currState),
            (this.forwardEvent = forwardEvent);
        }
        activate(parentContexts) {
          const futureRoot = this.futureState._root,
            currRoot = this.currState ? this.currState._root : null;
          this.deactivateChildRoutes(futureRoot, currRoot, parentContexts),
            advanceActivatedRoute(this.futureState.root),
            this.activateChildRoutes(futureRoot, currRoot, parentContexts);
        }
        deactivateChildRoutes(futureNode, currNode, contexts) {
          const children = nodeChildrenAsMap(currNode);
          futureNode.children.forEach(futureChild => {
            const childOutletName = futureChild.value.outlet;
            this.deactivateRoutes(
              futureChild,
              children[childOutletName],
              contexts
            ),
              delete children[childOutletName];
          }),
            forEach(children, (v, childName) => {
              this.deactivateRouteAndItsChildren(v, contexts);
            });
        }
        deactivateRoutes(futureNode, currNode, parentContext) {
          const future = futureNode.value,
            curr = currNode ? currNode.value : null;
          if (future === curr)
            if (future.component) {
              const context = parentContext.getContext(future.outlet);
              context &&
                this.deactivateChildRoutes(
                  futureNode,
                  currNode,
                  context.children
                );
            } else
              this.deactivateChildRoutes(futureNode, currNode, parentContext);
          else
            curr && this.deactivateRouteAndItsChildren(currNode, parentContext);
        }
        deactivateRouteAndItsChildren(route, parentContexts) {
          this.routeReuseStrategy.shouldDetach(route.value.snapshot)
            ? this.detachAndStoreRouteSubtree(route, parentContexts)
            : this.deactivateRouteAndOutlet(route, parentContexts);
        }
        detachAndStoreRouteSubtree(route, parentContexts) {
          const context = parentContexts.getContext(route.value.outlet);
          if (context && context.outlet) {
            const componentRef = context.outlet.detach(),
              contexts = context.children.onOutletDeactivated();
            this.routeReuseStrategy.store(route.value.snapshot, {
              componentRef: componentRef,
              route: route,
              contexts: contexts
            });
          }
        }
        deactivateRouteAndOutlet(route, parentContexts) {
          const context = parentContexts.getContext(route.value.outlet);
          if (context) {
            const children = nodeChildrenAsMap(route),
              contexts = route.value.component
                ? context.children
                : parentContexts;
            forEach(children, (v, k) =>
              this.deactivateRouteAndItsChildren(v, contexts)
            ),
              context.outlet &&
                (context.outlet.deactivate(),
                context.children.onOutletDeactivated());
          }
        }
        activateChildRoutes(futureNode, currNode, contexts) {
          const children = nodeChildrenAsMap(currNode);
          futureNode.children.forEach(c => {
            this.activateRoutes(c, children[c.value.outlet], contexts),
              this.forwardEvent(new ActivationEnd(c.value.snapshot));
          }),
            futureNode.children.length &&
              this.forwardEvent(
                new ChildActivationEnd(futureNode.value.snapshot)
              );
        }
        activateRoutes(futureNode, currNode, parentContexts) {
          const future = futureNode.value,
            curr = currNode ? currNode.value : null;
          if ((advanceActivatedRoute(future), future === curr))
            if (future.component) {
              const context = parentContexts.getOrCreateContext(future.outlet);
              this.activateChildRoutes(futureNode, currNode, context.children);
            } else
              this.activateChildRoutes(futureNode, currNode, parentContexts);
          else if (future.component) {
            const context = parentContexts.getOrCreateContext(future.outlet);
            if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
              const stored = this.routeReuseStrategy.retrieve(future.snapshot);
              this.routeReuseStrategy.store(future.snapshot, null),
                context.children.onOutletReAttached(stored.contexts),
                (context.attachRef = stored.componentRef),
                (context.route = stored.route.value),
                context.outlet &&
                  context.outlet.attach(
                    stored.componentRef,
                    stored.route.value
                  ),
                advanceActivatedRouteNodeAndItsChildren(stored.route);
            } else {
              const config = (function(snapshot) {
                  for (let s = snapshot.parent; s; s = s.parent) {
                    const route = s.routeConfig;
                    if (route && route._loadedConfig)
                      return route._loadedConfig;
                    if (route && route.component) return null;
                  }
                  return null;
                })(future.snapshot),
                cmpFactoryResolver = config
                  ? config.module.componentFactoryResolver
                  : null;
              (context.attachRef = null),
                (context.route = future),
                (context.resolver = cmpFactoryResolver),
                context.outlet &&
                  context.outlet.activateWith(future, cmpFactoryResolver),
                this.activateChildRoutes(futureNode, null, context.children);
            }
          } else this.activateChildRoutes(futureNode, null, parentContexts);
        }
      }
      function advanceActivatedRouteNodeAndItsChildren(node) {
        advanceActivatedRoute(node.value),
          node.children.forEach(advanceActivatedRouteNodeAndItsChildren);
      }
      function isFunction(v) {
        return 'function' == typeof v;
      }
      function isUrlTree(v) {
        return v instanceof UrlTree;
      }
      class NoMatch {
        constructor(segmentGroup) {
          this.segmentGroup = segmentGroup || null;
        }
      }
      class AbsoluteRedirect {
        constructor(urlTree) {
          this.urlTree = urlTree;
        }
      }
      function noMatch(segmentGroup) {
        return new Observable.a(obs => obs.error(new NoMatch(segmentGroup)));
      }
      function absoluteRedirect(newTree) {
        return new Observable.a(obs =>
          obs.error(new AbsoluteRedirect(newTree))
        );
      }
      function namedOutletsRedirect(redirectTo) {
        return new Observable.a(obs =>
          obs.error(
            new Error(
              `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`
            )
          )
        );
      }
      class router_ApplyRedirects {
        constructor(
          moduleInjector,
          configLoader,
          urlSerializer,
          urlTree,
          config
        ) {
          (this.configLoader = configLoader),
            (this.urlSerializer = urlSerializer),
            (this.urlTree = urlTree),
            (this.config = config),
            (this.allowRedirects = !0),
            (this.ngModule = moduleInjector.get(core.x));
        }
        apply() {
          return this.expandSegmentGroup(
            this.ngModule,
            this.config,
            this.urlTree.root,
            'primary'
          )
            .pipe(
              Object(map.a)(rootSegmentGroup =>
                this.createUrlTree(
                  rootSegmentGroup,
                  this.urlTree.queryParams,
                  this.urlTree.fragment
                )
              )
            )
            .pipe(
              Object(catchError.a)(e => {
                if (e instanceof AbsoluteRedirect)
                  return (this.allowRedirects = !1), this.match(e.urlTree);
                if (e instanceof NoMatch) throw this.noMatchError(e);
                throw e;
              })
            );
        }
        match(tree) {
          return this.expandSegmentGroup(
            this.ngModule,
            this.config,
            tree.root,
            'primary'
          )
            .pipe(
              Object(map.a)(rootSegmentGroup =>
                this.createUrlTree(
                  rootSegmentGroup,
                  tree.queryParams,
                  tree.fragment
                )
              )
            )
            .pipe(
              Object(catchError.a)(e => {
                if (e instanceof NoMatch) throw this.noMatchError(e);
                throw e;
              })
            );
        }
        noMatchError(e) {
          return new Error(
            `Cannot match any routes. URL Segment: '${e.segmentGroup}'`
          );
        }
        createUrlTree(rootCandidate, queryParams, fragment) {
          const root =
            rootCandidate.segments.length > 0
              ? new UrlSegmentGroup([], { primary: rootCandidate })
              : rootCandidate;
          return new UrlTree(root, queryParams, fragment);
        }
        expandSegmentGroup(ngModule, routes, segmentGroup, outlet) {
          return 0 === segmentGroup.segments.length &&
            segmentGroup.hasChildren()
            ? this.expandChildren(ngModule, routes, segmentGroup).pipe(
                Object(map.a)(children => new UrlSegmentGroup([], children))
              )
            : this.expandSegment(
                ngModule,
                segmentGroup,
                routes,
                segmentGroup.segments,
                outlet,
                !0
              );
        }
        expandChildren(ngModule, routes, segmentGroup) {
          return (function(obj, fn) {
            if (0 === Object.keys(obj).length) return Object(of.a)({});
            const waitHead = [],
              waitTail = [],
              res = {};
            return (
              forEach(obj, (a, k) => {
                const mapped = fn(k, a).pipe(Object(map.a)(r => (res[k] = r)));
                'primary' === k ? waitHead.push(mapped) : waitTail.push(mapped);
              }),
              of.a.apply(null, waitHead.concat(waitTail)).pipe(
                Object(concatAll.a)(),
                (function(predicate, defaultValue) {
                  const hasDefaultValue = arguments.length >= 2;
                  return source =>
                    source.pipe(
                      predicate
                        ? Object(filter.a)((v, i) => predicate(v, i, source))
                        : identity.a,
                      Object(takeLast.a)(1),
                      hasDefaultValue
                        ? Object(defaultIfEmpty.a)(defaultValue)
                        : throwIfEmpty(() => new EmptyError())
                    );
                })(),
                Object(map.a)(() => res)
              )
            );
          })(segmentGroup.children, (childOutlet, child) =>
            this.expandSegmentGroup(ngModule, routes, child, childOutlet)
          );
        }
        expandSegment(
          ngModule,
          segmentGroup,
          routes,
          segments,
          outlet,
          allowRedirects
        ) {
          return Object(of.a)(...routes).pipe(
            Object(map.a)(r =>
              this.expandSegmentAgainstRoute(
                ngModule,
                segmentGroup,
                routes,
                r,
                segments,
                outlet,
                allowRedirects
              ).pipe(
                Object(catchError.a)(e => {
                  if (e instanceof NoMatch) return Object(of.a)(null);
                  throw e;
                })
              )
            ),
            Object(concatAll.a)(),
            first(s => !!s),
            Object(catchError.a)((e, _) => {
              if (e instanceof EmptyError || 'EmptyError' === e.name) {
                if (this.noLeftoversInUrl(segmentGroup, segments, outlet))
                  return Object(of.a)(new UrlSegmentGroup([], {}));
                throw new NoMatch(segmentGroup);
              }
              throw e;
            })
          );
        }
        noLeftoversInUrl(segmentGroup, segments, outlet) {
          return 0 === segments.length && !segmentGroup.children[outlet];
        }
        expandSegmentAgainstRoute(
          ngModule,
          segmentGroup,
          routes,
          route,
          paths,
          outlet,
          allowRedirects
        ) {
          return getOutlet(route) !== outlet
            ? noMatch(segmentGroup)
            : void 0 === route.redirectTo
            ? this.matchSegmentAgainstRoute(
                ngModule,
                segmentGroup,
                route,
                paths
              )
            : allowRedirects && this.allowRedirects
            ? this.expandSegmentAgainstRouteUsingRedirect(
                ngModule,
                segmentGroup,
                routes,
                route,
                paths,
                outlet
              )
            : noMatch(segmentGroup);
        }
        expandSegmentAgainstRouteUsingRedirect(
          ngModule,
          segmentGroup,
          routes,
          route,
          segments,
          outlet
        ) {
          return '**' === route.path
            ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(
                ngModule,
                routes,
                route,
                outlet
              )
            : this.expandRegularSegmentAgainstRouteUsingRedirect(
                ngModule,
                segmentGroup,
                routes,
                route,
                segments,
                outlet
              );
        }
        expandWildCardWithParamsAgainstRouteUsingRedirect(
          ngModule,
          routes,
          route,
          outlet
        ) {
          const newTree = this.applyRedirectCommands([], route.redirectTo, {});
          return route.redirectTo.startsWith('/')
            ? absoluteRedirect(newTree)
            : this.lineralizeSegments(route, newTree).pipe(
                Object(mergeMap.a)(newSegments => {
                  const group = new UrlSegmentGroup(newSegments, {});
                  return this.expandSegment(
                    ngModule,
                    group,
                    routes,
                    newSegments,
                    outlet,
                    !1
                  );
                })
              );
        }
        expandRegularSegmentAgainstRouteUsingRedirect(
          ngModule,
          segmentGroup,
          routes,
          route,
          segments,
          outlet
        ) {
          const {
            matched: matched,
            consumedSegments: consumedSegments,
            lastChild: lastChild,
            positionalParamSegments: positionalParamSegments
          } = match(segmentGroup, route, segments);
          if (!matched) return noMatch(segmentGroup);
          const newTree = this.applyRedirectCommands(
            consumedSegments,
            route.redirectTo,
            positionalParamSegments
          );
          return route.redirectTo.startsWith('/')
            ? absoluteRedirect(newTree)
            : this.lineralizeSegments(route, newTree).pipe(
                Object(mergeMap.a)(newSegments =>
                  this.expandSegment(
                    ngModule,
                    segmentGroup,
                    routes,
                    newSegments.concat(segments.slice(lastChild)),
                    outlet,
                    !1
                  )
                )
              );
        }
        matchSegmentAgainstRoute(ngModule, rawSegmentGroup, route, segments) {
          if ('**' === route.path)
            return route.loadChildren
              ? this.configLoader
                  .load(ngModule.injector, route)
                  .pipe(
                    Object(map.a)(
                      cfg => (
                        (route._loadedConfig = cfg),
                        new UrlSegmentGroup(segments, {})
                      )
                    )
                  )
              : Object(of.a)(new UrlSegmentGroup(segments, {}));
          const {
            matched: matched,
            consumedSegments: consumedSegments,
            lastChild: lastChild
          } = match(rawSegmentGroup, route, segments);
          if (!matched) return noMatch(rawSegmentGroup);
          const rawSlicedSegments = segments.slice(lastChild);
          return this.getChildConfig(ngModule, route, segments).pipe(
            Object(mergeMap.a)(routerConfig => {
              const childModule = routerConfig.module,
                childConfig = routerConfig.routes,
                {
                  segmentGroup: segmentGroup,
                  slicedSegments: slicedSegments
                } = (function(
                  segmentGroup,
                  consumedSegments,
                  slicedSegments,
                  config
                ) {
                  return slicedSegments.length > 0 &&
                    (function(segmentGroup, segments, routes) {
                      return routes.some(
                        r =>
                          isEmptyPathRedirect(segmentGroup, segments, r) &&
                          'primary' !== getOutlet(r)
                      );
                    })(segmentGroup, slicedSegments, config)
                    ? {
                        segmentGroup: mergeTrivialChildren(
                          new UrlSegmentGroup(
                            consumedSegments,
                            (function(routes, primarySegmentGroup) {
                              const res = {};
                              res.primary = primarySegmentGroup;
                              for (const r of routes)
                                '' === r.path &&
                                  'primary' !== getOutlet(r) &&
                                  (res[getOutlet(r)] = new UrlSegmentGroup(
                                    [],
                                    {}
                                  ));
                              return res;
                            })(
                              config,
                              new UrlSegmentGroup(
                                slicedSegments,
                                segmentGroup.children
                              )
                            )
                          )
                        ),
                        slicedSegments: []
                      }
                    : 0 === slicedSegments.length &&
                      (function(segmentGroup, segments, routes) {
                        return routes.some(r =>
                          isEmptyPathRedirect(segmentGroup, segments, r)
                        );
                      })(segmentGroup, slicedSegments, config)
                    ? {
                        segmentGroup: mergeTrivialChildren(
                          new UrlSegmentGroup(
                            segmentGroup.segments,
                            (function(
                              segmentGroup,
                              slicedSegments,
                              routes,
                              children
                            ) {
                              const res = {};
                              for (const r of routes)
                                isEmptyPathRedirect(
                                  segmentGroup,
                                  slicedSegments,
                                  r
                                ) &&
                                  !children[getOutlet(r)] &&
                                  (res[getOutlet(r)] = new UrlSegmentGroup(
                                    [],
                                    {}
                                  ));
                              return Object.assign(
                                Object.assign({}, children),
                                res
                              );
                            })(
                              segmentGroup,
                              slicedSegments,
                              config,
                              segmentGroup.children
                            )
                          )
                        ),
                        slicedSegments: slicedSegments
                      }
                    : {
                        segmentGroup: segmentGroup,
                        slicedSegments: slicedSegments
                      };
                })(
                  rawSegmentGroup,
                  consumedSegments,
                  rawSlicedSegments,
                  childConfig
                );
              return 0 === slicedSegments.length && segmentGroup.hasChildren()
                ? this.expandChildren(
                    childModule,
                    childConfig,
                    segmentGroup
                  ).pipe(
                    Object(map.a)(
                      children =>
                        new UrlSegmentGroup(consumedSegments, children)
                    )
                  )
                : 0 === childConfig.length && 0 === slicedSegments.length
                ? Object(of.a)(new UrlSegmentGroup(consumedSegments, {}))
                : this.expandSegment(
                    childModule,
                    segmentGroup,
                    childConfig,
                    slicedSegments,
                    'primary',
                    !0
                  ).pipe(
                    Object(map.a)(
                      cs =>
                        new UrlSegmentGroup(
                          consumedSegments.concat(cs.segments),
                          cs.children
                        )
                    )
                  );
            })
          );
        }
        getChildConfig(ngModule, route, segments) {
          return route.children
            ? Object(of.a)(new LoadedRouterConfig(route.children, ngModule))
            : route.loadChildren
            ? void 0 !== route._loadedConfig
              ? Object(of.a)(route._loadedConfig)
              : this.runCanLoadGuards(ngModule.injector, route, segments).pipe(
                  Object(mergeMap.a)(shouldLoadResult =>
                    shouldLoadResult
                      ? this.configLoader
                          .load(ngModule.injector, route)
                          .pipe(
                            Object(map.a)(
                              cfg => ((route._loadedConfig = cfg), cfg)
                            )
                          )
                      : (function(route) {
                          return new Observable.a(obs =>
                            obs.error(
                              navigationCancelingError(
                                `Cannot load children because the guard of the route "path: '${route.path}'" returned false`
                              )
                            )
                          );
                        })(route)
                  )
                )
            : Object(of.a)(new LoadedRouterConfig([], ngModule));
        }
        runCanLoadGuards(moduleInjector, route, segments) {
          const canLoad = route.canLoad;
          return canLoad && 0 !== canLoad.length
            ? Object(from.a)(canLoad)
                .pipe(
                  Object(map.a)(injectionToken => {
                    const guard = moduleInjector.get(injectionToken);
                    let guardVal;
                    if (
                      (function(guard) {
                        return guard && isFunction(guard.canLoad);
                      })(guard)
                    )
                      guardVal = guard.canLoad(route, segments);
                    else {
                      if (!isFunction(guard))
                        throw new Error('Invalid CanLoad guard');
                      guardVal = guard(route, segments);
                    }
                    return wrapIntoObservable(guardVal);
                  })
                )
                .pipe(
                  Object(concatAll.a)(),
                  Object(tap.a)(result => {
                    if (!isUrlTree(result)) return;
                    const error = navigationCancelingError(
                      `Redirecting to "${this.urlSerializer.serialize(result)}"`
                    );
                    throw ((error.url = result), error);
                  }),
                  ((predicate = result => !0 === result),
                  source =>
                    source.lift(new EveryOperator(predicate, void 0, source)))
                )
            : Object(of.a)(!0);
          var predicate;
        }
        lineralizeSegments(route, urlTree) {
          let res = [],
            c = urlTree.root;
          for (;;) {
            if (((res = res.concat(c.segments)), 0 === c.numberOfChildren))
              return Object(of.a)(res);
            if (c.numberOfChildren > 1 || !c.children.primary)
              return namedOutletsRedirect(route.redirectTo);
            c = c.children.primary;
          }
        }
        applyRedirectCommands(segments, redirectTo, posParams) {
          return this.applyRedirectCreatreUrlTree(
            redirectTo,
            this.urlSerializer.parse(redirectTo),
            segments,
            posParams
          );
        }
        applyRedirectCreatreUrlTree(redirectTo, urlTree, segments, posParams) {
          const newRoot = this.createSegmentGroup(
            redirectTo,
            urlTree.root,
            segments,
            posParams
          );
          return new UrlTree(
            newRoot,
            this.createQueryParams(
              urlTree.queryParams,
              this.urlTree.queryParams
            ),
            urlTree.fragment
          );
        }
        createQueryParams(redirectToParams, actualParams) {
          const res = {};
          return (
            forEach(redirectToParams, (v, k) => {
              if ('string' == typeof v && v.startsWith(':')) {
                const sourceName = v.substring(1);
                res[k] = actualParams[sourceName];
              } else res[k] = v;
            }),
            res
          );
        }
        createSegmentGroup(redirectTo, group, segments, posParams) {
          const updatedSegments = this.createSegments(
            redirectTo,
            group.segments,
            segments,
            posParams
          );
          let children = {};
          return (
            forEach(group.children, (child, name) => {
              children[name] = this.createSegmentGroup(
                redirectTo,
                child,
                segments,
                posParams
              );
            }),
            new UrlSegmentGroup(updatedSegments, children)
          );
        }
        createSegments(
          redirectTo,
          redirectToSegments,
          actualSegments,
          posParams
        ) {
          return redirectToSegments.map(s =>
            s.path.startsWith(':')
              ? this.findPosParam(redirectTo, s, posParams)
              : this.findOrReturn(s, actualSegments)
          );
        }
        findPosParam(redirectTo, redirectToUrlSegment, posParams) {
          const pos = posParams[redirectToUrlSegment.path.substring(1)];
          if (!pos)
            throw new Error(
              `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`
            );
          return pos;
        }
        findOrReturn(redirectToUrlSegment, actualSegments) {
          let idx = 0;
          for (const s of actualSegments) {
            if (s.path === redirectToUrlSegment.path)
              return actualSegments.splice(idx), s;
            idx++;
          }
          return redirectToUrlSegment;
        }
      }
      function match(segmentGroup, route, segments) {
        if ('' === route.path)
          return 'full' === route.pathMatch &&
            (segmentGroup.hasChildren() || segments.length > 0)
            ? {
                matched: !1,
                consumedSegments: [],
                lastChild: 0,
                positionalParamSegments: {}
              }
            : {
                matched: !0,
                consumedSegments: [],
                lastChild: 0,
                positionalParamSegments: {}
              };
        const res = (route.matcher || defaultUrlMatcher)(
          segments,
          segmentGroup,
          route
        );
        return res
          ? {
              matched: !0,
              consumedSegments: res.consumed,
              lastChild: res.consumed.length,
              positionalParamSegments: res.posParams
            }
          : {
              matched: !1,
              consumedSegments: [],
              lastChild: 0,
              positionalParamSegments: {}
            };
      }
      function mergeTrivialChildren(s) {
        if (1 === s.numberOfChildren && s.children.primary) {
          const c = s.children.primary;
          return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
        }
        return s;
      }
      function isEmptyPathRedirect(segmentGroup, segments, r) {
        return (
          (!(segmentGroup.hasChildren() || segments.length > 0) ||
            'full' !== r.pathMatch) &&
          '' === r.path &&
          void 0 !== r.redirectTo
        );
      }
      function getOutlet(route) {
        return route.outlet || 'primary';
      }
      class CanActivate {
        constructor(path) {
          (this.path = path), (this.route = this.path[this.path.length - 1]);
        }
      }
      class CanDeactivate {
        constructor(component, route) {
          (this.component = component), (this.route = route);
        }
      }
      function getAllRouteGuards(future, curr, parentContexts) {
        const futureRoot = future._root;
        return (function getChildRouteGuards(
          futureNode,
          currNode,
          contexts,
          futurePath,
          checks = { canDeactivateChecks: [], canActivateChecks: [] }
        ) {
          const prevChildren = nodeChildrenAsMap(currNode);
          return (
            futureNode.children.forEach(c => {
              !(function(
                futureNode,
                currNode,
                parentContexts,
                futurePath,
                checks = { canDeactivateChecks: [], canActivateChecks: [] }
              ) {
                const future = futureNode.value,
                  curr = currNode ? currNode.value : null,
                  context = parentContexts
                    ? parentContexts.getContext(futureNode.value.outlet)
                    : null;
                if (curr && future.routeConfig === curr.routeConfig) {
                  const shouldRun = (function(curr, future, mode) {
                    if ('function' == typeof mode) return mode(curr, future);
                    switch (mode) {
                      case 'pathParamsChange':
                        return !equalPath(curr.url, future.url);
                      case 'pathParamsOrQueryParamsChange':
                        return (
                          !equalPath(curr.url, future.url) ||
                          !shallowEqual(curr.queryParams, future.queryParams)
                        );
                      case 'always':
                        return !0;
                      case 'paramsOrQueryParamsChange':
                        return (
                          !equalParamsAndUrlSegments(curr, future) ||
                          !shallowEqual(curr.queryParams, future.queryParams)
                        );
                      case 'paramsChange':
                      default:
                        return !equalParamsAndUrlSegments(curr, future);
                    }
                  })(curr, future, future.routeConfig.runGuardsAndResolvers);
                  shouldRun
                    ? checks.canActivateChecks.push(new CanActivate(futurePath))
                    : ((future.data = curr.data),
                      (future._resolvedData = curr._resolvedData)),
                    getChildRouteGuards(
                      futureNode,
                      currNode,
                      future.component
                        ? context
                          ? context.children
                          : null
                        : parentContexts,
                      futurePath,
                      checks
                    ),
                    shouldRun &&
                      checks.canDeactivateChecks.push(
                        new CanDeactivate(
                          (context &&
                            context.outlet &&
                            context.outlet.component) ||
                            null,
                          curr
                        )
                      );
                } else
                  curr &&
                    deactivateRouteAndItsChildren(currNode, context, checks),
                    checks.canActivateChecks.push(new CanActivate(futurePath)),
                    getChildRouteGuards(
                      futureNode,
                      null,
                      future.component
                        ? context
                          ? context.children
                          : null
                        : parentContexts,
                      futurePath,
                      checks
                    );
              })(
                c,
                prevChildren[c.value.outlet],
                contexts,
                futurePath.concat([c.value]),
                checks
              ),
                delete prevChildren[c.value.outlet];
            }),
            forEach(prevChildren, (v, k) =>
              deactivateRouteAndItsChildren(v, contexts.getContext(k), checks)
            ),
            checks
          );
        })(futureRoot, curr ? curr._root : null, parentContexts, [
          futureRoot.value
        ]);
      }
      function getToken(token, snapshot, moduleInjector) {
        const config = (function(snapshot) {
          if (!snapshot) return null;
          for (let s = snapshot.parent; s; s = s.parent) {
            const route = s.routeConfig;
            if (route && route._loadedConfig) return route._loadedConfig;
          }
          return null;
        })(snapshot);
        return (config ? config.module.injector : moduleInjector).get(token);
      }
      function deactivateRouteAndItsChildren(route, context, checks) {
        const children = nodeChildrenAsMap(route),
          r = route.value;
        forEach(children, (node, childName) => {
          deactivateRouteAndItsChildren(
            node,
            r.component
              ? context
                ? context.children.getContext(childName)
                : null
              : context,
            checks
          );
        }),
          checks.canDeactivateChecks.push(
            new CanDeactivate(
              r.component &&
              context &&
              context.outlet &&
              context.outlet.isActivated
                ? context.outlet.component
                : null,
              r
            )
          );
      }
      const INITIAL_VALUE = Symbol('INITIAL_VALUE');
      function prioritizedGuardValue() {
        return Object(switchMap.a)(obs =>
          Object(combineLatest.a)(
            ...obs.map(o =>
              o.pipe(
                Object(take.a)(1),
                Object(startWith.a)(INITIAL_VALUE)
              )
            )
          ).pipe(
            Object(scan.a)((acc, list) => {
              let isPending = !1;
              return list.reduce((innerAcc, val, i) => {
                if (innerAcc !== INITIAL_VALUE) return innerAcc;
                if ((val === INITIAL_VALUE && (isPending = !0), !isPending)) {
                  if (!1 === val) return val;
                  if (i === list.length - 1 || isUrlTree(val)) return val;
                }
                return innerAcc;
              }, acc);
            }, INITIAL_VALUE),
            Object(filter.a)(item => item !== INITIAL_VALUE),
            Object(map.a)(item => (isUrlTree(item) ? item : !0 === item)),
            Object(take.a)(1)
          )
        );
      }
      function fireActivationStart(snapshot, forwardEvent) {
        return (
          null !== snapshot &&
            forwardEvent &&
            forwardEvent(new ActivationStart(snapshot)),
          Object(of.a)(!0)
        );
      }
      function fireChildActivationStart(snapshot, forwardEvent) {
        return (
          null !== snapshot &&
            forwardEvent &&
            forwardEvent(new ChildActivationStart(snapshot)),
          Object(of.a)(!0)
        );
      }
      function runCanActivate(futureRSS, futureARS, moduleInjector) {
        const canActivate = futureARS.routeConfig
          ? futureARS.routeConfig.canActivate
          : null;
        if (!canActivate || 0 === canActivate.length) return Object(of.a)(!0);
        const canActivateObservables = canActivate.map(c =>
          defer(() => {
            const guard = getToken(c, futureARS, moduleInjector);
            let observable;
            if (
              (function(guard) {
                return guard && isFunction(guard.canActivate);
              })(guard)
            )
              observable = wrapIntoObservable(
                guard.canActivate(futureARS, futureRSS)
              );
            else {
              if (!isFunction(guard))
                throw new Error('Invalid CanActivate guard');
              observable = wrapIntoObservable(guard(futureARS, futureRSS));
            }
            return observable.pipe(first());
          })
        );
        return Object(of.a)(canActivateObservables).pipe(
          prioritizedGuardValue()
        );
      }
      function runCanActivateChild(futureRSS, path, moduleInjector) {
        const futureARS = path[path.length - 1],
          canActivateChildGuardsMapped = path
            .slice(0, path.length - 1)
            .reverse()
            .map(p =>
              (function(p) {
                const canActivateChild = p.routeConfig
                  ? p.routeConfig.canActivateChild
                  : null;
                return canActivateChild && 0 !== canActivateChild.length
                  ? { node: p, guards: canActivateChild }
                  : null;
              })(p)
            )
            .filter(_ => null !== _)
            .map(d =>
              defer(() => {
                const guardsMapped = d.guards.map(c => {
                  const guard = getToken(c, d.node, moduleInjector);
                  let observable;
                  if (
                    (function(guard) {
                      return guard && isFunction(guard.canActivateChild);
                    })(guard)
                  )
                    observable = wrapIntoObservable(
                      guard.canActivateChild(futureARS, futureRSS)
                    );
                  else {
                    if (!isFunction(guard))
                      throw new Error('Invalid CanActivateChild guard');
                    observable = wrapIntoObservable(
                      guard(futureARS, futureRSS)
                    );
                  }
                  return observable.pipe(first());
                });
                return Object(of.a)(guardsMapped).pipe(prioritizedGuardValue());
              })
            );
        return Object(of.a)(canActivateChildGuardsMapped).pipe(
          prioritizedGuardValue()
        );
      }
      class NoMatch$1 {}
      class router_Recognizer {
        constructor(
          rootComponentType,
          config,
          urlTree,
          url,
          paramsInheritanceStrategy,
          relativeLinkResolution
        ) {
          (this.rootComponentType = rootComponentType),
            (this.config = config),
            (this.urlTree = urlTree),
            (this.url = url),
            (this.paramsInheritanceStrategy = paramsInheritanceStrategy),
            (this.relativeLinkResolution = relativeLinkResolution);
        }
        recognize() {
          try {
            const rootSegmentGroup = split$1(
                this.urlTree.root,
                [],
                [],
                this.config,
                this.relativeLinkResolution
              ).segmentGroup,
              children = this.processSegmentGroup(
                this.config,
                rootSegmentGroup,
                'primary'
              ),
              root = new ActivatedRouteSnapshot(
                [],
                Object.freeze({}),
                Object.freeze(Object.assign({}, this.urlTree.queryParams)),
                this.urlTree.fragment,
                {},
                'primary',
                this.rootComponentType,
                null,
                this.urlTree.root,
                -1,
                {}
              ),
              rootNode = new TreeNode(root, children),
              routeState = new RouterStateSnapshot(this.url, rootNode);
            return (
              this.inheritParamsAndData(routeState._root),
              Object(of.a)(routeState)
            );
          } catch (e) {
            return new Observable.a(obs => obs.error(e));
          }
        }
        inheritParamsAndData(routeNode) {
          const route = routeNode.value,
            i = inheritedParamsDataResolve(
              route,
              this.paramsInheritanceStrategy
            );
          (route.params = Object.freeze(i.params)),
            (route.data = Object.freeze(i.data)),
            routeNode.children.forEach(n => this.inheritParamsAndData(n));
        }
        processSegmentGroup(config, segmentGroup, outlet) {
          return 0 === segmentGroup.segments.length &&
            segmentGroup.hasChildren()
            ? this.processChildren(config, segmentGroup)
            : this.processSegment(
                config,
                segmentGroup,
                segmentGroup.segments,
                outlet
              );
        }
        processChildren(config, segmentGroup) {
          const children = mapChildrenIntoArray(
            segmentGroup,
            (child, childOutlet) =>
              this.processSegmentGroup(config, child, childOutlet)
          );
          return (
            (function(nodes) {
              const names = {};
              nodes.forEach(n => {
                const routeWithSameOutletName = names[n.value.outlet];
                if (routeWithSameOutletName) {
                  const p = routeWithSameOutletName.url
                      .map(s => s.toString())
                      .join('/'),
                    c = n.value.url.map(s => s.toString()).join('/');
                  throw new Error(
                    `Two segments cannot have the same outlet name: '${p}' and '${c}'.`
                  );
                }
                names[n.value.outlet] = n.value;
              });
            })(children),
            children.sort((a, b) =>
              'primary' === a.value.outlet
                ? -1
                : 'primary' === b.value.outlet
                ? 1
                : a.value.outlet.localeCompare(b.value.outlet)
            ),
            children
          );
        }
        processSegment(config, segmentGroup, segments, outlet) {
          for (const r of config)
            try {
              return this.processSegmentAgainstRoute(
                r,
                segmentGroup,
                segments,
                outlet
              );
            } catch (e) {
              if (!(e instanceof NoMatch$1)) throw e;
            }
          if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) return [];
          throw new NoMatch$1();
        }
        noLeftoversInUrl(segmentGroup, segments, outlet) {
          return 0 === segments.length && !segmentGroup.children[outlet];
        }
        processSegmentAgainstRoute(route, rawSegment, segments, outlet) {
          if (route.redirectTo) throw new NoMatch$1();
          if ((route.outlet || 'primary') !== outlet) throw new NoMatch$1();
          let snapshot,
            consumedSegments = [],
            rawSlicedSegments = [];
          if ('**' === route.path) {
            const params =
              segments.length > 0 ? router_last(segments).parameters : {};
            snapshot = new ActivatedRouteSnapshot(
              segments,
              params,
              Object.freeze(Object.assign({}, this.urlTree.queryParams)),
              this.urlTree.fragment,
              getData(route),
              outlet,
              route.component,
              route,
              getSourceSegmentGroup(rawSegment),
              getPathIndexShift(rawSegment) + segments.length,
              getResolve(route)
            );
          } else {
            const result = (function(segmentGroup, route, segments) {
              if ('' === route.path) {
                if (
                  'full' === route.pathMatch &&
                  (segmentGroup.hasChildren() || segments.length > 0)
                )
                  throw new NoMatch$1();
                return { consumedSegments: [], lastChild: 0, parameters: {} };
              }
              const res = (route.matcher || defaultUrlMatcher)(
                segments,
                segmentGroup,
                route
              );
              if (!res) throw new NoMatch$1();
              const posParams = {};
              forEach(res.posParams, (v, k) => {
                posParams[k] = v.path;
              });
              const parameters =
                res.consumed.length > 0
                  ? Object.assign(
                      Object.assign({}, posParams),
                      res.consumed[res.consumed.length - 1].parameters
                    )
                  : posParams;
              return {
                consumedSegments: res.consumed,
                lastChild: res.consumed.length,
                parameters: parameters
              };
            })(rawSegment, route, segments);
            (consumedSegments = result.consumedSegments),
              (rawSlicedSegments = segments.slice(result.lastChild)),
              (snapshot = new ActivatedRouteSnapshot(
                consumedSegments,
                result.parameters,
                Object.freeze(Object.assign({}, this.urlTree.queryParams)),
                this.urlTree.fragment,
                getData(route),
                outlet,
                route.component,
                route,
                getSourceSegmentGroup(rawSegment),
                getPathIndexShift(rawSegment) + consumedSegments.length,
                getResolve(route)
              ));
          }
          const childConfig = (function(route) {
              return route.children
                ? route.children
                : route.loadChildren
                ? route._loadedConfig.routes
                : [];
            })(route),
            {
              segmentGroup: segmentGroup,
              slicedSegments: slicedSegments
            } = split$1(
              rawSegment,
              consumedSegments,
              rawSlicedSegments,
              childConfig,
              this.relativeLinkResolution
            );
          if (0 === slicedSegments.length && segmentGroup.hasChildren()) {
            const children = this.processChildren(childConfig, segmentGroup);
            return [new TreeNode(snapshot, children)];
          }
          if (0 === childConfig.length && 0 === slicedSegments.length)
            return [new TreeNode(snapshot, [])];
          const children = this.processSegment(
            childConfig,
            segmentGroup,
            slicedSegments,
            'primary'
          );
          return [new TreeNode(snapshot, children)];
        }
      }
      function getSourceSegmentGroup(segmentGroup) {
        let s = segmentGroup;
        for (; s._sourceSegment; ) s = s._sourceSegment;
        return s;
      }
      function getPathIndexShift(segmentGroup) {
        let s = segmentGroup,
          res = s._segmentIndexShift ? s._segmentIndexShift : 0;
        for (; s._sourceSegment; )
          (s = s._sourceSegment),
            (res += s._segmentIndexShift ? s._segmentIndexShift : 0);
        return res - 1;
      }
      function split$1(
        segmentGroup,
        consumedSegments,
        slicedSegments,
        config,
        relativeLinkResolution
      ) {
        if (
          slicedSegments.length > 0 &&
          (function(segmentGroup, slicedSegments, routes) {
            return routes.some(
              r =>
                emptyPathMatch(segmentGroup, slicedSegments, r) &&
                'primary' !== getOutlet$1(r)
            );
          })(segmentGroup, slicedSegments, config)
        ) {
          const s = new UrlSegmentGroup(
            consumedSegments,
            (function(segmentGroup, consumedSegments, routes, primarySegment) {
              const res = {};
              (res.primary = primarySegment),
                (primarySegment._sourceSegment = segmentGroup),
                (primarySegment._segmentIndexShift = consumedSegments.length);
              for (const r of routes)
                if ('' === r.path && 'primary' !== getOutlet$1(r)) {
                  const s = new UrlSegmentGroup([], {});
                  (s._sourceSegment = segmentGroup),
                    (s._segmentIndexShift = consumedSegments.length),
                    (res[getOutlet$1(r)] = s);
                }
              return res;
            })(
              segmentGroup,
              consumedSegments,
              config,
              new UrlSegmentGroup(slicedSegments, segmentGroup.children)
            )
          );
          return (
            (s._sourceSegment = segmentGroup),
            (s._segmentIndexShift = consumedSegments.length),
            { segmentGroup: s, slicedSegments: [] }
          );
        }
        if (
          0 === slicedSegments.length &&
          (function(segmentGroup, slicedSegments, routes) {
            return routes.some(r =>
              emptyPathMatch(segmentGroup, slicedSegments, r)
            );
          })(segmentGroup, slicedSegments, config)
        ) {
          const s = new UrlSegmentGroup(
            segmentGroup.segments,
            (function(
              segmentGroup,
              consumedSegments,
              slicedSegments,
              routes,
              children,
              relativeLinkResolution
            ) {
              const res = {};
              for (const r of routes)
                if (
                  emptyPathMatch(segmentGroup, slicedSegments, r) &&
                  !children[getOutlet$1(r)]
                ) {
                  const s = new UrlSegmentGroup([], {});
                  (s._sourceSegment = segmentGroup),
                    (s._segmentIndexShift =
                      'legacy' === relativeLinkResolution
                        ? segmentGroup.segments.length
                        : consumedSegments.length),
                    (res[getOutlet$1(r)] = s);
                }
              return Object.assign(Object.assign({}, children), res);
            })(
              segmentGroup,
              consumedSegments,
              slicedSegments,
              config,
              segmentGroup.children,
              relativeLinkResolution
            )
          );
          return (
            (s._sourceSegment = segmentGroup),
            (s._segmentIndexShift = consumedSegments.length),
            { segmentGroup: s, slicedSegments: slicedSegments }
          );
        }
        const s = new UrlSegmentGroup(
          segmentGroup.segments,
          segmentGroup.children
        );
        return (
          (s._sourceSegment = segmentGroup),
          (s._segmentIndexShift = consumedSegments.length),
          { segmentGroup: s, slicedSegments: slicedSegments }
        );
      }
      function emptyPathMatch(segmentGroup, slicedSegments, r) {
        return (
          (!(segmentGroup.hasChildren() || slicedSegments.length > 0) ||
            'full' !== r.pathMatch) &&
          '' === r.path &&
          void 0 === r.redirectTo
        );
      }
      function getOutlet$1(route) {
        return route.outlet || 'primary';
      }
      function getData(route) {
        return route.data || {};
      }
      function getResolve(route) {
        return route.resolve || {};
      }
      function switchTap(next) {
        return function(source) {
          return source.pipe(
            Object(switchMap.a)(v => {
              const nextResult = next(v);
              return nextResult
                ? Object(from.a)(nextResult).pipe(Object(map.a)(() => v))
                : Object(from.a)([v]);
            })
          );
        };
      }
      class RouteReuseStrategy {}
      class DefaultRouteReuseStrategy {
        shouldDetach(route) {
          return !1;
        }
        store(route, detachedTree) {}
        shouldAttach(route) {
          return !1;
        }
        retrieve(route) {
          return null;
        }
        shouldReuseRoute(future, curr) {
          return future.routeConfig === curr.routeConfig;
        }
      }
      const ROUTES = new core.q('ROUTES');
      class router_RouterConfigLoader {
        constructor(loader, compiler, onLoadStartListener, onLoadEndListener) {
          (this.loader = loader),
            (this.compiler = compiler),
            (this.onLoadStartListener = onLoadStartListener),
            (this.onLoadEndListener = onLoadEndListener);
        }
        load(parentInjector, route) {
          return (
            this.onLoadStartListener && this.onLoadStartListener(route),
            this.loadModuleFactory(route.loadChildren).pipe(
              Object(map.a)(factory => {
                this.onLoadEndListener && this.onLoadEndListener(route);
                const module = factory.create(parentInjector);
                return new LoadedRouterConfig(
                  flatten(module.injector.get(ROUTES)).map(standardizeConfig),
                  module
                );
              })
            )
          );
        }
        loadModuleFactory(loadChildren) {
          return 'string' == typeof loadChildren
            ? Object(from.a)(this.loader.load(loadChildren))
            : wrapIntoObservable(loadChildren()).pipe(
                Object(mergeMap.a)(t =>
                  t instanceof core.v
                    ? Object(of.a)(t)
                    : Object(from.a)(this.compiler.compileModuleAsync(t))
                )
              );
        }
      }
      class OutletContext {
        constructor() {
          (this.outlet = null),
            (this.route = null),
            (this.resolver = null),
            (this.children = new ChildrenOutletContexts()),
            (this.attachRef = null);
        }
      }
      class ChildrenOutletContexts {
        constructor() {
          this.contexts = new Map();
        }
        onChildOutletCreated(childName, outlet) {
          const context = this.getOrCreateContext(childName);
          (context.outlet = outlet), this.contexts.set(childName, context);
        }
        onChildOutletDestroyed(childName) {
          const context = this.getContext(childName);
          context && (context.outlet = null);
        }
        onOutletDeactivated() {
          const contexts = this.contexts;
          return (this.contexts = new Map()), contexts;
        }
        onOutletReAttached(contexts) {
          this.contexts = contexts;
        }
        getOrCreateContext(childName) {
          let context = this.getContext(childName);
          return (
            context ||
              ((context = new OutletContext()),
              this.contexts.set(childName, context)),
            context
          );
        }
        getContext(childName) {
          return this.contexts.get(childName) || null;
        }
      }
      class DefaultUrlHandlingStrategy {
        shouldProcessUrl(url) {
          return !0;
        }
        extract(url) {
          return url;
        }
        merge(newUrlPart, wholeUrl) {
          return newUrlPart;
        }
      }
      function defaultErrorHandler(error) {
        throw error;
      }
      function defaultMalformedUriErrorHandler(error, urlSerializer, url) {
        return urlSerializer.parse('/');
      }
      function defaultRouterHook(snapshot, runExtras) {
        return Object(of.a)(null);
      }
      let router_Router = (() => {
          class Router {
            constructor(
              rootComponentType,
              urlSerializer,
              rootContexts,
              location,
              injector,
              loader,
              compiler,
              config
            ) {
              (this.rootComponentType = rootComponentType),
                (this.urlSerializer = urlSerializer),
                (this.rootContexts = rootContexts),
                (this.location = location),
                (this.config = config),
                (this.lastSuccessfulNavigation = null),
                (this.currentNavigation = null),
                (this.navigationId = 0),
                (this.isNgZoneEnabled = !1),
                (this.events = new Subject.a()),
                (this.errorHandler = defaultErrorHandler),
                (this.malformedUriErrorHandler = defaultMalformedUriErrorHandler),
                (this.navigated = !1),
                (this.lastSuccessfulId = -1),
                (this.hooks = {
                  beforePreactivation: defaultRouterHook,
                  afterPreactivation: defaultRouterHook
                }),
                (this.urlHandlingStrategy = new DefaultUrlHandlingStrategy()),
                (this.routeReuseStrategy = new DefaultRouteReuseStrategy()),
                (this.onSameUrlNavigation = 'ignore'),
                (this.paramsInheritanceStrategy = 'emptyOnly'),
                (this.urlUpdateStrategy = 'deferred'),
                (this.relativeLinkResolution = 'legacy'),
                (this.ngModule = injector.get(core.x)),
                (this.console = injector.get(core.W));
              const ngZone = injector.get(core.z);
              (this.isNgZoneEnabled = ngZone instanceof core.z),
                this.resetConfig(config),
                (this.currentUrlTree = new UrlTree(
                  new UrlSegmentGroup([], {}),
                  {},
                  null
                )),
                (this.rawUrlTree = this.currentUrlTree),
                (this.browserUrlTree = this.currentUrlTree),
                (this.configLoader = new router_RouterConfigLoader(
                  loader,
                  compiler,
                  r => this.triggerEvent(new RouteConfigLoadStart(r)),
                  r => this.triggerEvent(new RouteConfigLoadEnd(r))
                )),
                (this.routerState = createEmptyState(
                  this.currentUrlTree,
                  this.rootComponentType
                )),
                (this.transitions = new BehaviorSubject.a({
                  id: 0,
                  currentUrlTree: this.currentUrlTree,
                  currentRawUrl: this.currentUrlTree,
                  extractedUrl: this.urlHandlingStrategy.extract(
                    this.currentUrlTree
                  ),
                  urlAfterRedirects: this.urlHandlingStrategy.extract(
                    this.currentUrlTree
                  ),
                  rawUrl: this.currentUrlTree,
                  extras: {},
                  resolve: null,
                  reject: null,
                  promise: Promise.resolve(!0),
                  source: 'imperative',
                  restoredState: null,
                  currentSnapshot: this.routerState.snapshot,
                  targetSnapshot: null,
                  currentRouterState: this.routerState,
                  targetRouterState: null,
                  guards: { canActivateChecks: [], canDeactivateChecks: [] },
                  guardsResult: null
                })),
                (this.navigations = this.setupNavigations(this.transitions)),
                this.processNavigations();
            }
            setupNavigations(transitions) {
              const eventsSubject = this.events;
              return transitions.pipe(
                Object(filter.a)(t => 0 !== t.id),
                Object(map.a)(t =>
                  Object.assign(Object.assign({}, t), {
                    extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl)
                  })
                ),
                Object(switchMap.a)(t => {
                  let completed = !1,
                    errored = !1;
                  return Object(of.a)(t).pipe(
                    Object(tap.a)(t => {
                      this.currentNavigation = {
                        id: t.id,
                        initialUrl: t.currentRawUrl,
                        extractedUrl: t.extractedUrl,
                        trigger: t.source,
                        extras: t.extras,
                        previousNavigation: this.lastSuccessfulNavigation
                          ? Object.assign(
                              Object.assign({}, this.lastSuccessfulNavigation),
                              { previousNavigation: null }
                            )
                          : null
                      };
                    }),
                    Object(switchMap.a)(t => {
                      const urlTransition =
                        !this.navigated ||
                        t.extractedUrl.toString() !==
                          this.browserUrlTree.toString();
                      if (
                        ('reload' === this.onSameUrlNavigation ||
                          urlTransition) &&
                        this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)
                      )
                        return Object(of.a)(t).pipe(
                          Object(switchMap.a)(t => {
                            const transition = this.transitions.getValue();
                            return (
                              eventsSubject.next(
                                new NavigationStart(
                                  t.id,
                                  this.serializeUrl(t.extractedUrl),
                                  t.source,
                                  t.restoredState
                                )
                              ),
                              transition !== this.transitions.getValue()
                                ? empty.a
                                : [t]
                            );
                          }),
                          Object(switchMap.a)(t => Promise.resolve(t)),
                          ((moduleInjector = this.ngModule.injector),
                          (configLoader = this.configLoader),
                          (urlSerializer = this.urlSerializer),
                          (config = this.config),
                          function(source) {
                            return source.pipe(
                              Object(switchMap.a)(t =>
                                (function(
                                  moduleInjector,
                                  configLoader,
                                  urlSerializer,
                                  urlTree,
                                  config
                                ) {
                                  return new router_ApplyRedirects(
                                    moduleInjector,
                                    configLoader,
                                    urlSerializer,
                                    urlTree,
                                    config
                                  ).apply();
                                })(
                                  moduleInjector,
                                  configLoader,
                                  urlSerializer,
                                  t.extractedUrl,
                                  config
                                ).pipe(
                                  Object(map.a)(urlAfterRedirects =>
                                    Object.assign(Object.assign({}, t), {
                                      urlAfterRedirects: urlAfterRedirects
                                    })
                                  )
                                )
                              )
                            );
                          }),
                          Object(tap.a)(t => {
                            this.currentNavigation = Object.assign(
                              Object.assign({}, this.currentNavigation),
                              { finalUrl: t.urlAfterRedirects }
                            );
                          }),
                          (function(
                            rootComponentType,
                            config,
                            serializer,
                            paramsInheritanceStrategy,
                            relativeLinkResolution
                          ) {
                            return function(source) {
                              return source.pipe(
                                Object(mergeMap.a)(t =>
                                  (function(
                                    rootComponentType,
                                    config,
                                    urlTree,
                                    url,
                                    paramsInheritanceStrategy = 'emptyOnly',
                                    relativeLinkResolution = 'legacy'
                                  ) {
                                    return new router_Recognizer(
                                      rootComponentType,
                                      config,
                                      urlTree,
                                      url,
                                      paramsInheritanceStrategy,
                                      relativeLinkResolution
                                    ).recognize();
                                  })(
                                    rootComponentType,
                                    config,
                                    t.urlAfterRedirects,
                                    serializer(t.urlAfterRedirects),
                                    paramsInheritanceStrategy,
                                    relativeLinkResolution
                                  ).pipe(
                                    Object(map.a)(targetSnapshot =>
                                      Object.assign(Object.assign({}, t), {
                                        targetSnapshot: targetSnapshot
                                      })
                                    )
                                  )
                                )
                              );
                            };
                          })(
                            this.rootComponentType,
                            this.config,
                            url => this.serializeUrl(url),
                            this.paramsInheritanceStrategy,
                            this.relativeLinkResolution
                          ),
                          Object(tap.a)(t => {
                            'eager' === this.urlUpdateStrategy &&
                              (t.extras.skipLocationChange ||
                                this.setBrowserUrl(
                                  t.urlAfterRedirects,
                                  !!t.extras.replaceUrl,
                                  t.id,
                                  t.extras.state
                                ),
                              (this.browserUrlTree = t.urlAfterRedirects));
                          }),
                          Object(tap.a)(t => {
                            const routesRecognized = new RoutesRecognized(
                              t.id,
                              this.serializeUrl(t.extractedUrl),
                              this.serializeUrl(t.urlAfterRedirects),
                              t.targetSnapshot
                            );
                            eventsSubject.next(routesRecognized);
                          })
                        );
                      var moduleInjector, configLoader, urlSerializer, config;
                      if (
                        urlTransition &&
                        this.rawUrlTree &&
                        this.urlHandlingStrategy.shouldProcessUrl(
                          this.rawUrlTree
                        )
                      ) {
                        const {
                            id: id,
                            extractedUrl: extractedUrl,
                            source: source,
                            restoredState: restoredState,
                            extras: extras
                          } = t,
                          navStart = new NavigationStart(
                            id,
                            this.serializeUrl(extractedUrl),
                            source,
                            restoredState
                          );
                        eventsSubject.next(navStart);
                        const targetSnapshot = createEmptyState(
                          extractedUrl,
                          this.rootComponentType
                        ).snapshot;
                        return Object(of.a)(
                          Object.assign(Object.assign({}, t), {
                            targetSnapshot: targetSnapshot,
                            urlAfterRedirects: extractedUrl,
                            extras: Object.assign(Object.assign({}, extras), {
                              skipLocationChange: !1,
                              replaceUrl: !1
                            })
                          })
                        );
                      }
                      return (
                        (this.rawUrlTree = t.rawUrl),
                        (this.browserUrlTree = t.urlAfterRedirects),
                        t.resolve(null),
                        empty.a
                      );
                    }),
                    switchTap(t => {
                      const {
                        targetSnapshot: targetSnapshot,
                        id: navigationId,
                        extractedUrl: appliedUrlTree,
                        rawUrl: rawUrlTree,
                        extras: {
                          skipLocationChange: skipLocationChange,
                          replaceUrl: replaceUrl
                        }
                      } = t;
                      return this.hooks.beforePreactivation(targetSnapshot, {
                        navigationId: navigationId,
                        appliedUrlTree: appliedUrlTree,
                        rawUrlTree: rawUrlTree,
                        skipLocationChange: !!skipLocationChange,
                        replaceUrl: !!replaceUrl
                      });
                    }),
                    Object(tap.a)(t => {
                      const guardsStart = new GuardsCheckStart(
                        t.id,
                        this.serializeUrl(t.extractedUrl),
                        this.serializeUrl(t.urlAfterRedirects),
                        t.targetSnapshot
                      );
                      this.triggerEvent(guardsStart);
                    }),
                    Object(map.a)(t =>
                      Object.assign(Object.assign({}, t), {
                        guards: getAllRouteGuards(
                          t.targetSnapshot,
                          t.currentSnapshot,
                          this.rootContexts
                        )
                      })
                    ),
                    (function(moduleInjector, forwardEvent) {
                      return function(source) {
                        return source.pipe(
                          Object(mergeMap.a)(t => {
                            const {
                              targetSnapshot: targetSnapshot,
                              currentSnapshot: currentSnapshot,
                              guards: {
                                canActivateChecks: canActivateChecks,
                                canDeactivateChecks: canDeactivateChecks
                              }
                            } = t;
                            return 0 === canDeactivateChecks.length &&
                              0 === canActivateChecks.length
                              ? Object(of.a)(
                                  Object.assign(Object.assign({}, t), {
                                    guardsResult: !0
                                  })
                                )
                              : (function(
                                  checks,
                                  futureRSS,
                                  currRSS,
                                  moduleInjector
                                ) {
                                  return Object(from.a)(checks).pipe(
                                    Object(mergeMap.a)(check =>
                                      (function(
                                        component,
                                        currARS,
                                        currRSS,
                                        futureRSS,
                                        moduleInjector
                                      ) {
                                        const canDeactivate =
                                          currARS && currARS.routeConfig
                                            ? currARS.routeConfig.canDeactivate
                                            : null;
                                        if (
                                          !canDeactivate ||
                                          0 === canDeactivate.length
                                        )
                                          return Object(of.a)(!0);
                                        const canDeactivateObservables = canDeactivate.map(
                                          c => {
                                            const guard = getToken(
                                              c,
                                              currARS,
                                              moduleInjector
                                            );
                                            let observable;
                                            if (
                                              (function(guard) {
                                                return (
                                                  guard &&
                                                  isFunction(
                                                    guard.canDeactivate
                                                  )
                                                );
                                              })(guard)
                                            )
                                              observable = wrapIntoObservable(
                                                guard.canDeactivate(
                                                  component,
                                                  currARS,
                                                  currRSS,
                                                  futureRSS
                                                )
                                              );
                                            else {
                                              if (!isFunction(guard))
                                                throw new Error(
                                                  'Invalid CanDeactivate guard'
                                                );
                                              observable = wrapIntoObservable(
                                                guard(
                                                  component,
                                                  currARS,
                                                  currRSS,
                                                  futureRSS
                                                )
                                              );
                                            }
                                            return observable.pipe(first());
                                          }
                                        );
                                        return Object(of.a)(
                                          canDeactivateObservables
                                        ).pipe(prioritizedGuardValue());
                                      })(
                                        check.component,
                                        check.route,
                                        currRSS,
                                        futureRSS,
                                        moduleInjector
                                      )
                                    ),
                                    first(result => !0 !== result, !0)
                                  );
                                })(
                                  canDeactivateChecks,
                                  targetSnapshot,
                                  currentSnapshot,
                                  moduleInjector
                                ).pipe(
                                  Object(mergeMap.a)(canDeactivate =>
                                    canDeactivate &&
                                    'boolean' == typeof canDeactivate
                                      ? (function(
                                          futureSnapshot,
                                          checks,
                                          moduleInjector,
                                          forwardEvent
                                        ) {
                                          return Object(from.a)(checks).pipe(
                                            Object(concatMap.a)(check =>
                                              Object(from.a)([
                                                fireChildActivationStart(
                                                  check.route.parent,
                                                  forwardEvent
                                                ),
                                                fireActivationStart(
                                                  check.route,
                                                  forwardEvent
                                                ),
                                                runCanActivateChild(
                                                  futureSnapshot,
                                                  check.path,
                                                  moduleInjector
                                                ),
                                                runCanActivate(
                                                  futureSnapshot,
                                                  check.route,
                                                  moduleInjector
                                                )
                                              ]).pipe(
                                                Object(concatAll.a)(),
                                                first(
                                                  result => !0 !== result,
                                                  !0
                                                )
                                              )
                                            ),
                                            first(result => !0 !== result, !0)
                                          );
                                        })(
                                          targetSnapshot,
                                          canActivateChecks,
                                          moduleInjector,
                                          forwardEvent
                                        )
                                      : Object(of.a)(canDeactivate)
                                  ),
                                  Object(map.a)(guardsResult =>
                                    Object.assign(Object.assign({}, t), {
                                      guardsResult: guardsResult
                                    })
                                  )
                                );
                          })
                        );
                      };
                    })(this.ngModule.injector, evt => this.triggerEvent(evt)),
                    Object(tap.a)(t => {
                      if (isUrlTree(t.guardsResult)) {
                        const error = navigationCancelingError(
                          `Redirecting to "${this.serializeUrl(
                            t.guardsResult
                          )}"`
                        );
                        throw ((error.url = t.guardsResult), error);
                      }
                    }),
                    Object(tap.a)(t => {
                      const guardsEnd = new GuardsCheckEnd(
                        t.id,
                        this.serializeUrl(t.extractedUrl),
                        this.serializeUrl(t.urlAfterRedirects),
                        t.targetSnapshot,
                        !!t.guardsResult
                      );
                      this.triggerEvent(guardsEnd);
                    }),
                    Object(filter.a)(t => {
                      if (!t.guardsResult) {
                        this.resetUrlToCurrentUrlTree();
                        const navCancel = new NavigationCancel(
                          t.id,
                          this.serializeUrl(t.extractedUrl),
                          ''
                        );
                        return eventsSubject.next(navCancel), t.resolve(!1), !1;
                      }
                      return !0;
                    }),
                    switchTap(t => {
                      if (t.guards.canActivateChecks.length)
                        return Object(of.a)(t).pipe(
                          Object(tap.a)(t => {
                            const resolveStart = new ResolveStart(
                              t.id,
                              this.serializeUrl(t.extractedUrl),
                              this.serializeUrl(t.urlAfterRedirects),
                              t.targetSnapshot
                            );
                            this.triggerEvent(resolveStart);
                          }),
                          Object(switchMap.a)(t => {
                            let dataResolved = !1;
                            return Object(of.a)(t).pipe(
                              ((paramsInheritanceStrategy = this
                                .paramsInheritanceStrategy),
                              (moduleInjector = this.ngModule.injector),
                              function(source) {
                                return source.pipe(
                                  Object(mergeMap.a)(t => {
                                    const {
                                      targetSnapshot: targetSnapshot,
                                      guards: {
                                        canActivateChecks: canActivateChecks
                                      }
                                    } = t;
                                    if (!canActivateChecks.length)
                                      return Object(of.a)(t);
                                    let canActivateChecksResolved = 0;
                                    return Object(from.a)(
                                      canActivateChecks
                                    ).pipe(
                                      Object(concatMap.a)(check =>
                                        (function(
                                          futureARS,
                                          futureRSS,
                                          paramsInheritanceStrategy,
                                          moduleInjector
                                        ) {
                                          return (function(
                                            resolve,
                                            futureARS,
                                            futureRSS,
                                            moduleInjector
                                          ) {
                                            const keys = Object.keys(resolve);
                                            if (0 === keys.length)
                                              return Object(of.a)({});
                                            const data = {};
                                            return Object(from.a)(keys).pipe(
                                              Object(mergeMap.a)(key =>
                                                (function(
                                                  injectionToken,
                                                  futureARS,
                                                  futureRSS,
                                                  moduleInjector
                                                ) {
                                                  const resolver = getToken(
                                                    injectionToken,
                                                    futureARS,
                                                    moduleInjector
                                                  );
                                                  return wrapIntoObservable(
                                                    resolver.resolve
                                                      ? resolver.resolve(
                                                          futureARS,
                                                          futureRSS
                                                        )
                                                      : resolver(
                                                          futureARS,
                                                          futureRSS
                                                        )
                                                  );
                                                })(
                                                  resolve[key],
                                                  futureARS,
                                                  futureRSS,
                                                  moduleInjector
                                                ).pipe(
                                                  Object(tap.a)(value => {
                                                    data[key] = value;
                                                  })
                                                )
                                              ),
                                              Object(takeLast.a)(1),
                                              Object(mergeMap.a)(() =>
                                                Object.keys(data).length ===
                                                keys.length
                                                  ? Object(of.a)(data)
                                                  : empty.a
                                              )
                                            );
                                          })(
                                            futureARS._resolve,
                                            futureARS,
                                            futureRSS,
                                            moduleInjector
                                          ).pipe(
                                            Object(map.a)(
                                              resolvedData => (
                                                (futureARS._resolvedData = resolvedData),
                                                (futureARS.data = Object.assign(
                                                  Object.assign(
                                                    {},
                                                    futureARS.data
                                                  ),
                                                  inheritedParamsDataResolve(
                                                    futureARS,
                                                    paramsInheritanceStrategy
                                                  ).resolve
                                                )),
                                                null
                                              )
                                            )
                                          );
                                        })(
                                          check.route,
                                          targetSnapshot,
                                          paramsInheritanceStrategy,
                                          moduleInjector
                                        )
                                      ),
                                      Object(tap.a)(
                                        () => canActivateChecksResolved++
                                      ),
                                      Object(takeLast.a)(1),
                                      Object(mergeMap.a)(_ =>
                                        canActivateChecksResolved ===
                                        canActivateChecks.length
                                          ? Object(of.a)(t)
                                          : empty.a
                                      )
                                    );
                                  })
                                );
                              }),
                              Object(tap.a)({
                                next: () => (dataResolved = !0),
                                complete: () => {
                                  if (!dataResolved) {
                                    const navCancel = new NavigationCancel(
                                      t.id,
                                      this.serializeUrl(t.extractedUrl),
                                      "At least one route resolver didn't emit any value."
                                    );
                                    eventsSubject.next(navCancel),
                                      t.resolve(!1);
                                  }
                                }
                              })
                            );
                            var paramsInheritanceStrategy, moduleInjector;
                          }),
                          Object(tap.a)(t => {
                            const resolveEnd = new ResolveEnd(
                              t.id,
                              this.serializeUrl(t.extractedUrl),
                              this.serializeUrl(t.urlAfterRedirects),
                              t.targetSnapshot
                            );
                            this.triggerEvent(resolveEnd);
                          })
                        );
                    }),
                    switchTap(t => {
                      const {
                        targetSnapshot: targetSnapshot,
                        id: navigationId,
                        extractedUrl: appliedUrlTree,
                        rawUrl: rawUrlTree,
                        extras: {
                          skipLocationChange: skipLocationChange,
                          replaceUrl: replaceUrl
                        }
                      } = t;
                      return this.hooks.afterPreactivation(targetSnapshot, {
                        navigationId: navigationId,
                        appliedUrlTree: appliedUrlTree,
                        rawUrlTree: rawUrlTree,
                        skipLocationChange: !!skipLocationChange,
                        replaceUrl: !!replaceUrl
                      });
                    }),
                    Object(map.a)(t => {
                      const targetRouterState = (function(
                        routeReuseStrategy,
                        curr,
                        prevState
                      ) {
                        const root = (function createNode(
                          routeReuseStrategy,
                          curr,
                          prevState
                        ) {
                          if (
                            prevState &&
                            routeReuseStrategy.shouldReuseRoute(
                              curr.value,
                              prevState.value.snapshot
                            )
                          ) {
                            const value = prevState.value;
                            value._futureSnapshot = curr.value;
                            const children = (function(
                              routeReuseStrategy,
                              curr,
                              prevState
                            ) {
                              return curr.children.map(child => {
                                for (const p of prevState.children)
                                  if (
                                    routeReuseStrategy.shouldReuseRoute(
                                      p.value.snapshot,
                                      child.value
                                    )
                                  )
                                    return createNode(
                                      routeReuseStrategy,
                                      child,
                                      p
                                    );
                                return createNode(routeReuseStrategy, child);
                              });
                            })(routeReuseStrategy, curr, prevState);
                            return new TreeNode(value, children);
                          }
                          {
                            const detachedRouteHandle = routeReuseStrategy.retrieve(
                              curr.value
                            );
                            if (detachedRouteHandle) {
                              const tree = detachedRouteHandle.route;
                              return (
                                (function setFutureSnapshotsOfActivatedRoutes(
                                  curr,
                                  result
                                ) {
                                  if (
                                    curr.value.routeConfig !==
                                    result.value.routeConfig
                                  )
                                    throw new Error(
                                      'Cannot reattach ActivatedRouteSnapshot created from a different route'
                                    );
                                  if (
                                    curr.children.length !==
                                    result.children.length
                                  )
                                    throw new Error(
                                      'Cannot reattach ActivatedRouteSnapshot with a different number of children'
                                    );
                                  result.value._futureSnapshot = curr.value;
                                  for (let i = 0; i < curr.children.length; ++i)
                                    setFutureSnapshotsOfActivatedRoutes(
                                      curr.children[i],
                                      result.children[i]
                                    );
                                })(curr, tree),
                                tree
                              );
                            }
                            {
                              const value = new router_ActivatedRoute(
                                  new BehaviorSubject.a((c = curr.value).url),
                                  new BehaviorSubject.a(c.params),
                                  new BehaviorSubject.a(c.queryParams),
                                  new BehaviorSubject.a(c.fragment),
                                  new BehaviorSubject.a(c.data),
                                  c.outlet,
                                  c.component,
                                  c
                                ),
                                children = curr.children.map(c =>
                                  createNode(routeReuseStrategy, c)
                                );
                              return new TreeNode(value, children);
                            }
                          }
                          var c;
                        })(
                          routeReuseStrategy,
                          curr._root,
                          prevState ? prevState._root : void 0
                        );
                        return new RouterState(root, curr);
                      })(
                        this.routeReuseStrategy,
                        t.targetSnapshot,
                        t.currentRouterState
                      );
                      return Object.assign(Object.assign({}, t), {
                        targetRouterState: targetRouterState
                      });
                    }),
                    Object(tap.a)(t => {
                      (this.currentUrlTree = t.urlAfterRedirects),
                        (this.rawUrlTree = this.urlHandlingStrategy.merge(
                          this.currentUrlTree,
                          t.rawUrl
                        )),
                        (this.routerState = t.targetRouterState),
                        'deferred' === this.urlUpdateStrategy &&
                          (t.extras.skipLocationChange ||
                            this.setBrowserUrl(
                              this.rawUrlTree,
                              !!t.extras.replaceUrl,
                              t.id,
                              t.extras.state
                            ),
                          (this.browserUrlTree = t.urlAfterRedirects));
                    }),
                    ((rootContexts = this.rootContexts),
                    (routeReuseStrategy = this.routeReuseStrategy),
                    (forwardEvent = evt => this.triggerEvent(evt)),
                    Object(map.a)(
                      t => (
                        new ActivateRoutes(
                          routeReuseStrategy,
                          t.targetRouterState,
                          t.currentRouterState,
                          forwardEvent
                        ).activate(rootContexts),
                        t
                      )
                    )),
                    Object(tap.a)({
                      next() {
                        completed = !0;
                      },
                      complete() {
                        completed = !0;
                      }
                    }),
                    ((callback = () => {
                      if (!completed && !errored) {
                        this.resetUrlToCurrentUrlTree();
                        const navCancel = new NavigationCancel(
                          t.id,
                          this.serializeUrl(t.extractedUrl),
                          `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`
                        );
                        eventsSubject.next(navCancel), t.resolve(!1);
                      }
                      this.currentNavigation = null;
                    }),
                    source => source.lift(new FinallyOperator(callback))),
                    Object(catchError.a)(e => {
                      if (
                        ((errored = !0),
                        (error = e) && error.ngNavigationCancelingError)
                      ) {
                        const redirecting = isUrlTree(e.url);
                        redirecting ||
                          ((this.navigated = !0),
                          this.resetStateAndUrl(
                            t.currentRouterState,
                            t.currentUrlTree,
                            t.rawUrl
                          ));
                        const navCancel = new NavigationCancel(
                          t.id,
                          this.serializeUrl(t.extractedUrl),
                          e.message
                        );
                        eventsSubject.next(navCancel),
                          redirecting
                            ? setTimeout(() => {
                                const mergedTree = this.urlHandlingStrategy.merge(
                                  e.url,
                                  this.rawUrlTree
                                );
                                return this.scheduleNavigation(
                                  mergedTree,
                                  'imperative',
                                  null,
                                  {
                                    skipLocationChange:
                                      t.extras.skipLocationChange,
                                    replaceUrl:
                                      'eager' === this.urlUpdateStrategy
                                  },
                                  {
                                    resolve: t.resolve,
                                    reject: t.reject,
                                    promise: t.promise
                                  }
                                );
                              }, 0)
                            : t.resolve(!1);
                      } else {
                        this.resetStateAndUrl(
                          t.currentRouterState,
                          t.currentUrlTree,
                          t.rawUrl
                        );
                        const navError = new NavigationError(
                          t.id,
                          this.serializeUrl(t.extractedUrl),
                          e
                        );
                        eventsSubject.next(navError);
                        try {
                          t.resolve(this.errorHandler(e));
                        } catch (ee) {
                          t.reject(ee);
                        }
                      }
                      var error;
                      return empty.a;
                    })
                  );
                  var callback, rootContexts, routeReuseStrategy, forwardEvent;
                })
              );
            }
            resetRootComponentType(rootComponentType) {
              (this.rootComponentType = rootComponentType),
                (this.routerState.root.component = this.rootComponentType);
            }
            getTransition() {
              const transition = this.transitions.value;
              return (
                (transition.urlAfterRedirects = this.browserUrlTree), transition
              );
            }
            setTransition(t) {
              this.transitions.next(
                Object.assign(Object.assign({}, this.getTransition()), t)
              );
            }
            initialNavigation() {
              this.setUpLocationChangeListener(),
                0 === this.navigationId &&
                  this.navigateByUrl(this.location.path(!0), {
                    replaceUrl: !0
                  });
            }
            setUpLocationChangeListener() {
              this.locationSubscription ||
                (this.locationSubscription = this.location.subscribe(change => {
                  let rawUrlTree = this.parseUrl(change.url);
                  const source =
                      'popstate' === change.type ? 'popstate' : 'hashchange',
                    state =
                      change.state && change.state.navigationId
                        ? change.state
                        : null;
                  setTimeout(() => {
                    this.scheduleNavigation(rawUrlTree, source, state, {
                      replaceUrl: !0
                    });
                  }, 0);
                }));
            }
            get url() {
              return this.serializeUrl(this.currentUrlTree);
            }
            getCurrentNavigation() {
              return this.currentNavigation;
            }
            triggerEvent(event) {
              this.events.next(event);
            }
            resetConfig(config) {
              validateConfig(config),
                (this.config = config.map(standardizeConfig)),
                (this.navigated = !1),
                (this.lastSuccessfulId = -1);
            }
            ngOnDestroy() {
              this.dispose();
            }
            dispose() {
              this.locationSubscription &&
                (this.locationSubscription.unsubscribe(),
                (this.locationSubscription = null));
            }
            createUrlTree(commands, navigationExtras = {}) {
              const {
                relativeTo: relativeTo,
                queryParams: queryParams,
                fragment: fragment,
                preserveQueryParams: preserveQueryParams,
                queryParamsHandling: queryParamsHandling,
                preserveFragment: preserveFragment
              } = navigationExtras;
              Object(core.T)() &&
                preserveQueryParams &&
                console &&
                console.warn &&
                console.warn(
                  'preserveQueryParams is deprecated, use queryParamsHandling instead.'
                );
              const a = relativeTo || this.routerState.root,
                f = preserveFragment ? this.currentUrlTree.fragment : fragment;
              let q = null;
              if (queryParamsHandling)
                switch (queryParamsHandling) {
                  case 'merge':
                    q = Object.assign(
                      Object.assign({}, this.currentUrlTree.queryParams),
                      queryParams
                    );
                    break;
                  case 'preserve':
                    q = this.currentUrlTree.queryParams;
                    break;
                  default:
                    q = queryParams || null;
                }
              else
                q = preserveQueryParams
                  ? this.currentUrlTree.queryParams
                  : queryParams || null;
              return (
                null !== q && (q = this.removeEmptyProps(q)),
                (function(route, urlTree, commands, queryParams, fragment) {
                  if (0 === commands.length)
                    return router_tree(
                      urlTree.root,
                      urlTree.root,
                      urlTree,
                      queryParams,
                      fragment
                    );
                  const nav = (function(commands) {
                    if (
                      'string' == typeof commands[0] &&
                      1 === commands.length &&
                      '/' === commands[0]
                    )
                      return new Navigation(!0, 0, commands);
                    let numberOfDoubleDots = 0,
                      isAbsolute = !1;
                    const res = commands.reduce((res, cmd, cmdIdx) => {
                      if ('object' == typeof cmd && null != cmd) {
                        if (cmd.outlets) {
                          const outlets = {};
                          return (
                            forEach(cmd.outlets, (commands, name) => {
                              outlets[name] =
                                'string' == typeof commands
                                  ? commands.split('/')
                                  : commands;
                            }),
                            [...res, { outlets: outlets }]
                          );
                        }
                        if (cmd.segmentPath) return [...res, cmd.segmentPath];
                      }
                      return 'string' != typeof cmd
                        ? [...res, cmd]
                        : 0 === cmdIdx
                        ? (cmd.split('/').forEach((urlPart, partIndex) => {
                            (0 == partIndex && '.' === urlPart) ||
                              (0 == partIndex && '' === urlPart
                                ? (isAbsolute = !0)
                                : '..' === urlPart
                                ? numberOfDoubleDots++
                                : '' != urlPart && res.push(urlPart));
                          }),
                          res)
                        : [...res, cmd];
                    }, []);
                    return new Navigation(isAbsolute, numberOfDoubleDots, res);
                  })(commands);
                  if (nav.toRoot())
                    return router_tree(
                      urlTree.root,
                      new UrlSegmentGroup([], {}),
                      urlTree,
                      queryParams,
                      fragment
                    );
                  const startingPosition = (function(nav, tree, route) {
                      if (nav.isAbsolute) return new Position(tree.root, !0, 0);
                      if (-1 === route.snapshot._lastPathIndex) {
                        const segmentGroup = route.snapshot._urlSegment;
                        return new Position(
                          segmentGroup,
                          segmentGroup === tree.root,
                          0
                        );
                      }
                      const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
                      return (function(group, index, numberOfDoubleDots) {
                        let g = group,
                          ci = index,
                          dd = numberOfDoubleDots;
                        for (; dd > ci; ) {
                          if (((dd -= ci), (g = g.parent), !g))
                            throw new Error("Invalid number of '../'");
                          ci = g.segments.length;
                        }
                        return new Position(g, !1, ci - dd);
                      })(
                        route.snapshot._urlSegment,
                        route.snapshot._lastPathIndex + modifier,
                        nav.numberOfDoubleDots
                      );
                    })(nav, urlTree, route),
                    segmentGroup = startingPosition.processChildren
                      ? updateSegmentGroupChildren(
                          startingPosition.segmentGroup,
                          startingPosition.index,
                          nav.commands
                        )
                      : updateSegmentGroup(
                          startingPosition.segmentGroup,
                          startingPosition.index,
                          nav.commands
                        );
                  return router_tree(
                    startingPosition.segmentGroup,
                    segmentGroup,
                    urlTree,
                    queryParams,
                    fragment
                  );
                })(a, this.currentUrlTree, commands, q, f)
              );
            }
            navigateByUrl(url, extras = { skipLocationChange: !1 }) {
              Object(core.T)() &&
                this.isNgZoneEnabled &&
                !core.z.isInAngularZone() &&
                this.console.warn(
                  "Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?"
                );
              const urlTree = isUrlTree(url) ? url : this.parseUrl(url),
                mergedTree = this.urlHandlingStrategy.merge(
                  urlTree,
                  this.rawUrlTree
                );
              return this.scheduleNavigation(
                mergedTree,
                'imperative',
                null,
                extras
              );
            }
            navigate(commands, extras = { skipLocationChange: !1 }) {
              return (
                (function(commands) {
                  for (let i = 0; i < commands.length; i++) {
                    const cmd = commands[i];
                    if (null == cmd)
                      throw new Error(
                        `The requested path contains ${cmd} segment at index ${i}`
                      );
                  }
                })(commands),
                this.navigateByUrl(this.createUrlTree(commands, extras), extras)
              );
            }
            serializeUrl(url) {
              return this.urlSerializer.serialize(url);
            }
            parseUrl(url) {
              let urlTree;
              try {
                urlTree = this.urlSerializer.parse(url);
              } catch (e) {
                urlTree = this.malformedUriErrorHandler(
                  e,
                  this.urlSerializer,
                  url
                );
              }
              return urlTree;
            }
            isActive(url, exact) {
              if (isUrlTree(url))
                return containsTree(this.currentUrlTree, url, exact);
              const urlTree = this.parseUrl(url);
              return containsTree(this.currentUrlTree, urlTree, exact);
            }
            removeEmptyProps(params) {
              return Object.keys(params).reduce((result, key) => {
                const value = params[key];
                return null != value && (result[key] = value), result;
              }, {});
            }
            processNavigations() {
              this.navigations.subscribe(
                t => {
                  (this.navigated = !0),
                    (this.lastSuccessfulId = t.id),
                    this.events.next(
                      new NavigationEnd(
                        t.id,
                        this.serializeUrl(t.extractedUrl),
                        this.serializeUrl(this.currentUrlTree)
                      )
                    ),
                    (this.lastSuccessfulNavigation = this.currentNavigation),
                    (this.currentNavigation = null),
                    t.resolve(!0);
                },
                e => {
                  this.console.warn('Unhandled Navigation Error: ');
                }
              );
            }
            scheduleNavigation(
              rawUrl,
              source,
              restoredState,
              extras,
              priorPromise
            ) {
              const lastNavigation = this.getTransition();
              if (
                lastNavigation &&
                'imperative' !== source &&
                'imperative' === lastNavigation.source &&
                lastNavigation.rawUrl.toString() === rawUrl.toString()
              )
                return Promise.resolve(!0);
              if (
                lastNavigation &&
                'hashchange' == source &&
                'popstate' === lastNavigation.source &&
                lastNavigation.rawUrl.toString() === rawUrl.toString()
              )
                return Promise.resolve(!0);
              if (
                lastNavigation &&
                'popstate' == source &&
                'hashchange' === lastNavigation.source &&
                lastNavigation.rawUrl.toString() === rawUrl.toString()
              )
                return Promise.resolve(!0);
              let resolve, reject, promise;
              priorPromise
                ? ((resolve = priorPromise.resolve),
                  (reject = priorPromise.reject),
                  (promise = priorPromise.promise))
                : (promise = new Promise((res, rej) => {
                    (resolve = res), (reject = rej);
                  }));
              const id = ++this.navigationId;
              return (
                this.setTransition({
                  id: id,
                  source: source,
                  restoredState: restoredState,
                  currentUrlTree: this.currentUrlTree,
                  currentRawUrl: this.rawUrlTree,
                  rawUrl: rawUrl,
                  extras: extras,
                  resolve: resolve,
                  reject: reject,
                  promise: promise,
                  currentSnapshot: this.routerState.snapshot,
                  currentRouterState: this.routerState
                }),
                promise.catch(e => Promise.reject(e))
              );
            }
            setBrowserUrl(url, replaceUrl, id, state) {
              const path = this.urlSerializer.serialize(url);
              (state = state || {}),
                this.location.isCurrentPathEqualTo(path) || replaceUrl
                  ? this.location.replaceState(
                      path,
                      '',
                      Object.assign(Object.assign({}, state), {
                        navigationId: id
                      })
                    )
                  : this.location.go(
                      path,
                      '',
                      Object.assign(Object.assign({}, state), {
                        navigationId: id
                      })
                    );
            }
            resetStateAndUrl(storedState, storedUrl, rawUrl) {
              (this.routerState = storedState),
                (this.currentUrlTree = storedUrl),
                (this.rawUrlTree = this.urlHandlingStrategy.merge(
                  this.currentUrlTree,
                  rawUrl
                )),
                this.resetUrlToCurrentUrlTree();
            }
            resetUrlToCurrentUrlTree() {
              this.location.replaceState(
                this.urlSerializer.serialize(this.rawUrlTree),
                '',
                { navigationId: this.lastSuccessfulId }
              );
            }
          }
          return (
            (Router.ɵfac = function(t) {
              return new (t || Router)(
                core.Yb(core.M),
                core.Yb(UrlSerializer),
                core.Yb(ChildrenOutletContexts),
                core.Yb(common.g),
                core.Yb(core.r),
                core.Yb(core.w),
                core.Yb(core.i),
                core.Yb(void 0)
              );
            }),
            (Router.ɵprov = core.Hb({ token: Router, factory: Router.ɵfac })),
            Router
          );
        })(),
        router_RouterLinkWithHref = (() => {
          class RouterLinkWithHref {
            constructor(router, route, locationStrategy) {
              (this.router = router),
                (this.route = route),
                (this.locationStrategy = locationStrategy),
                (this.commands = []),
                (this.subscription = router.events.subscribe(s => {
                  s instanceof NavigationEnd && this.updateTargetUrlAndHref();
                }));
            }
            set routerLink(commands) {
              this.commands =
                null != commands
                  ? Array.isArray(commands)
                    ? commands
                    : [commands]
                  : [];
            }
            set preserveQueryParams(value) {
              Object(core.T)() &&
                console &&
                console.warn &&
                console.warn(
                  'preserveQueryParams is deprecated, use queryParamsHandling instead.'
                ),
                (this.preserve = value);
            }
            ngOnChanges(changes) {
              this.updateTargetUrlAndHref();
            }
            ngOnDestroy() {
              this.subscription.unsubscribe();
            }
            onClick(button, ctrlKey, metaKey, shiftKey) {
              if (0 !== button || ctrlKey || metaKey || shiftKey) return !0;
              if ('string' == typeof this.target && '_self' != this.target)
                return !0;
              const extras = {
                skipLocationChange: attrBoolValue(this.skipLocationChange),
                replaceUrl: attrBoolValue(this.replaceUrl),
                state: this.state
              };
              return this.router.navigateByUrl(this.urlTree, extras), !1;
            }
            updateTargetUrlAndHref() {
              this.href = this.locationStrategy.prepareExternalUrl(
                this.router.serializeUrl(this.urlTree)
              );
            }
            get urlTree() {
              return this.router.createUrlTree(this.commands, {
                relativeTo: this.route,
                queryParams: this.queryParams,
                fragment: this.fragment,
                preserveQueryParams: attrBoolValue(this.preserve),
                queryParamsHandling: this.queryParamsHandling,
                preserveFragment: attrBoolValue(this.preserveFragment)
              });
            }
          }
          return (
            (RouterLinkWithHref.ɵfac = function(t) {
              return new (t || RouterLinkWithHref)(
                core.Lb(router_Router),
                core.Lb(router_ActivatedRoute),
                core.Lb(common.h)
              );
            }),
            (RouterLinkWithHref.ɵdir = core.Gb({
              type: RouterLinkWithHref,
              selectors: [['a', 'routerLink', ''], ['area', 'routerLink', '']],
              hostVars: 2,
              hostBindings: function(rf, ctx) {
                1 & rf &&
                  core.bc('click', function($event) {
                    return ctx.onClick(
                      $event.button,
                      $event.ctrlKey,
                      $event.metaKey,
                      $event.shiftKey
                    );
                  }),
                  2 & rf &&
                    (core.Tb('href', ctx.href, core.yc),
                    core.yb('target', ctx.target));
              },
              inputs: {
                routerLink: 'routerLink',
                preserveQueryParams: 'preserveQueryParams',
                target: 'target',
                queryParams: 'queryParams',
                fragment: 'fragment',
                queryParamsHandling: 'queryParamsHandling',
                preserveFragment: 'preserveFragment',
                skipLocationChange: 'skipLocationChange',
                replaceUrl: 'replaceUrl',
                state: 'state'
              },
              features: [core.vb]
            })),
            RouterLinkWithHref
          );
        })();
      function attrBoolValue(s) {
        return '' === s || !!s;
      }
      let router_RouterOutlet = (() => {
        class RouterOutlet {
          constructor(
            parentContexts,
            location,
            resolver,
            name,
            changeDetector
          ) {
            (this.parentContexts = parentContexts),
              (this.location = location),
              (this.resolver = resolver),
              (this.changeDetector = changeDetector),
              (this.activated = null),
              (this._activatedRoute = null),
              (this.activateEvents = new core.n()),
              (this.deactivateEvents = new core.n()),
              (this.name = name || 'primary'),
              parentContexts.onChildOutletCreated(this.name, this);
          }
          ngOnDestroy() {
            this.parentContexts.onChildOutletDestroyed(this.name);
          }
          ngOnInit() {
            if (!this.activated) {
              const context = this.parentContexts.getContext(this.name);
              context &&
                context.route &&
                (context.attachRef
                  ? this.attach(context.attachRef, context.route)
                  : this.activateWith(context.route, context.resolver || null));
            }
          }
          get isActivated() {
            return !!this.activated;
          }
          get component() {
            if (!this.activated) throw new Error('Outlet is not activated');
            return this.activated.instance;
          }
          get activatedRoute() {
            if (!this.activated) throw new Error('Outlet is not activated');
            return this._activatedRoute;
          }
          get activatedRouteData() {
            return this._activatedRoute
              ? this._activatedRoute.snapshot.data
              : {};
          }
          detach() {
            if (!this.activated) throw new Error('Outlet is not activated');
            this.location.detach();
            const cmp = this.activated;
            return (this.activated = null), (this._activatedRoute = null), cmp;
          }
          attach(ref, activatedRoute) {
            (this.activated = ref),
              (this._activatedRoute = activatedRoute),
              this.location.insert(ref.hostView);
          }
          deactivate() {
            if (this.activated) {
              const c = this.component;
              this.activated.destroy(),
                (this.activated = null),
                (this._activatedRoute = null),
                this.deactivateEvents.emit(c);
            }
          }
          activateWith(activatedRoute, resolver) {
            if (this.isActivated)
              throw new Error('Cannot activate an already activated outlet');
            this._activatedRoute = activatedRoute;
            const factory = (resolver =
                resolver || this.resolver).resolveComponentFactory(
                activatedRoute._futureSnapshot.routeConfig.component
              ),
              childContexts = this.parentContexts.getOrCreateContext(this.name)
                .children,
              injector = new OutletInjector(
                activatedRoute,
                childContexts,
                this.location.injector
              );
            (this.activated = this.location.createComponent(
              factory,
              this.location.length,
              injector
            )),
              this.changeDetector.markForCheck(),
              this.activateEvents.emit(this.activated.instance);
          }
        }
        return (
          (RouterOutlet.ɵfac = function(t) {
            return new (t || RouterOutlet)(
              core.Lb(ChildrenOutletContexts),
              core.Lb(core.O),
              core.Lb(core.j),
              core.Zb('name'),
              core.Lb(core.h)
            );
          }),
          (RouterOutlet.ɵdir = core.Gb({
            type: RouterOutlet,
            selectors: [['router-outlet']],
            outputs: {
              activateEvents: 'activate',
              deactivateEvents: 'deactivate'
            },
            exportAs: ['outlet']
          })),
          RouterOutlet
        );
      })();
      class OutletInjector {
        constructor(route, childContexts, parent) {
          (this.route = route),
            (this.childContexts = childContexts),
            (this.parent = parent);
        }
        get(token, notFoundValue) {
          return token === router_ActivatedRoute
            ? this.route
            : token === ChildrenOutletContexts
            ? this.childContexts
            : this.parent.get(token, notFoundValue);
        }
      }
      class PreloadingStrategy {}
      class router_PreloadAllModules {
        preload(route, fn) {
          return fn().pipe(Object(catchError.a)(() => Object(of.a)(null)));
        }
      }
      class router_NoPreloading {
        preload(route, fn) {
          return Object(of.a)(null);
        }
      }
      let router_RouterPreloader = (() => {
          class RouterPreloader {
            constructor(
              router,
              moduleLoader,
              compiler,
              injector,
              preloadingStrategy
            ) {
              (this.router = router),
                (this.injector = injector),
                (this.preloadingStrategy = preloadingStrategy),
                (this.loader = new router_RouterConfigLoader(
                  moduleLoader,
                  compiler,
                  r => router.triggerEvent(new RouteConfigLoadStart(r)),
                  r => router.triggerEvent(new RouteConfigLoadEnd(r))
                ));
            }
            setUpPreloading() {
              this.subscription = this.router.events
                .pipe(
                  Object(filter.a)(e => e instanceof NavigationEnd),
                  Object(concatMap.a)(() => this.preload())
                )
                .subscribe(() => {});
            }
            preload() {
              const ngModule = this.injector.get(core.x);
              return this.processRoutes(ngModule, this.router.config);
            }
            ngOnDestroy() {
              this.subscription.unsubscribe();
            }
            processRoutes(ngModule, routes) {
              const res = [];
              for (const route of routes)
                if (
                  route.loadChildren &&
                  !route.canLoad &&
                  route._loadedConfig
                ) {
                  const childConfig = route._loadedConfig;
                  res.push(
                    this.processRoutes(childConfig.module, childConfig.routes)
                  );
                } else
                  route.loadChildren && !route.canLoad
                    ? res.push(this.preloadConfig(ngModule, route))
                    : route.children &&
                      res.push(this.processRoutes(ngModule, route.children));
              return Object(from.a)(res).pipe(
                Object(mergeAll.a)(),
                Object(map.a)(_ => {})
              );
            }
            preloadConfig(ngModule, route) {
              return this.preloadingStrategy.preload(route, () =>
                this.loader
                  .load(ngModule.injector, route)
                  .pipe(
                    Object(mergeMap.a)(
                      config => (
                        (route._loadedConfig = config),
                        this.processRoutes(config.module, config.routes)
                      )
                    )
                  )
              );
            }
          }
          return (
            (RouterPreloader.ɵfac = function(t) {
              return new (t || RouterPreloader)(
                core.Yb(router_Router),
                core.Yb(core.w),
                core.Yb(core.i),
                core.Yb(core.r),
                core.Yb(PreloadingStrategy)
              );
            }),
            (RouterPreloader.ɵprov = core.Hb({
              token: RouterPreloader,
              factory: RouterPreloader.ɵfac
            })),
            RouterPreloader
          );
        })(),
        router_RouterScroller = (() => {
          class RouterScroller {
            constructor(router, viewportScroller, options = {}) {
              (this.router = router),
                (this.viewportScroller = viewportScroller),
                (this.options = options),
                (this.lastId = 0),
                (this.lastSource = 'imperative'),
                (this.restoredId = 0),
                (this.store = {}),
                (options.scrollPositionRestoration =
                  options.scrollPositionRestoration || 'disabled'),
                (options.anchorScrolling =
                  options.anchorScrolling || 'disabled');
            }
            init() {
              'disabled' !== this.options.scrollPositionRestoration &&
                this.viewportScroller.setHistoryScrollRestoration('manual'),
                (this.routerEventsSubscription = this.createScrollEvents()),
                (this.scrollEventsSubscription = this.consumeScrollEvents());
            }
            createScrollEvents() {
              return this.router.events.subscribe(e => {
                e instanceof NavigationStart
                  ? ((this.store[
                      this.lastId
                    ] = this.viewportScroller.getScrollPosition()),
                    (this.lastSource = e.navigationTrigger),
                    (this.restoredId = e.restoredState
                      ? e.restoredState.navigationId
                      : 0))
                  : e instanceof NavigationEnd &&
                    ((this.lastId = e.id),
                    this.scheduleScrollEvent(
                      e,
                      this.router.parseUrl(e.urlAfterRedirects).fragment
                    ));
              });
            }
            consumeScrollEvents() {
              return this.router.events.subscribe(e => {
                e instanceof Scroll &&
                  (e.position
                    ? 'top' === this.options.scrollPositionRestoration
                      ? this.viewportScroller.scrollToPosition([0, 0])
                      : 'enabled' === this.options.scrollPositionRestoration &&
                        this.viewportScroller.scrollToPosition(e.position)
                    : e.anchor && 'enabled' === this.options.anchorScrolling
                    ? this.viewportScroller.scrollToAnchor(e.anchor)
                    : 'disabled' !== this.options.scrollPositionRestoration &&
                      this.viewportScroller.scrollToPosition([0, 0]));
              });
            }
            scheduleScrollEvent(routerEvent, anchor) {
              this.router.triggerEvent(
                new Scroll(
                  routerEvent,
                  'popstate' === this.lastSource
                    ? this.store[this.restoredId]
                    : null,
                  anchor
                )
              );
            }
            ngOnDestroy() {
              this.routerEventsSubscription &&
                this.routerEventsSubscription.unsubscribe(),
                this.scrollEventsSubscription &&
                  this.scrollEventsSubscription.unsubscribe();
            }
          }
          return (
            (RouterScroller.ɵfac = function(t) {
              return new (t || RouterScroller)(
                core.Yb(router_Router),
                core.Yb(common.q),
                core.Yb(void 0)
              );
            }),
            (RouterScroller.ɵprov = core.Hb({
              token: RouterScroller,
              factory: RouterScroller.ɵfac
            })),
            RouterScroller
          );
        })();
      const ROUTER_CONFIGURATION = new core.q('ROUTER_CONFIGURATION'),
        ROUTER_FORROOT_GUARD = new core.q('ROUTER_FORROOT_GUARD'),
        ROUTER_PROVIDERS = [
          common.g,
          { provide: UrlSerializer, useClass: DefaultUrlSerializer },
          {
            provide: router_Router,
            useFactory: function(
              urlSerializer,
              contexts,
              location,
              injector,
              loader,
              compiler,
              config,
              opts = {},
              urlHandlingStrategy,
              routeReuseStrategy
            ) {
              const router = new router_Router(
                null,
                urlSerializer,
                contexts,
                location,
                injector,
                loader,
                compiler,
                flatten(config)
              );
              if (
                (urlHandlingStrategy &&
                  (router.urlHandlingStrategy = urlHandlingStrategy),
                routeReuseStrategy &&
                  (router.routeReuseStrategy = routeReuseStrategy),
                opts.errorHandler && (router.errorHandler = opts.errorHandler),
                opts.malformedUriErrorHandler &&
                  (router.malformedUriErrorHandler =
                    opts.malformedUriErrorHandler),
                opts.enableTracing)
              ) {
                const dom = Object(common.y)();
                router.events.subscribe(e => {
                  dom.logGroup('Router Event: ' + e.constructor.name),
                    dom.log(e.toString()),
                    dom.log(e),
                    dom.logGroupEnd();
                });
              }
              return (
                opts.onSameUrlNavigation &&
                  (router.onSameUrlNavigation = opts.onSameUrlNavigation),
                opts.paramsInheritanceStrategy &&
                  (router.paramsInheritanceStrategy =
                    opts.paramsInheritanceStrategy),
                opts.urlUpdateStrategy &&
                  (router.urlUpdateStrategy = opts.urlUpdateStrategy),
                opts.relativeLinkResolution &&
                  (router.relativeLinkResolution = opts.relativeLinkResolution),
                router
              );
            },
            deps: [
              UrlSerializer,
              ChildrenOutletContexts,
              common.g,
              core.r,
              core.w,
              core.i,
              ROUTES,
              ROUTER_CONFIGURATION,
              [class {}, new core.A()],
              [RouteReuseStrategy, new core.A()]
            ]
          },
          ChildrenOutletContexts,
          {
            provide: router_ActivatedRoute,
            useFactory: function(router) {
              return router.routerState.root;
            },
            deps: [router_Router]
          },
          { provide: core.w, useClass: core.J },
          router_RouterPreloader,
          router_NoPreloading,
          router_PreloadAllModules,
          { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: !1 } }
        ];
      function routerNgProbeToken() {
        return new core.y('Router', router_Router);
      }
      let router_RouterModule = (() => {
        class RouterModule {
          constructor(guard, router) {}
          static forRoot(routes, config) {
            return {
              ngModule: RouterModule,
              providers: [
                ROUTER_PROVIDERS,
                provideRoutes(routes),
                {
                  provide: ROUTER_FORROOT_GUARD,
                  useFactory: provideForRootGuard,
                  deps: [[router_Router, new core.A(), new core.I()]]
                },
                { provide: ROUTER_CONFIGURATION, useValue: config || {} },
                {
                  provide: common.h,
                  useFactory: provideLocationStrategy,
                  deps: [
                    common.o,
                    [new core.p(common.a), new core.A()],
                    ROUTER_CONFIGURATION
                  ]
                },
                {
                  provide: router_RouterScroller,
                  useFactory: createRouterScroller,
                  deps: [router_Router, common.q, ROUTER_CONFIGURATION]
                },
                {
                  provide: PreloadingStrategy,
                  useExisting:
                    config && config.preloadingStrategy
                      ? config.preloadingStrategy
                      : router_NoPreloading
                },
                { provide: core.y, multi: !0, useFactory: routerNgProbeToken },
                [
                  router_RouterInitializer,
                  {
                    provide: core.d,
                    multi: !0,
                    useFactory: getAppInitializer,
                    deps: [router_RouterInitializer]
                  },
                  {
                    provide: ROUTER_INITIALIZER,
                    useFactory: getBootstrapListener,
                    deps: [router_RouterInitializer]
                  },
                  {
                    provide: core.b,
                    multi: !0,
                    useExisting: ROUTER_INITIALIZER
                  }
                ]
              ]
            };
          }
          static forChild(routes) {
            return {
              ngModule: RouterModule,
              providers: [provideRoutes(routes)]
            };
          }
        }
        return (
          (RouterModule.ɵmod = core.Jb({ type: RouterModule })),
          (RouterModule.ɵinj = core.Ib({
            factory: function(t) {
              return new (t || RouterModule)(
                core.Yb(ROUTER_FORROOT_GUARD, 8),
                core.Yb(router_Router, 8)
              );
            }
          })),
          RouterModule
        );
      })();
      function createRouterScroller(router, viewportScroller, config) {
        return (
          config.scrollOffset &&
            viewportScroller.setOffset(config.scrollOffset),
          new router_RouterScroller(router, viewportScroller, config)
        );
      }
      function provideLocationStrategy(
        platformLocationStrategy,
        baseHref,
        options = {}
      ) {
        return options.useHash
          ? new common.e(platformLocationStrategy, baseHref)
          : new common.n(platformLocationStrategy, baseHref);
      }
      function provideForRootGuard(router) {
        if (router)
          throw new Error(
            'RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.'
          );
        return 'guarded';
      }
      function provideRoutes(routes) {
        return [
          { provide: core.a, multi: !0, useValue: routes },
          { provide: ROUTES, multi: !0, useValue: routes }
        ];
      }
      let router_RouterInitializer = (() => {
        class RouterInitializer {
          constructor(injector) {
            (this.injector = injector),
              (this.initNavigation = !1),
              (this.resultOfPreactivationDone = new Subject.a());
          }
          appInitializer() {
            return this.injector
              .get(common.f, Promise.resolve(null))
              .then(() => {
                let resolve = null;
                const res = new Promise(r => (resolve = r)),
                  router = this.injector.get(router_Router),
                  opts = this.injector.get(ROUTER_CONFIGURATION);
                if (this.isLegacyDisabled(opts) || this.isLegacyEnabled(opts))
                  resolve(!0);
                else if ('disabled' === opts.initialNavigation)
                  router.setUpLocationChangeListener(), resolve(!0);
                else {
                  if ('enabled' !== opts.initialNavigation)
                    throw new Error(
                      `Invalid initialNavigation options: '${opts.initialNavigation}'`
                    );
                  (router.hooks.afterPreactivation = () =>
                    this.initNavigation
                      ? Object(of.a)(null)
                      : ((this.initNavigation = !0),
                        resolve(!0),
                        this.resultOfPreactivationDone)),
                    router.initialNavigation();
                }
                return res;
              });
          }
          bootstrapListener(bootstrappedComponentRef) {
            const opts = this.injector.get(ROUTER_CONFIGURATION),
              preloader = this.injector.get(router_RouterPreloader),
              routerScroller = this.injector.get(router_RouterScroller),
              router = this.injector.get(router_Router),
              ref = this.injector.get(core.g);
            bootstrappedComponentRef === ref.components[0] &&
              (this.isLegacyEnabled(opts)
                ? router.initialNavigation()
                : this.isLegacyDisabled(opts) &&
                  router.setUpLocationChangeListener(),
              preloader.setUpPreloading(),
              routerScroller.init(),
              router.resetRootComponentType(ref.componentTypes[0]),
              this.resultOfPreactivationDone.next(null),
              this.resultOfPreactivationDone.complete());
          }
          isLegacyEnabled(opts) {
            return (
              'legacy_enabled' === opts.initialNavigation ||
              !0 === opts.initialNavigation ||
              void 0 === opts.initialNavigation
            );
          }
          isLegacyDisabled(opts) {
            return (
              'legacy_disabled' === opts.initialNavigation ||
              !1 === opts.initialNavigation
            );
          }
        }
        return (
          (RouterInitializer.ɵfac = function(t) {
            return new (t || RouterInitializer)(core.Yb(core.r));
          }),
          (RouterInitializer.ɵprov = core.Hb({
            token: RouterInitializer,
            factory: RouterInitializer.ɵfac
          })),
          RouterInitializer
        );
      })();
      function getAppInitializer(r) {
        return r.appInitializer.bind(r);
      }
      function getBootstrapListener(r) {
        return r.bootstrapListener.bind(r);
      }
      const ROUTER_INITIALIZER = new core.q('Router Initializer');
    },
    tycR: function(module, exports, __webpack_require__) {
      var bind = __webpack_require__('+MLx'),
        IndexedObject = __webpack_require__('RK3t'),
        toObject = __webpack_require__('ewvW'),
        toLength = __webpack_require__('UMSQ'),
        arraySpeciesCreate = __webpack_require__('ZfDv'),
        push = [].push,
        createMethod = function(TYPE) {
          var IS_MAP = 1 == TYPE,
            IS_FILTER = 2 == TYPE,
            IS_SOME = 3 == TYPE,
            IS_EVERY = 4 == TYPE,
            IS_FIND_INDEX = 6 == TYPE,
            NO_HOLES = 5 == TYPE || IS_FIND_INDEX;
          return function($this, callbackfn, that, specificCreate) {
            for (
              var value,
                result,
                O = toObject($this),
                self = IndexedObject(O),
                boundFunction = bind(callbackfn, that, 3),
                length = toLength(self.length),
                index = 0,
                create = specificCreate || arraySpeciesCreate,
                target = IS_MAP
                  ? create($this, length)
                  : IS_FILTER
                  ? create($this, 0)
                  : void 0;
              length > index;
              index++
            )
              if (
                (NO_HOLES || index in self) &&
                ((result = boundFunction((value = self[index]), index, O)),
                TYPE)
              )
                if (IS_MAP) target[index] = result;
                else if (result)
                  switch (TYPE) {
                    case 3:
                      return !0;
                    case 5:
                      return value;
                    case 6:
                      return index;
                    case 2:
                      push.call(target, value);
                  }
                else if (IS_EVERY) return !1;
            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
          };
        };
      module.exports = {
        forEach: createMethod(0),
        map: createMethod(1),
        filter: createMethod(2),
        some: createMethod(3),
        every: createMethod(4),
        find: createMethod(5),
        findIndex: createMethod(6)
      };
    },
    uy83: function(module, exports, __webpack_require__) {
      var fails = __webpack_require__('0Dky');
      module.exports = !fails(function() {
        return Object.isExtensible(Object.preventExtensions({}));
      });
    },
    uyHG: function(module, exports) {
      var uid,
        reIsHostCtor = /^\[object .+?Constructor\]$/,
        freeGlobal =
          'object' == typeof global &&
          global &&
          global.Object === Object &&
          global,
        freeSelf =
          'object' == typeof self && self && self.Object === Object && self,
        root = freeGlobal || freeSelf || Function('return this')(),
        arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype,
        coreJsData = root['__core-js_shared__'],
        maskSrcKey = (uid = /[^.]+$/.exec(
          (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ''
        ))
          ? 'Symbol(src)_1.' + uid
          : '',
        funcToString = funcProto.toString,
        hasOwnProperty = objectProto.hasOwnProperty,
        objectToString = objectProto.toString,
        reIsNative = RegExp(
          '^' +
            funcToString
              .call(hasOwnProperty)
              .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
              .replace(
                /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                '$1.*?'
              ) +
            '$'
        ),
        splice = arrayProto.splice,
        Map = getNative(root, 'Map'),
        nativeCreate = getNative(Object, 'create');
      function Hash(entries) {
        var index = -1,
          length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function ListCache(entries) {
        var index = -1,
          length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function MapCache(entries) {
        var index = -1,
          length = entries ? entries.length : 0;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function assocIndexOf(array, key) {
        for (var value, other, length = array.length; length--; )
          if (
            (value = array[length][0]) === (other = key) ||
            (value != value && other != other)
          )
            return length;
        return -1;
      }
      function getMapData(map, key) {
        var value,
          type,
          data = map.__data__;
        return ('string' == (type = typeof (value = key)) ||
        'number' == type ||
        'symbol' == type ||
        'boolean' == type
        ? '__proto__' !== value
        : null === value)
          ? data['string' == typeof key ? 'string' : 'hash']
          : data.map;
      }
      function getNative(object, key) {
        var value = (function(object, key) {
          return null == object ? void 0 : object[key];
        })(object, key);
        return (function(value) {
          return (
            !(
              !isObject(value) ||
              ((func = value), maskSrcKey && maskSrcKey in func)
            ) &&
            ((function(value) {
              var tag = isObject(value) ? objectToString.call(value) : '';
              return (
                '[object Function]' == tag ||
                '[object GeneratorFunction]' == tag
              );
            })(value) ||
            (function(value) {
              var result = !1;
              if (null != value && 'function' != typeof value.toString)
                try {
                  result = !!(value + '');
                } catch (e) {}
              return result;
            })(value)
              ? reIsNative
              : reIsHostCtor
            ).test(
              (function(func) {
                if (null != func) {
                  try {
                    return funcToString.call(func);
                  } catch (e) {}
                  try {
                    return func + '';
                  } catch (e) {}
                }
                return '';
              })(value)
            )
          );
          var func;
        })(value)
          ? value
          : void 0;
      }
      function memoize(func, resolver) {
        if (
          'function' != typeof func ||
          (resolver && 'function' != typeof resolver)
        )
          throw new TypeError('Expected a function');
        var memoized = function() {
          var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;
          if (cache.has(key)) return cache.get(key);
          var result = func.apply(this, args);
          return (memoized.cache = cache.set(key, result)), result;
        };
        return (memoized.cache = new (memoize.Cache || MapCache)()), memoized;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && ('object' == type || 'function' == type);
      }
      (Hash.prototype.clear = function() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }),
        (Hash.prototype.delete = function(key) {
          return this.has(key) && delete this.__data__[key];
        }),
        (Hash.prototype.get = function(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return '__lodash_hash_undefined__' === result ? void 0 : result;
          }
          return hasOwnProperty.call(data, key) ? data[key] : void 0;
        }),
        (Hash.prototype.has = function(key) {
          var data = this.__data__;
          return nativeCreate
            ? void 0 !== data[key]
            : hasOwnProperty.call(data, key);
        }),
        (Hash.prototype.set = function(key, value) {
          return (
            (this.__data__[key] =
              nativeCreate && void 0 === value
                ? '__lodash_hash_undefined__'
                : value),
            this
          );
        }),
        (ListCache.prototype.clear = function() {
          this.__data__ = [];
        }),
        (ListCache.prototype.delete = function(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          return !(
            index < 0 ||
            (index == data.length - 1
              ? data.pop()
              : splice.call(data, index, 1),
            0)
          );
        }),
        (ListCache.prototype.get = function(key) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          return index < 0 ? void 0 : data[index][1];
        }),
        (ListCache.prototype.has = function(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }),
        (ListCache.prototype.set = function(key, value) {
          var data = this.__data__,
            index = assocIndexOf(data, key);
          return (
            index < 0 ? data.push([key, value]) : (data[index][1] = value), this
          );
        }),
        (MapCache.prototype.clear = function() {
          this.__data__ = {
            hash: new Hash(),
            map: new (Map || ListCache)(),
            string: new Hash()
          };
        }),
        (MapCache.prototype.delete = function(key) {
          return getMapData(this, key).delete(key);
        }),
        (MapCache.prototype.get = function(key) {
          return getMapData(this, key).get(key);
        }),
        (MapCache.prototype.has = function(key) {
          return getMapData(this, key).has(key);
        }),
        (MapCache.prototype.set = function(key, value) {
          return getMapData(this, key).set(key, value), this;
        }),
        (memoize.Cache = MapCache),
        (module.exports = memoize);
    },
    vauT: function(module, exports, __webpack_require__) {
      'use strict';
      function __getInputValues() {
        var _inputs = document.querySelectorAll('input, textarea, select');
        return Array.prototype.slice.call(_inputs).map(function(input) {
          var inputTagName = input.tagName.toLowerCase(),
            inputType = input.type,
            inputId = input.id && 'string' == typeof input.id ? input.id : null,
            inputName =
              input.name && 'string' == typeof input.name ? input.name : null,
            inputValue =
              input.value && 'string' == typeof input.value
                ? input.value
                : null,
            inputChildNodes = input.childNodes,
            inputSelected = Boolean(input.selected),
            elementStore = {
              tag: inputTagName,
              type: null,
              id: inputId,
              name: inputName,
              value: '',
              checked: !1,
              options: []
            };
          if ('input' === inputTagName || 'textarea' === inputTagName) {
            if (((elementStore.type = inputType), 'input' !== inputTagName))
              return (elementStore.value = inputValue), elementStore;
            switch (inputType) {
              case 'checkbox':
              case 'radio':
                return (
                  (elementStore.checked = inputSelected),
                  (elementStore.value = inputValue),
                  elementStore
                );
              case 'image':
              case 'button':
              case 'submit':
              case 'reset':
              default:
                return elementStore;
            }
          } else if ('select' === inputTagName) {
            var options = Array.prototype.slice
              .call(inputChildNodes)
              .map(function(option, i) {
                return {
                  value: option.value,
                  selected: Boolean(option.selected)
                };
              });
            return (elementStore.options = options), elementStore;
          }
          return elementStore;
        });
      }
      function __setInputValues($inputs) {
        var inputs = document.querySelectorAll('input, textarea');
        $inputs.forEach(function(store, i) {
          if ('input' === store.tag || 'textarea' === store.tag)
            if (
              'input' !== store.tag ||
              ('checkbox' !== store.type && 'radio' !== store.type)
            )
              ('input' !== store.tagName.toLowerCase() ||
                ('image' !== store.type &&
                  'button' !== store.type &&
                  'submit' !== store.type &&
                  'reset' !== store.type)) &&
                (null === store.id && null === store.name
                  ? !store.value.length ||
                    !inputs[i] ||
                    inputs[i].tagName.toLowerCase() !== store.tag ||
                    ('textarea' !== store.tag &&
                      inputs[i].getAttribute('type') !== store.type) ||
                    ('string' == typeof inputs[i].id && inputs[i].id.length) ||
                    ('string' == typeof inputs[i].getAttribute('name') &&
                      inputs[i].getAttribute('name').length) ||
                    ((inputs[i].value = store.value),
                    inputs[i].dispatchEvent(
                      new CustomEvent('input', { detail: inputs[i].value })
                    ))
                  : ((selector =
                      'input' +
                      (null !== store.id ? '#' + store.id : '') +
                      ('input' === store.tag
                        ? '[type="' + store.type + '"]'
                        : '') +
                      (null !== store.name
                        ? '[name="' + store.name + '"]'
                        : '')),
                    (element = document.body.querySelector(selector)) &&
                      store.value.length &&
                      ((element.value = store.value),
                      element.dispatchEvent(
                        new CustomEvent('input', { detail: element.value })
                      ))));
            else {
              var selector =
                'input' +
                (null !== store.id ? '#' + store.id : '') +
                '[type="' +
                store.type +
                '"]' +
                (null !== store.name ? '[name="' + store.name + '"]' : '') +
                '[value="' +
                store.value +
                '"]';
              (element = document.body.querySelector(selector)) &&
                Boolean(store.checked) &&
                ((element.checked = 'checked'),
                element.dispatchEvent(
                  new CustomEvent('input', { detail: element.checked })
                ));
            }
          else if ('select' === store.tag) {
            var element,
              select_1 = null;
            null === store.id && null === store.name
              ? !inputs[i] ||
                inputs[i].tagName.toLowerCase() !== store.tag ||
                ('string' == typeof inputs[i].id && inputs[i].id.length) ||
                ('string' == typeof inputs[i].getAttribute('name') &&
                  inputs[i].getAttribute('name').length) ||
                (select_1 = inputs[i])
              : ((selector =
                  'select' +
                  (null !== store.id ? '#' + store.id : '') +
                  (null !== store.name ? '[name="' + store.name + '"]' : '')),
                (element = document.body.querySelector(selector)) &&
                  (select_1 = element)),
              select_1 &&
                store.options.forEach(function(storedOption, j) {
                  var option = select_1.querySelector(
                    'option[value="' + storedOption.value + '"]'
                  );
                  option ||
                    !select_1.childNodes[j] ||
                    ('string' == typeof select_1.childNodes[j].value &&
                      select_1.childNodes[j].value.length) ||
                    (option = select_1.childNodes[j]),
                    option &&
                      storedOption.selected &&
                      ((option.selected = 'selected'),
                      option.dispatchEvent(
                        new CustomEvent('input', { detail: option.selected })
                      ));
                });
          }
        });
      }
      Object.defineProperty(exports, '__esModule', { value: !0 }),
        (exports.__getInputValues = __getInputValues),
        (exports.__setInputValues = __setInputValues),
        (exports.__createInputTransfer = function() {
          var $inputs = __getInputValues();
          return function() {
            return __setInputValues($inputs);
          };
        });
    },
    vkgz: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return tap;
      });
      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          '7o/Q'
        ),
        _util_noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__('KqfI'),
        _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'n6bG'
        );
      function tap(nextOrObserver, error, complete) {
        return function(source) {
          return source.lift(new DoOperator(nextOrObserver, error, complete));
        };
      }
      class DoOperator {
        constructor(nextOrObserver, error, complete) {
          (this.nextOrObserver = nextOrObserver),
            (this.error = error),
            (this.complete = complete);
        }
        call(subscriber, source) {
          return source.subscribe(
            new TapSubscriber(
              subscriber,
              this.nextOrObserver,
              this.error,
              this.complete
            )
          );
        }
      }
      class TapSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(destination, observerOrNext, error, complete) {
          super(destination),
            (this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_1__.a),
            (this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_1__.a),
            (this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_1__.a),
            (this._tapError =
              error || _util_noop__WEBPACK_IMPORTED_MODULE_1__.a),
            (this._tapComplete =
              complete || _util_noop__WEBPACK_IMPORTED_MODULE_1__.a),
            Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__.a)(
              observerOrNext
            )
              ? ((this._context = this), (this._tapNext = observerOrNext))
              : observerOrNext &&
                ((this._context = observerOrNext),
                (this._tapNext =
                  observerOrNext.next ||
                  _util_noop__WEBPACK_IMPORTED_MODULE_1__.a),
                (this._tapError =
                  observerOrNext.error ||
                  _util_noop__WEBPACK_IMPORTED_MODULE_1__.a),
                (this._tapComplete =
                  observerOrNext.complete ||
                  _util_noop__WEBPACK_IMPORTED_MODULE_1__.a));
        }
        _next(value) {
          try {
            this._tapNext.call(this._context, value);
          } catch (err) {
            return void this.destination.error(err);
          }
          this.destination.next(value);
        }
        _error(err) {
          try {
            this._tapError.call(this._context, err);
          } catch (err) {
            return void this.destination.error(err);
          }
          this.destination.error(err);
        }
        _complete() {
          try {
            this._tapComplete.call(this._context);
          } catch (err) {
            return void this.destination.error(err);
          }
          return this.destination.complete();
        }
      }
    },
    w1tV: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return share;
      });
      var Subject = __webpack_require__('XNiG'),
        Observable = __webpack_require__('HDdC'),
        Subscriber = __webpack_require__('7o/Q'),
        Subscription = __webpack_require__('quSY');
      function refCount() {
        return function(source) {
          return source.lift(new RefCountOperator(source));
        };
      }
      class RefCountOperator {
        constructor(connectable) {
          this.connectable = connectable;
        }
        call(subscriber, source) {
          const { connectable: connectable } = this;
          connectable._refCount++;
          const refCounter = new refCount_RefCountSubscriber(
              subscriber,
              connectable
            ),
            subscription = source.subscribe(refCounter);
          return (
            refCounter.closed ||
              (refCounter.connection = connectable.connect()),
            subscription
          );
        }
      }
      class refCount_RefCountSubscriber extends Subscriber.a {
        constructor(destination, connectable) {
          super(destination), (this.connectable = connectable);
        }
        _unsubscribe() {
          const { connectable: connectable } = this;
          if (!connectable) return void (this.connection = null);
          this.connectable = null;
          const refCount = connectable._refCount;
          if (refCount <= 0) return void (this.connection = null);
          if (((connectable._refCount = refCount - 1), refCount > 1))
            return void (this.connection = null);
          const { connection: connection } = this,
            sharedConnection = connectable._connection;
          (this.connection = null),
            !sharedConnection ||
              (connection && sharedConnection !== connection) ||
              sharedConnection.unsubscribe();
        }
      }
      class ConnectableObservable_ConnectableObservable extends Observable.a {
        constructor(source, subjectFactory) {
          super(),
            (this.source = source),
            (this.subjectFactory = subjectFactory),
            (this._refCount = 0),
            (this._isComplete = !1);
        }
        _subscribe(subscriber) {
          return this.getSubject().subscribe(subscriber);
        }
        getSubject() {
          const subject = this._subject;
          return (
            (subject && !subject.isStopped) ||
              (this._subject = this.subjectFactory()),
            this._subject
          );
        }
        connect() {
          let connection = this._connection;
          return (
            connection ||
              ((this._isComplete = !1),
              (connection = this._connection = new Subscription.a()),
              connection.add(
                this.source.subscribe(
                  new ConnectableObservable_ConnectableSubscriber(
                    this.getSubject(),
                    this
                  )
                )
              ),
              connection.closed &&
                ((this._connection = null),
                (connection = Subscription.a.EMPTY))),
            connection
          );
        }
        refCount() {
          return refCount()(this);
        }
      }
      const connectableObservableDescriptor = (() => {
        const connectableProto =
          ConnectableObservable_ConnectableObservable.prototype;
        return {
          operator: { value: null },
          _refCount: { value: 0, writable: !0 },
          _subject: { value: null, writable: !0 },
          _connection: { value: null, writable: !0 },
          _subscribe: { value: connectableProto._subscribe },
          _isComplete: { value: connectableProto._isComplete, writable: !0 },
          getSubject: { value: connectableProto.getSubject },
          connect: { value: connectableProto.connect },
          refCount: { value: connectableProto.refCount }
        };
      })();
      class ConnectableObservable_ConnectableSubscriber extends Subject.b {
        constructor(destination, connectable) {
          super(destination), (this.connectable = connectable);
        }
        _error(err) {
          this._unsubscribe(), super._error(err);
        }
        _complete() {
          (this.connectable._isComplete = !0),
            this._unsubscribe(),
            super._complete();
        }
        _unsubscribe() {
          const connectable = this.connectable;
          if (connectable) {
            this.connectable = null;
            const connection = connectable._connection;
            (connectable._refCount = 0),
              (connectable._subject = null),
              (connectable._connection = null),
              connection && connection.unsubscribe();
          }
        }
      }
      function shareSubjectFactory() {
        return new Subject.a();
      }
      function share() {
        return source => {
          return refCount()(
            ((subjectOrSubjectFactory = shareSubjectFactory),
            function(source) {
              let subjectFactory;
              subjectFactory =
                'function' == typeof subjectOrSubjectFactory
                  ? subjectOrSubjectFactory
                  : function() {
                      return subjectOrSubjectFactory;
                    };
              const connectable = Object.create(
                source,
                connectableObservableDescriptor
              );
              return (
                (connectable.source = source),
                (connectable.subjectFactory = subjectFactory),
                connectable
              );
            })(source)
          );
          var subjectOrSubjectFactory;
        };
      }
    },
    wE6v: function(module, exports, __webpack_require__) {
      var isObject = __webpack_require__('hh1v');
      module.exports = function(input, PREFERRED_STRING) {
        if (!isObject(input)) return input;
        var fn, val;
        if (
          PREFERRED_STRING &&
          'function' == typeof (fn = input.toString) &&
          !isObject((val = fn.call(input)))
        )
          return val;
        if (
          'function' == typeof (fn = input.valueOf) &&
          !isObject((val = fn.call(input)))
        )
          return val;
        if (
          !PREFERRED_STRING &&
          'function' == typeof (fn = input.toString) &&
          !isObject((val = fn.call(input)))
        )
          return val;
        throw TypeError("Can't convert object to primitive value");
      };
    },
    wHSu: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return faBullseye;
      }),
        __webpack_require__.d(__webpack_exports__, 'b', function() {
          return faCalendarAlt;
        }),
        __webpack_require__.d(__webpack_exports__, 'c', function() {
          return faChartLine;
        }),
        __webpack_require__.d(__webpack_exports__, 'd', function() {
          return faCheck;
        }),
        __webpack_require__.d(__webpack_exports__, 'e', function() {
          return faChevronDown;
        }),
        __webpack_require__.d(__webpack_exports__, 'f', function() {
          return faEnvelope;
        }),
        __webpack_require__.d(__webpack_exports__, 'g', function() {
          return faFileInvoice;
        }),
        __webpack_require__.d(__webpack_exports__, 'h', function() {
          return faHeart;
        }),
        __webpack_require__.d(__webpack_exports__, 'i', function() {
          return faInfoCircle;
        }),
        __webpack_require__.d(__webpack_exports__, 'j', function() {
          return faLightbulb;
        }),
        __webpack_require__.d(__webpack_exports__, 'k', function() {
          return faLongArrowAltLeft;
        }),
        __webpack_require__.d(__webpack_exports__, 'l', function() {
          return faLongArrowAltRight;
        }),
        __webpack_require__.d(__webpack_exports__, 'm', function() {
          return faMapMarker;
        }),
        __webpack_require__.d(__webpack_exports__, 'n', function() {
          return faPaperPlane;
        }),
        __webpack_require__.d(__webpack_exports__, 'o', function() {
          return faPhone;
        }),
        __webpack_require__.d(__webpack_exports__, 'p', function() {
          return faPlay;
        }),
        __webpack_require__.d(__webpack_exports__, 'q', function() {
          return faQuoteLeft;
        }),
        __webpack_require__.d(__webpack_exports__, 'r', function() {
          return faRss;
        }),
        __webpack_require__.d(__webpack_exports__, 's', function() {
          return faSignInAlt;
        }),
        __webpack_require__.d(__webpack_exports__, 't', function() {
          return faTag;
        }),
        __webpack_require__.d(__webpack_exports__, 'u', function() {
          return faUser;
        }),
        __webpack_require__.d(__webpack_exports__, 'v', function() {
          return faUserPlus;
        }),
        __webpack_require__.d(__webpack_exports__, 'w', function() {
          return faUserShield;
        }),
        __webpack_require__.d(__webpack_exports__, 'x', function() {
          return faUsersCog;
        });
      var faBullseye = {
          prefix: 'fas',
          iconName: 'bullseye',
          icon: [
            496,
            512,
            [],
            'f140',
            'M248 8C111.03 8 0 119.03 0 256s111.03 248 248 248 248-111.03 248-248S384.97 8 248 8zm0 432c-101.69 0-184-82.29-184-184 0-101.69 82.29-184 184-184 101.69 0 184 82.29 184 184 0 101.69-82.29 184-184 184zm0-312c-70.69 0-128 57.31-128 128s57.31 128 128 128 128-57.31 128-128-57.31-128-128-128zm0 192c-35.29 0-64-28.71-64-64s28.71-64 64-64 64 28.71 64 64-28.71 64-64 64z'
          ]
        },
        faCalendarAlt = {
          prefix: 'fas',
          iconName: 'calendar-alt',
          icon: [
            448,
            512,
            [],
            'f073',
            'M0 464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V192H0v272zm320-196c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zM192 268c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zM64 268c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zM400 64h-48V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48H160V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48H48C21.5 64 0 85.5 0 112v48h448v-48c0-26.5-21.5-48-48-48z'
          ]
        },
        faChartLine = {
          prefix: 'fas',
          iconName: 'chart-line',
          icon: [
            512,
            512,
            [],
            'f201',
            'M496 384H64V80c0-8.84-7.16-16-16-16H16C7.16 64 0 71.16 0 80v336c0 17.67 14.33 32 32 32h464c8.84 0 16-7.16 16-16v-32c0-8.84-7.16-16-16-16zM464 96H345.94c-21.38 0-32.09 25.85-16.97 40.97l32.4 32.4L288 242.75l-73.37-73.37c-12.5-12.5-32.76-12.5-45.25 0l-68.69 68.69c-6.25 6.25-6.25 16.38 0 22.63l22.62 22.62c6.25 6.25 16.38 6.25 22.63 0L192 237.25l73.37 73.37c12.5 12.5 32.76 12.5 45.25 0l96-96 32.4 32.4c15.12 15.12 40.97 4.41 40.97-16.97V112c.01-8.84-7.15-16-15.99-16z'
          ]
        },
        faCheck = {
          prefix: 'fas',
          iconName: 'check',
          icon: [
            512,
            512,
            [],
            'f00c',
            'M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z'
          ]
        },
        faChevronDown = {
          prefix: 'fas',
          iconName: 'chevron-down',
          icon: [
            448,
            512,
            [],
            'f078',
            'M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z'
          ]
        },
        faEnvelope = {
          prefix: 'fas',
          iconName: 'envelope',
          icon: [
            512,
            512,
            [],
            'f0e0',
            'M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z'
          ]
        },
        faFileInvoice = {
          prefix: 'fas',
          iconName: 'file-invoice',
          icon: [
            384,
            512,
            [],
            'f570',
            'M288 256H96v64h192v-64zm89-151L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128v-6.1c0-6.3-2.5-12.4-7-16.9zm-153 31V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zM64 72c0-4.42 3.58-8 8-8h80c4.42 0 8 3.58 8 8v16c0 4.42-3.58 8-8 8H72c-4.42 0-8-3.58-8-8V72zm0 64c0-4.42 3.58-8 8-8h80c4.42 0 8 3.58 8 8v16c0 4.42-3.58 8-8 8H72c-4.42 0-8-3.58-8-8v-16zm256 304c0 4.42-3.58 8-8 8h-80c-4.42 0-8-3.58-8-8v-16c0-4.42 3.58-8 8-8h80c4.42 0 8 3.58 8 8v16zm0-200v96c0 8.84-7.16 16-16 16H80c-8.84 0-16-7.16-16-16v-96c0-8.84 7.16-16 16-16h224c8.84 0 16 7.16 16 16z'
          ]
        },
        faHeart = {
          prefix: 'fas',
          iconName: 'heart',
          icon: [
            512,
            512,
            [],
            'f004',
            'M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z'
          ]
        },
        faInfoCircle = {
          prefix: 'fas',
          iconName: 'info-circle',
          icon: [
            512,
            512,
            [],
            'f05a',
            'M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z'
          ]
        },
        faLightbulb = {
          prefix: 'fas',
          iconName: 'lightbulb',
          icon: [
            352,
            512,
            [],
            'f0eb',
            'M96.06 454.35c.01 6.29 1.87 12.45 5.36 17.69l17.09 25.69a31.99 31.99 0 0 0 26.64 14.28h61.71a31.99 31.99 0 0 0 26.64-14.28l17.09-25.69a31.989 31.989 0 0 0 5.36-17.69l.04-38.35H96.01l.05 38.35zM0 176c0 44.37 16.45 84.85 43.56 115.78 16.52 18.85 42.36 58.23 52.21 91.45.04.26.07.52.11.78h160.24c.04-.26.07-.51.11-.78 9.85-33.22 35.69-72.6 52.21-91.45C335.55 260.85 352 220.37 352 176 352 78.61 272.91-.3 175.45 0 73.44.31 0 82.97 0 176zm176-80c-44.11 0-80 35.89-80 80 0 8.84-7.16 16-16 16s-16-7.16-16-16c0-61.76 50.24-112 112-112 8.84 0 16 7.16 16 16s-7.16 16-16 16z'
          ]
        },
        faLongArrowAltLeft = {
          prefix: 'fas',
          iconName: 'long-arrow-alt-left',
          icon: [
            448,
            512,
            [],
            'f30a',
            'M134.059 296H436c6.627 0 12-5.373 12-12v-56c0-6.627-5.373-12-12-12H134.059v-46.059c0-21.382-25.851-32.09-40.971-16.971L7.029 239.029c-9.373 9.373-9.373 24.569 0 33.941l86.059 86.059c15.119 15.119 40.971 4.411 40.971-16.971V296z'
          ]
        },
        faLongArrowAltRight = {
          prefix: 'fas',
          iconName: 'long-arrow-alt-right',
          icon: [
            448,
            512,
            [],
            'f30b',
            'M313.941 216H12c-6.627 0-12 5.373-12 12v56c0 6.627 5.373 12 12 12h301.941v46.059c0 21.382 25.851 32.09 40.971 16.971l86.059-86.059c9.373-9.373 9.373-24.569 0-33.941l-86.059-86.059c-15.119-15.119-40.971-4.411-40.971 16.971V216z'
          ]
        },
        faMapMarker = {
          prefix: 'fas',
          iconName: 'map-marker',
          icon: [
            384,
            512,
            [],
            'f041',
            'M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0z'
          ]
        },
        faPaperPlane = {
          prefix: 'fas',
          iconName: 'paper-plane',
          icon: [
            512,
            512,
            [],
            'f1d8',
            'M476 3.2L12.5 270.6c-18.1 10.4-15.8 35.6 2.2 43.2L121 358.4l287.3-253.2c5.5-4.9 13.3 2.6 8.6 8.3L176 407v80.5c0 23.6 28.5 32.9 42.5 15.8L282 426l124.6 52.2c14.2 6 30.4-2.9 33-18.2l72-432C515 7.8 493.3-6.8 476 3.2z'
          ]
        },
        faPhone = {
          prefix: 'fas',
          iconName: 'phone',
          icon: [
            512,
            512,
            [],
            'f095',
            'M493.4 24.6l-104-24c-11.3-2.6-22.9 3.3-27.5 13.9l-48 112c-4.2 9.8-1.4 21.3 6.9 28l60.6 49.6c-36 76.7-98.9 140.5-177.2 177.2l-49.6-60.6c-6.8-8.3-18.2-11.1-28-6.9l-112 48C3.9 366.5-2 378.1.6 389.4l24 104C27.1 504.2 36.7 512 48 512c256.1 0 464-207.5 464-464 0-11.2-7.7-20.9-18.6-23.4z'
          ]
        },
        faPlay = {
          prefix: 'fas',
          iconName: 'play',
          icon: [
            448,
            512,
            [],
            'f04b',
            'M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z'
          ]
        },
        faQuoteLeft = {
          prefix: 'fas',
          iconName: 'quote-left',
          icon: [
            512,
            512,
            [],
            'f10d',
            'M464 256h-80v-64c0-35.3 28.7-64 64-64h8c13.3 0 24-10.7 24-24V56c0-13.3-10.7-24-24-24h-8c-88.4 0-160 71.6-160 160v240c0 26.5 21.5 48 48 48h128c26.5 0 48-21.5 48-48V304c0-26.5-21.5-48-48-48zm-288 0H96v-64c0-35.3 28.7-64 64-64h8c13.3 0 24-10.7 24-24V56c0-13.3-10.7-24-24-24h-8C71.6 32 0 103.6 0 192v240c0 26.5 21.5 48 48 48h128c26.5 0 48-21.5 48-48V304c0-26.5-21.5-48-48-48z'
          ]
        },
        faRss = {
          prefix: 'fas',
          iconName: 'rss',
          icon: [
            448,
            512,
            [],
            'f09e',
            'M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z'
          ]
        },
        faSignInAlt = {
          prefix: 'fas',
          iconName: 'sign-in-alt',
          icon: [
            512,
            512,
            [],
            'f2f6',
            'M416 448h-84c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h84c17.7 0 32-14.3 32-32V160c0-17.7-14.3-32-32-32h-84c-6.6 0-12-5.4-12-12V76c0-6.6 5.4-12 12-12h84c53 0 96 43 96 96v192c0 53-43 96-96 96zm-47-201L201 79c-15-15-41-4.5-41 17v96H24c-13.3 0-24 10.7-24 24v96c0 13.3 10.7 24 24 24h136v96c0 21.5 26 32 41 17l168-168c9.3-9.4 9.3-24.6 0-34z'
          ]
        },
        faTag = {
          prefix: 'fas',
          iconName: 'tag',
          icon: [
            512,
            512,
            [],
            'f02b',
            'M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z'
          ]
        },
        faUser = {
          prefix: 'fas',
          iconName: 'user',
          icon: [
            448,
            512,
            [],
            'f007',
            'M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z'
          ]
        },
        faUserPlus = {
          prefix: 'fas',
          iconName: 'user-plus',
          icon: [
            640,
            512,
            [],
            'f234',
            'M624 208h-64v-64c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v64h-64c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h64v64c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16v-64h64c8.8 0 16-7.2 16-16v-32c0-8.8-7.2-16-16-16zm-400 48c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z'
          ]
        },
        faUserShield = {
          prefix: 'fas',
          iconName: 'user-shield',
          icon: [
            640,
            512,
            [],
            'f505',
            'M622.3 271.1l-115.2-45c-4.1-1.6-12.6-3.7-22.2 0l-115.2 45c-10.7 4.2-17.7 14-17.7 24.9 0 111.6 68.7 188.8 132.9 213.9 9.6 3.7 18 1.6 22.2 0C558.4 489.9 640 420.5 640 296c0-10.9-7-20.7-17.7-24.9zM496 462.4V273.3l95.5 37.3c-5.6 87.1-60.9 135.4-95.5 151.8zM224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm96 40c0-2.5.8-4.8 1.1-7.2-2.5-.1-4.9-.8-7.5-.8h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c6.8 0 13.3-1.5 19.2-4-54-42.9-99.2-116.7-99.2-212z'
          ]
        },
        faUsersCog = {
          prefix: 'fas',
          iconName: 'users-cog',
          icon: [
            640,
            512,
            [],
            'f509',
            'M610.5 341.3c2.6-14.1 2.6-28.5 0-42.6l25.8-14.9c3-1.7 4.3-5.2 3.3-8.5-6.7-21.6-18.2-41.2-33.2-57.4-2.3-2.5-6-3.1-9-1.4l-25.8 14.9c-10.9-9.3-23.4-16.5-36.9-21.3v-29.8c0-3.4-2.4-6.4-5.7-7.1-22.3-5-45-4.8-66.2 0-3.3.7-5.7 3.7-5.7 7.1v29.8c-13.5 4.8-26 12-36.9 21.3l-25.8-14.9c-2.9-1.7-6.7-1.1-9 1.4-15 16.2-26.5 35.8-33.2 57.4-1 3.3.4 6.8 3.3 8.5l25.8 14.9c-2.6 14.1-2.6 28.5 0 42.6l-25.8 14.9c-3 1.7-4.3 5.2-3.3 8.5 6.7 21.6 18.2 41.1 33.2 57.4 2.3 2.5 6 3.1 9 1.4l25.8-14.9c10.9 9.3 23.4 16.5 36.9 21.3v29.8c0 3.4 2.4 6.4 5.7 7.1 22.3 5 45 4.8 66.2 0 3.3-.7 5.7-3.7 5.7-7.1v-29.8c13.5-4.8 26-12 36.9-21.3l25.8 14.9c2.9 1.7 6.7 1.1 9-1.4 15-16.2 26.5-35.8 33.2-57.4 1-3.3-.4-6.8-3.3-8.5l-25.8-14.9zM496 368.5c-26.8 0-48.5-21.8-48.5-48.5s21.8-48.5 48.5-48.5 48.5 21.8 48.5 48.5-21.7 48.5-48.5 48.5zM96 224c35.3 0 64-28.7 64-64s-28.7-64-64-64-64 28.7-64 64 28.7 64 64 64zm224 32c1.9 0 3.7-.5 5.6-.6 8.3-21.7 20.5-42.1 36.3-59.2 7.4-8 17.9-12.6 28.9-12.6 6.9 0 13.7 1.8 19.6 5.3l7.9 4.6c.8-.5 1.6-.9 2.4-1.4 7-14.6 11.2-30.8 11.2-48 0-61.9-50.1-112-112-112S208 82.1 208 144c0 61.9 50.1 112 112 112zm105.2 194.5c-2.3-1.2-4.6-2.6-6.8-3.9-8.2 4.8-15.3 9.8-27.5 9.8-10.9 0-21.4-4.6-28.9-12.6-18.3-19.8-32.3-43.9-40.2-69.6-10.7-34.5 24.9-49.7 25.8-50.3-.1-2.6-.1-5.2 0-7.8l-7.9-4.6c-3.8-2.2-7-5-9.8-8.1-3.3.2-6.5.6-9.8.6-24.6 0-47.6-6-68.5-16h-8.3C179.6 288 128 339.6 128 403.2V432c0 26.5 21.5 48 48 48h255.4c-3.7-6-6.2-12.8-6.2-20.3v-9.2zM173.1 274.6C161.5 263.1 145.6 256 128 256H64c-35.3 0-64 28.7-64 64v32c0 17.7 14.3 32 32 32h65.9c6.3-47.4 34.9-87.3 75.2-109.4z'
          ]
        };
    },
    xDBR: function(module, exports) {
      module.exports = !1;
    },
    xbPD: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return defaultIfEmpty;
      });
      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        '7o/Q'
      );
      function defaultIfEmpty(defaultValue = null) {
        return source => source.lift(new DefaultIfEmptyOperator(defaultValue));
      }
      class DefaultIfEmptyOperator {
        constructor(defaultValue) {
          this.defaultValue = defaultValue;
        }
        call(subscriber, source) {
          return source.subscribe(
            new DefaultIfEmptySubscriber(subscriber, this.defaultValue)
          );
        }
      }
      class DefaultIfEmptySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
        constructor(destination, defaultValue) {
          super(destination),
            (this.defaultValue = defaultValue),
            (this.isEmpty = !0);
        }
        _next(value) {
          (this.isEmpty = !1), this.destination.next(value);
        }
        _complete() {
          this.isEmpty && this.destination.next(this.defaultValue),
            this.destination.complete();
        }
      }
    },
    xrYK: function(module, exports) {
      var toString = {}.toString;
      module.exports = function(it) {
        return toString.call(it).slice(8, -1);
      };
    },
    yCtX: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return fromArray;
      });
      var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          'HDdC'
        ),
        _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
          'ngJS'
        ),
        _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
          'jZKg'
        );
      function fromArray(input, scheduler) {
        return scheduler
          ? Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__.a)(
              input,
              scheduler
            )
          : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(
              Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__.a)(
                input
              )
            );
      }
    },
    yoRg: function(module, exports, __webpack_require__) {
      var has = __webpack_require__('UTVS'),
        toIndexedObject = __webpack_require__('/GqU'),
        indexOf = __webpack_require__('TWQb').indexOf,
        hiddenKeys = __webpack_require__('0BK2');
      module.exports = function(object, names) {
        var key,
          O = toIndexedObject(object),
          i = 0,
          result = [];
        for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
        for (; names.length > i; )
          has(O, (key = names[i++])) &&
            (~indexOf(result, key) || result.push(key));
        return result;
      };
    },
    'z+Ro': function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      function isScheduler(value) {
        return value && 'function' == typeof value.schedule;
      }
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return isScheduler;
      });
    },
    z6cu: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.d(__webpack_exports__, 'a', function() {
        return throwError;
      });
      var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
        'HDdC'
      );
      function throwError(error, scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(
          scheduler
            ? subscriber =>
                scheduler.schedule(dispatch, 0, {
                  error: error,
                  subscriber: subscriber
                })
            : subscriber => subscriber.error(error)
        );
      }
      function dispatch({ error: error, subscriber: subscriber }) {
        subscriber.error(error);
      }
    },
    zBJ4: function(module, exports, __webpack_require__) {
      var global = __webpack_require__('2oRo'),
        isObject = __webpack_require__('hh1v'),
        document = global.document,
        EXISTS = isObject(document) && isObject(document.createElement);
      module.exports = function(it) {
        return EXISTS ? document.createElement(it) : {};
      };
    },
    zKZe: function(module, exports, __webpack_require__) {
      var $ = __webpack_require__('I+eb'),
        assign = __webpack_require__('YNrV');
      $(
        { target: 'Object', stat: !0, forced: Object.assign !== assign },
        { assign: assign }
      );
    },
    zUnb: function(module, __webpack_exports__, __webpack_require__) {
      'use strict';
      __webpack_require__.r(__webpack_exports__),
        function(module) {
          var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
              'fXoL'
            ),
            _env_environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
              'AytR'
            ),
            _hmr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__('0QMH'),
            _app_app_module__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
              'ZAI4'
            ),
            _angular_platform_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
              'jhN1'
            );
          _env_environment__WEBPACK_IMPORTED_MODULE_1__.a.production &&
            Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.R)();
          const bootstrap = () =>
            _angular_platform_browser__WEBPACK_IMPORTED_MODULE_4__
              .e()
              .bootstrapModule(_app_app_module__WEBPACK_IMPORTED_MODULE_3__.a);
          _env_environment__WEBPACK_IMPORTED_MODULE_1__.a.hmr
            ? Object(_hmr__WEBPACK_IMPORTED_MODULE_2__.a)(module, bootstrap)
            : bootstrap().catch(err => console.error(err));
        }.call(this, __webpack_require__('3UD+')(module));
    },
    zk60: function(module, exports, __webpack_require__) {
      var global = __webpack_require__('2oRo'),
        hide = __webpack_require__('X2U+');
      module.exports = function(key, value) {
        try {
          hide(global, key, value);
        } catch (error) {
          global[key] = value;
        }
        return value;
      };
    },
    zn8P: function(module, exports) {
      function webpackEmptyAsyncContext(req) {
        return Promise.resolve().then(function() {
          var e = new Error("Cannot find module '" + req + "'");
          throw ((e.code = 'MODULE_NOT_FOUND'), e);
        });
      }
      (webpackEmptyAsyncContext.keys = function() {
        return [];
      }),
        (webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext),
        (module.exports = webpackEmptyAsyncContext),
        (webpackEmptyAsyncContext.id = 'zn8P');
    }
  },
  [[0, 3]]
]);
